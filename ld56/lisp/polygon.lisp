(defun polygon:new (vertices color)
    (let ((poly (list :vertices)))
        (set poly.triangleCount (/ (length vertices) 3))
        (if color
            (set poly.color (Float32Array.from color)) 
            (set poly.color (Float32Array.from vertices (lambda (x) 1.0))))

        (set poly.type 'polygon)
        (set poly.buffer nil)
        (set poly.colorBuffer nil)
        (set poly.vertices (float32-array-from vertices))

        poly))

(defun polygon:new-points (vertices sizes color)
  (let ((poly (list :points)))
	 (set poly.count (/ (length vertices) 3))
	 (set poly.color color)
	 (set poly.vertices vertices)
	 (set poly.sizes sizes)
	 (set poly.colorBuffer nil)
	 (set poly.buffer nil)
	 (set poly.type 'points)
	 (set poly.sizeBuffer nil)
	 (set poly.vao nil)
	 poly))
(defvar model::bound-va nil)
(defun polygon:load (poly)
  (unless poly.vao
	 (set poly.vao (gl.createVertexArray))
	 (gl.bindVertexArray poly.vao)
	 (set poly.buffer (gl.createBuffer))
	 (gl.bindBuffer gl.ARRAY_BUFFER poly.buffer)
	 (gl.vertexAttribPointer 0 3 gl.FLOAT false 0 0)
    (gl.enableVertexAttribArray 0)

    (set poly.colorBuffer (gl.createBuffer))
	 (gl.bindBuffer gl.ARRAY_BUFFER poly.colorBuffer)
	 (gl.vertexAttribPointer 1 3 gl.FLOAT false 0 0)
    (gl.enableVertexAttribArray 1)
	 (gl.bindVertexArray nil)
	 )
  		
  (gl.bindBuffer gl.ARRAY_BUFFER poly.buffer)
  (gl.bufferData gl.ARRAY_BUFFER poly.vertices gl.STATIC_DRAW)
  (gl.bindBuffer gl.ARRAY_BUFFER poly.colorBuffer)
  (gl.bufferData gl.ARRAY_BUFFER poly.color gl.STATIC_DRAW))
	
(defun polygon:delete (poly)   
    (when poly.buffer
        (gl.bindBuffer gl.ARRAY_BUFFER nil)
        (gl.deleteBuffer poly.buffer)
        (set poly.buffer nil)))

(defun polygon:draw (poly)
  (unless poly.vao
    (polygon:load poly))
  (unless (eq model::bound-va poly.vao)
	 (gl.bindVertexArray poly.vao)
	 (set model::bound-va poly.vao)
	 )
  (gl.drawArrays gl.TRIANGLE_STRIP 0 poly.triangleCount)
  ;(gl.bindVertexArray nil)
  )

