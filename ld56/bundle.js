/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./rtc.js":
/*!****************!*\
  !*** ./rtc.js ***!
  \****************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var nats_ws__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nats.ws */ \"./node_modules/nats.ws/esm/nats.js\");\n //\"https://unpkg.com/nats.ws/nats.mjs\";\nlet localConnection, remoteConnection, dataChannel, sendMessageBtn, messageInput, messagesDiv;\n\nsendMessageBtn = document.getElementById('sendMessageBtn');\nmessageInput = document.getElementById('messageInput');\nmessagesDiv = document.getElementById('messages');\n\n// Initialize WebRTC peer connections and data channel\nfunction initWebRTC() {\n  // Create two RTCPeerConnection instances (acting as peers in this demo)\n  localConnection = new RTCPeerConnection();\n  remoteConnection = new RTCPeerConnection();\n\n  // Create a data channel on the local connection\n  dataChannel = localConnection.createDataChannel(\"messageChannel\");\n\n  // Set up event listeners for the data channel\n  dataChannel.onopen = () => console.log('Data channel is open');\n  dataChannel.onclose = () => console.log('Data channel is closed');\n  dataChannel.onmessage = receiveMessage;\n\n  // When the remote connection receives a data channel, set its event listeners\n  remoteConnection.ondatachannel = (event) => {\n    let remoteChannel = event.channel;\n    remoteChannel.onmessage = receiveMessage;\n    remoteChannel.onopen = () => console.log('Remote data channel is open');\n    remoteChannel.onclose = () => console.log('Remote data channel is closed');\n  };\n\n\t\n  // Set up ICE candidate exchange\n\t localConnection.onicecandidate = (event) => {\n\t\t  console.log(event)\n\t\tif (event.candidate) {\n\t\t\t \n      remoteConnection.addIceCandidate(event.candidate);\n    }\n  };\n\n\t remoteConnection.onicecandidate = (event) => {\n\t\t  console.log(event)\n    if (event.candidate) {\n      localConnection.addIceCandidate(event.candidate);\n    }\n  };\n\n  // Create an offer to start the connection process\n  localConnection.createOffer()\n\t\t  .then(offer => {\n\t\t\t\tconsole.log(offer)\n      return localConnection.setLocalDescription(offer);\n    })\n\t\t  .then(() => {\n\t\t\t\tconsole.log(localConnection.localDescription)\n      return remoteConnection.setRemoteDescription(localConnection.localDescription);\n    })\n    .then(() => {\n      return remoteConnection.createAnswer();\n    })\n\t\t  .then(answer => {\n\t\t\t\tconsole.log(answer)\n      return remoteConnection.setLocalDescription(answer);\n    })\n\t\t  .then(() => {\n\t\t\t\tconsole.log(remoteConnection.localDescription)\n      return localConnection.setRemoteDescription(remoteConnection.localDescription);\n    })\n    .catch(error => console.error('Error during WebRTC setup: ', error));\n}\n\n// Function to send a message over the data channel\nfunction sendMessage() {\n  const message = messageInput.value;\n  if (dataChannel.readyState === 'open') {\n    dataChannel.send(message);\n    displayMessage(`Sent: ${message}`);\n  }\n}\n\nfunction sendMessage2(message) {\n  if (dataChannel.readyState === 'open') {\n    dataChannel.send(message);\n    displayMessage(`Sent: ${message}`);\n  }\n}\n\n// Function to handle incoming messages\nfunction receiveMessage(event) {\n  const message = event.data;\n  displayMessage(`Received: ${message}`);\n}\n\n// Utility function to display messages\nfunction displayMessage(message) {\n  const messageElem = document.createElement('div');\n  messageElem.textContent = message;\n  messagesDiv.appendChild(messageElem);\n}\n\n// Attach event listener for sending messages\n//sendMessageBtn.addEventListener('click', sendMessage);\n\n// Initialize WebRTC\n//initWebRTC();\n\n//let s1 = \"wss://connect.ngs.global\";\n//let s1 = \"wss://demo.nats.io:8443\"\n //const authenticator = credsAuthenticator(creds);\nasync function setupNATS() {\n\t const nc = await (0,nats_ws__WEBPACK_IMPORTED_MODULE_0__.connect)({ servers: s1, authenticator: authenticator });  console.log(\"Connected to NATS and listening for messages\");\n\t nc.publish(\"foo.bar\", \"123\")\n\t nc.publish(\"foo.bar\", \"1234\")\n\t nc.publish(\"foo.bar\", \"12345\")\n\t const chat = await nc.subscribe(\"foo.*\");\n\t for await (const m of chat) {\n\t\t  console.log(m)\n\t }\n}\n\n//nats = setupNATS\n\n//setupNATS();\n\n\n//# sourceURL=webpack:///./rtc.js?");

/***/ }),

/***/ "../../src/foxlisp-web.js":
/*!********************************!*\
  !*** ../../src/foxlisp-web.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! ./lisp */ \"../../src/lisp.js\")\n\nlet load_file = (filePath) => {\n\t\n\treturn fetch(filePath)\n\t \t\n\t\t  .then(response => {\n\t\t\tif (!response.ok) {\n\t\t\t\treturn \"(println 'file-not-found \\\"\" + filePath + \"\\\")\"\n\t\t\t}\n\t\t\treturn response.text()\n\t\t\t\n\t\t  })\n\t\t  \n}\n\nfunction WriteCodeToLog(code){\n\treturn;\n}\nwriteCodetoLog = WriteCodeToLog\nloadFileAsync = load_file\n\nconsole.log(\"foxlisp JS loaded!\")\n\n\n//# sourceURL=webpack:///../../src/foxlisp-web.js?");

/***/ }),

/***/ "../../src/lisp.js":
/*!*************************!*\
  !*** ../../src/lisp.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const parser = __webpack_require__(/*! ./lispy_parser */ \"../../src/lispy_parser.js\")\nconst lisp = __webpack_require__(/*! ./symbols */ \"../../src/symbols.js\")\n\nfunction sym(x, jsname){\n    return lisp.sym(x, jsname)\n}\n\nfunction issym(x){\n\t return x && x.type == \"symbol\";\n}\n\n___sym = lisp.lisp.symbols\n__quotes = []\nconst quotes_lookup = new Map()\nfunction _getQuote(id) {\n    return __quotes[id]\n}\ngetQuote = _getQuote\nfunction setQuote(newQuote){\n\t \n\t let existing = quotes_lookup.get(newQuote)\n\t \n\t if(existing) {\n\t\t  return existing\n\t }\n    let id = __quotes.length;\n    __quotes.length += 1\n    __quotes[id] = newQuote\n\t quotes_lookup.set(newQuote, id)\n    return id\n}\n\nlookupsym = lisp.getsym\ncar = (x) => x && x[0]\ncdr = (x) => x && x.slice(1)\nop_add = (x, y) => x + y\nop_sub = (x, y) => x - y\nop_div = (x, y) => x / y\nop_mul = (x, y) => x * y\nop_leftshift = (x, y) => x << y;\nop_rightshift = (x, y) => x >> y;\nop_xor = (x, y) => x ^ y;\nop_or = (x,y) => x|y;\nop_and = (x,y) => x&y\n\nmod = (x, y) => x % y\nnot = (x) => !x\nlen = (x) => (x && x.length) || 0\nlist = (...x) => x\n__undefined = undefined\n\neq = (a, b) => a === b;\nslice = (a, n) => a && (a.length <= n ? null : a.slice(n));\n_raise = (err) => {throw err;}\n\nusplice = (x) => ({type: \"unsplice\", value: x})\n\nloadfile = (x, loadcontext) => ({type: \"load\", value: x, loadcontext: loadcontext})\n\nmacroLookup = new Map();\n\nismacro = (x) => macroLookup.has(x)\n\nulist = (...x) => {\n\t let out = []\n\t for (let elem of x){\n\t\t  if(elem == undefined){\n\t\t\t\tthrow new Error(\"content is undefined\" + x);\n\t\t  }\n\t\t  if(typeof(elem) == \"object\" && elem.type == \"unsplice\"){\n\t\t\t\tfor (let elem2 of elem.value){\n\t\t\t\t\t out.push(elem2);\n\t\t\t\t}\n\t\t\t\t\n\t\t  }else{\n\t\t\t\tout.push(elem);\n\t\t  }\n\t }\n\t \n\t return out\n}\n\nfunction escapeString(x){\n\t return x.replace(/\"/g, '\"\"').replace(/\\n/g, '\\\\n')\n}\n\ngetsym = (s) => sym(s, null)\n\nfunction println_impl(obj){\n\t if(Array.isArray(obj) || obj instanceof Float32Array){\n\t\t  \n\t\t  let strOut = \"\"\n\t\t  let first = true\n\t\t  \n\t\t  strOut += \"(\"\n\t\t  \n\t\t  for(let elem of obj){\n\t\t\t\tif(!first){\n\t\t\t\t\t strOut = strOut + \" \";\n\t\t\t\t}else{\n\t\t\t\t\t first = false;\n\t\t\t\t\t if(elem == quoteSym){\n\t\t\t\t\t\t  return \"'\" + println_impl(obj[1]);\n\t\t\t\t\t }\n\t\t\t\t}\n\t\t\t\tstrOut += println_impl(elem)\n\t\t\t\t\n\t\t  }\n\t\t  \n\t\t  strOut += \")\"\n\t\t  return strOut;\n\t }else{\n\t\t  if(obj === null){\n\t\t\t\treturn \"null\";\n\t\t  }\n\t\t  if(obj === undefined){\n\t\t\t\treturn \"undefined\"\n\t\t  }\n\t\t  \n\t\t  if(obj.type === \"symbol\"){\n\t\t\t\treturn obj.value;\n\t\t  }\n\t\t  if(typeof obj === \"string\") {\n\t\t\t\treturn `\"${obj}\"`\n\t\t  }\n\t\t  return obj.toString()\n\t }\n}\n\nprintln = (...a) => {\n\t let combined = \"\"\n\t let first = true\n\t for(let elem of a){\n\t\t  if(!first){\n\t\t\t\tcombined = combined + \" \"\n\t\t  }else{\n\t\t\t\tfirst = false\n\t\t  }\n\t\t  combined = combined + println_impl(elem)\n\t }\n\t // print without newline:\n\t console.log(combined)\n\t return a[0]\n}\n\n__valueToString = (a) => println_impl(a);\n\nnth = (a, n) => a && (n >= a.length ? null : a[n])\nsetnth = (a, n, v) => a[n] = v\ngetnth = (a, n) => a[n]\nmakemap_ = () => ({type: \"lisp-object\"})\nput = (obj, name, value) =>  obj[name.jsname ? name.jsname : name] = value\nget = (obj, name) => obj[name.jsname ? name.jsname : name]\ncharcode = (a) => a.charCodeAt(0)\nstrfromchar = (...a) => String.fromCharCode(...a)\nreverse = (a) => a.slice().reverse()\n_op_gte = (a,b) => a >= b\n_op_lte = (a,b) => b >= a\n_op_lt = (a,b) => a < b\n_op_gt = (a,b) => a > b\nconcat = (...lst)=> len(lst) == 0 ? [] : lst[0].concat(...lst.slice(1))\n__makesym = (a) => sym(a)\n_typeof = (a) => typeof a\n\n\nconst loopSym = sym(\"loop\");\nconst notSym = sym(\"not\");\nconst setSym = sym(\"set\");\nconst letSym = sym(\"let\");\nconst constSym = sym(\"const\");\nconst prognSym = sym(\"progn\");\nconst ifSym = sym(\"if\");\nconst lambdaSym = sym(\"_lambda\");\nconst defMacroSym = sym(\"setmacro\");\nconst orSym = sym(\"or\");\nconst andSym = sym(\"and\");\nconst blockSym = sym(\"_block\");\nconst returnFromSym = sym(\"return-from\")\nconst jsSym = sym(\"%js\")\nconst quoteSym = lisp.quote_sym;\nconst keywordSym = lisp.keyword_sym;\nconst quasiQuoteSym = lisp.quasiquote_sym;\nconst quasiUnQuoteSym = lisp.quasiunquote_sym;\nconst quasiUnQuoteSpliceSym = lisp.quasiunquotesplice_sym;\nconst restSym = sym(\"&rest\")\nconst declareSym = sym(\"declare\")\nconst defvarSym = sym(\"defvar\");\nconst handleErrorsSym = sym(\"handle-errors\")\nconst loop_sym = sym(\"loop\")\nconst withSym = sym(\"with\")\n\nfunction quotedJs(code){\n\t if(Array.isArray(code)){\n\t\t  const innerCode = code.map(elem => quotedJs(elem)).join(',');\n\t\t  return `[${innerCode}]`\n\t }\n\t if(code.type == \"symbol\"){\n\t\t  \n\t\t  return `___sym[${code.index}]`\n\t }\n\t if(typeof(code) == 'string'){\n\t\t  return `\"${escapeString(code)}\"`\n\t }\t \n\t return code.toString();\n\n}\n\nfunction unscope(code){\n\t if(isScope(code)){\n\t\t  return `(()=>{var tmp_unscope; ${code.replaceAll(value_marker, \"tmp_unscope =\")}; return tmp_unscope})()`\n\t }\n\t return code\n}\n\nfunction unquoteToJs(code){\n\t if(code == null){\n\t\t  return \"null\"\n\t }\n\t if(Array.isArray(code)){\n\t\t  if(code[0] == quasiQuoteSym){\n\t\t\t\t\n\t\t\t\treturn quotedJs(code) \n\t\t  }\n\t\t  if(code[0] == quasiUnQuoteSpliceSym){\n\t\t\t\t\n\t\t\t\treturn `usplice(${unscope(lispCompile(code[1]))})`;\n\t\t  }\n\t\t  if(code[0] == quasiUnQuoteSym){\n\t\t\t\treturn unscope(lispCompile(code[1]))\n\t\t  }\n\t\t  const innerCode = code.map(elem => unquoteToJs(elem)).join(',');\n\t\t  return `ulist(${innerCode})`;\n\t }\n\t if(code.type == \"symbol\"){\n\t\t  return `___sym[${code.index}]`\n\t }\n\t if(typeof(code) == 'string'){\n\t\t  return `\"${escapeString(code)}\"`\n\t }\n\t \n\t \n\t return code.toString();\n}\n\nfunction scope(items){\n\t for(let i = 0; i < items.length; i++){\n\t\t  if(i == items.length -1){\n\t\t\t\tif(isScope(items[i])){\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t}else{\n\t\t\t\t\t items[i] = value_marker + \" \" + items[i]\n\t\t\t\t}\n\t\t  }else{\n\t\t\t\tif(isScope(items[i]))\n\t\t\t\t\t items[i] = items[i].replaceAll(value_marker,\"\")\n\t\t  }\n\t\t  \n        \n\t }\n\t let a =  items.map(i => i + \";\").join(\"\")\n\t return a\n}\n\nconst value_marker = \"__>>VALUEMARKER<<__\"\nfunction isScope(code){\n\t return typeof(code) == 'string' && code.includes(value_marker)\n}\n\nfunction lispCompileLet(variables, body, isConst){\n\t const kw = isConst ? \"const\" : \"let\"\n\t let brackets = 0\n\t let usedNames = {}\n\t const varCode = variables.map(updateExpr => {\n\t\t  if(updateExpr.length != 2){\n\t\t\t\tthrow new Error(\"The expression (xyz) is malformed.\" + println_impl(updateExpr));\n\t\t  }\n        const [left, right] = updateExpr;\n\t\t  let r = lispCompile2(right)\n\t\t  if(isScope(r)){\n\t\t\t\tcode = `${kw} ${left.jsname};${r.replaceAll(value_marker, left.jsname + \"=\")}`\n\t\t  }else{\n\t\t\t\tcode = `${kw} ${left.jsname} = ${r}`\n\t\t  }\n\t\t  if(brackets == 0 || left.jsname in usedNames){\n\t\t\t\tbrackets += 1\n\t\t\t\tusedNames = {}\n\t\t\t\tcode = \"{\" + code;\n\t\t  }\n\t\t  usedNames[left.jsname] = true\n        return code;\n    });\n    if(body.length == 0){\n\t\t  body = [[]]\n\t }\n\t if(body.length == 1 && variables.length == 0){\n\t\t  return `${lispCompile(body[0])}`\n\t }\n\t result = scope(varCode.concat(body.map(x => lispCompile(x))))\n\t for(let i = 0; i < brackets; i++){\n\t\t  result = result + \"}\";\n\t }\n\t return result;\n}\nlmbmark = (id, f) => {\n\t f.assoc_id = id;\n\t return f;\n}\n\nlet associd = 0;\nlet assoc = {}\n///\\/\\*lmb#(\\d+)\\*\\//\nconst markRegex = /\\/\\*lmb#(\\d+)\\*\\/\\(/g;\nlet codeStack = []\n\nfunction lispCompile(code, assignto){\n\t const result = lispCompile2(code);\n\n\t if(isScope(result) && assignto){\n\t\t  const fin = result.replace(value_marker, assignto);\n\t\t  return fin\n\t }\n\n\t if(assignto){\n        const r = assignto + \" \" + result;\n\t\treturn r\n\t }\n\t \n\t return result;\n\n}\n\nfunction lispCompile2(code) {\n\t \n\t try{\n\t\t  codeStack.push(code);\n\t\t  if(typeof(code) == \"number\"){\n\t\t\t\treturn code\n\t\t  }\n\t\t  if(typeof(code) == \"string\"){\n\t\t\t\tcode = code.replaceAll(\"\\\"\", \"\\\\\\\"\");\n\t\t\t\tcode = code.replaceAll(\"\\n\", \"\\\\n\");\n\t\t\t\treturn `\\\"${code}\\\"`;\n\t\t  }\n\t\t  if(code == undefined){\n\t\t\t\treturn \"undefined\"\n\t\t  }\n\t\t  if (code.type == \"symbol\"){\n\t\t\t\treturn code.jsname\n\t\t  }\n\t\t  if(code.length == 0) {\n\t\t\t\treturn \"null\"\n\t\t  }\n\n\t\t  const [operator, ...operands] = code;\n\t\t  switch (operator) {\n\t\t  case loopSym:\n\t\t\t\tconst [condition, ...update] = operands;\n\t\t\t\t\n\t\t\t\tlet updateCode = lispCompileLet([], update);\n\t\t\t\tlet conditionCode = lispCompile(condition);\n\t\t\t\tif(!isScope(updateCode)){\n\t\t\t\t\t updateCode = value_marker + updateCode\n\t\t\t\t}\n\t\t\t\tif(isScope(conditionCode)){\n\t\t\t\t\t conditionCode = conditionCode.replaceAll(value_marker, \"condition =\")\n\t\t\t\t\t return `while(true) { var condition; ${conditionCode}; if(!condition){break;} ${updateCode}}`;\n\t\t\t\t}\n\t\t\t\treturn `while (${conditionCode}) {  ${updateCode}; }`;\n\t\t  case jsSym:\n\t\t\t\t{\n\t\t\t\t\t let outstr = \"\";\n\t\t\t\t\t for (let x of operands) {\n\t\t\t\t\t\t  if (typeof(x) == \"string\") {\n\t\t\t\t\t\t\t\toutstr += x;\n\t\t\t\t\t\t  }else{\n\t\t\t\t\t\t\t\toutstr += lispCompile(x)\n\t\t\t\t\t\t  }\n\t\t\t\t\t }\n\t\t\t\t\t return outstr;\n\t\t\t\t\t \n\t\t\t\t}\n\t \t\t\t\n\t\t  case blockSym:{\n\t\t\t\tconst [sym, ...body] = operands;\n\t\t\t\tlet bodyCode = lispCompile(body[0])\n\t\t\t\t\n\t\t\t\tif(!isScope(bodyCode)){\n\t\t\t\t\t \n\t\t\t\t\t bodyCode = value_marker + \" \" + bodyCode\n\t\t\t\t\t \n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn `const ${sym.jsname} = {};try{${bodyCode}}catch(ex){if(ex.id === ${sym.jsname}){${value_marker} ex.value;}else{_raise(ex);}}`\n\t\t  }\n\t\t  case returnFromSym:{\n\t\t\t\tconst [sym, value] = operands;\n\t\t\t\tlet valuef = lispCompile(value);\n\t\t\t\tlet pre = \"\"\n\t\t\t\tif(isScope(valuef)){\n\t\t\t\t\t pre = \"var tmpValue;\" + valuef.replaceAll(value_marker,\"tmpValue =\") + \";\";\n\t\t\t\t\t valuef = \"tmpValue\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn `${pre} _raise({id:${sym.jsname}, value:${valuef}, type: \"return-from\" })`;\n\t\t  }\n\t\t  case lambdaSym:\n\t\t\t\t{\n\n\t\t\t\t\t const [args, ...body] = operands;\n\t\t\t\t\t // find invalid args    \n\t\t\t\t\t for(let arg of args){\n\t\t\t\t\t\t  if(arg.type != \"symbol\"){\n\t\t\t\t\t\t\t\tthrow new Error(\"Invalid argument in lambda: \" + arg + \" in \" + println_impl(code));\n\t\t\t\t\t\t  }\n\t\t\t\t\t }\n\n\t\t\t\t\t const restIndex = args.indexOf(restSym)\n\t\t\t\t\t let argstr = args.map(arg => arg.jsname).join(\",\")\n\t\t\t\t\t if(restIndex != -1){\n\t\t\t\t\t\t  argstr = args.slice(0, restIndex).map(arg => arg.jsname).concat([\"...\" + args[restIndex + 1].jsname]).join(\",\");\n\t\t\t\t\t }\n\t\t\t\t\t \n\t\t\t\t\t assoc[associd] = operands\n\t\t\t\t\t \n\n\t\t\t\t\t let bodyCode = lispCompileLet([], body)\n\t\t\t\t\t if(isScope(bodyCode)){\n\t\t\t\t\t\t  bodyCode = \"{ var lambdaResult;\"+ bodyCode.replaceAll(value_marker, \"lambdaResult=\") + \"return lambdaResult}\"\n\t\t\t\t\t }\n\t\t\t\t\t let lmb = `(${argstr}) => ${bodyCode}`;\n\t\t\t\t\t \n\t\t\t\t\t return lmb\n\t\t\t\t}\n\t\t  case prognSym:\n\t\t\t\treturn lispCompileLet([], operands)\n\t\t  case keywordSym:\n\t\t  case quoteSym:\n\t\t\t\t{\n\t\t\t\t\t const [quoted] = operands\n\t\t\t\t\t if(issym(quoted)){\n\t\t\t\t\t\tif(quoted.index > -1){\n\t\t\t\t\t\t\treturn `___sym[${quoted.index}]`\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn `getsym(\\\"${quoted.value}\\\")/*3*/`\n\t\t\t\t\t }\n\t\t\t\t\t \n\t\t\t\t\t const id = setQuote(quoted)\n\t\t\t\t\t return `__quotes[${id}]`\n\t\t\t\t}\n\t\t  case quasiQuoteSym:\n\t\t\t\t{\n\t\t\t\t\t const [quoted] = operands\n\t\t\t\t\t const code = unquoteToJs(quoted)\n\t\t\t\t\t return code;\n\t\t\t\t}\n\t\t  case defvarSym:\n\t\t\t\t{\n\t\t\t\t\t \n\t\t\t\t\t const [sym, code] = operands;\n\t\t\t\t\t let valueCode = lispCompile(code);\n\t\t\t\t\t if (typeof(valueCode) == \"string\"){\n\t\t\t\t\t\t  valueCode = valueCode.replace(markRegex, 'lmbmark($1,');\n\t\t\t\t\t }\n\t\t\t\t\t \n\t\t\t\t\t let code2 = `${sym.jsname} = ${valueCode}`;\n\t\t\t\t\t if(isScope(valueCode)){\n\t\t\t\t\t\t  code2 = `${sym.jsname} = null;${valueCode.replaceAll(value_marker, sym.jsname + \"=\")}`\n\t\t\t\t\t }\n\n\t\t\t\t\t //console.log(code2)\n\t\t\t\t\t let result = eval?.(code2);\n\t\t\t\t\t if(typeof(result) == \"function\" && result.assoc_id){\n\t\t\t\t\t\t  result.lispname = sym\n\t\t\t\t\t }\n\t\t\t\t\t return `${sym.jsname}`\n\t\t\t\t}\n\t\t  case defMacroSym:\n\t\t\t\t{\n\t\t\t\t\t const [sym, code] = operands;\n\t\t\t\t\t const macroCode = lispCompile(code)\n\t\t\t\t\t \n\t\t\t\t\t macroValue = eval(macroCode);\n\t\t\t\t\t \n\t\t\t\t\t macroLookup.set(sym, macroValue)\n\t\t\t\t\t \n\t\t\t\t\t return \"1\"\n\t\t\t\t}\n\t\t  case setSym: {\n\t\t\t\tconst [variable, value] = operands;\n\t\t\t\tlet result = lispCompile(value)\n\t\t\t\tlet leftHand = variable.jsname\n\t\t\t\tif(Array.isArray(variable)){\n\t\t\t\t\t leftHand = lispCompile(variable)\n\t\t\t\t\t if(isScope(leftHand)){\n\t\t\t\t\t\t  throw \"left hand of set cannot be a scope\"\n\t\t\t\t\t }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(isScope(result)){\n\t\t\t\t\t result = result.replaceAll(value_marker, value_marker + leftHand + \"=\")\n\t\t\t\t\t \n\t\t\t\t}else{\n\t\t\t\t\t result = leftHand + \"=\" + result;\n\t\t\t\t}\n\t\t\t\treturn result\n\t\t  }\n\t\t  case letSym: {\n\t\t\t\tconst [variables, ...body] = operands\n\t\t\t\treturn lispCompileLet(variables, body)\n\t\t  }\n\t\t  case constSym: {\n\t\t\t\tconst [variables, ...body] = operands\n\t\t\t\treturn lispCompileLet(variables, body, true)\n\t\t  }\n\t\t  case ifSym:\n\t\t\t\t{\n\t\t\t\t\t const [condition, thenClause, elseClause] = operands;\n\n\t\t\t\t\t let conditionCode = lispCompile(condition);\n\t\t\t\t\t let thenCode = lispCompile(thenClause);\n\t\t\t\t\t let elseCode = elseClause == null ? \"null\" : lispCompile(elseClause);\n\t\t\t\t\t \n\t\t\t\t\t if(thenCode === null || thenCode === \"\"){\n\t\t\t\t\t\t  thenCode = \"null\"\n\t\t\t\t\t }\n\t\t\t\t\t if(elseCode === null || elseCode === \"\"){\n\t\t\t\t\t\t  elseCode = \"null\"\n\t\t\t\t\t }\n\t\t\t\t\t if(!isScope(conditionCode) && !isScope(thenCode) && !isScope(elseCode)){\n\t\t\t\t\t\t  \n\t\t\t\t\t\t  return `(${conditionCode} ? ${thenCode} : ${elseCode})`\n\t\t\t\t\t }\n\t\t\t\t\t let js = \"\"\n\t\t\t\t\t let isConditionScope = false;\n\t\t\t\t\t if(isScope(conditionCode)){\n\t\t\t\t\t\t  js = \"{var check; \" + conditionCode.replaceAll(value_marker, \"check = \");\n\t\t\t\t\t\t  conditionCode = \"check\"\n\t\t\t\t\t\t  isConditionScope = true\n\t\t\t\t\t }\n\t\t\t\t\t if(!isScope(elseCode)){\n\t\t\t\t\t\t  elseCode = value_marker + \" \" + elseCode;\n\t\t\t\t\t }\n\t\t\t\t\t if(!isScope(thenCode)){\n\t\t\t\t\t\t  thenCode = value_marker + \" \" + thenCode;\n\t\t\t\t\t }\n\t\t\t\t\t js = js + `if(${conditionCode}){${thenCode}}else{${elseCode}${isConditionScope ? \"}\" : \"\"}} `\n\n\t\t\t\t\t \n\t\t\t\t\t return js;\n\t\t\t\t}\n\t\t  case handleErrorsSym:\n\t\t\t\t{\n\t\t\t\t\t \n\t\t\t\t\t const [body, handler] = operands;\n\n\t\t\t\t\t const [varSym, handlerBody] = handler;\n\t\t\t\t\t const bodyCode = lispCompile(body);\n\t\t\t\t\t const handlerBodyCode = lispCompile(handlerBody);\n\t\t\t\t\t return `try{${isScope(bodyCode) ? bodyCode : value_marker + \" \" + bodyCode}}catch(${varSym.jsname}){ if(${varSym.jsname}.type === \"return-from\") _raise(${varSym.jsname}); ${isScope(handlerBodyCode) ? handlerBodyCode : value_marker +\" \" + handlerBodyCode}}`\n\t\t\t\t\t \n\t\t\t\t}\n\t\t  case withSym:\n\t\t\t\t{\n\t\t\t\t\t const [arg, ...body] = operands;\n\t\t\t\t\t // arg must be in the form (sym value)\n\t\t\t\t\t let argCode = lispCompile(arg[1]);\n\t\t\t\t\t if(isScope(argCode)){\n\t\t\t\t\t\t  argCode = argCode.replaceAll(value_marker, arg[0].jsname);\n\t\t\t\t\t }else{\n                    argCode = arg[0].jsname + \"=\" + argCode;\n\t\t\t\t\t }\n\t\t\t\t\t\t \n\t\t\t\t\t let bodyCode = lispCompileLet([], body, true)\n\t\t\t\t\t if(!isScope(bodyCode)){\n                    bodyCode = value_marker + \" \" + bodyCode;\n\t\t\t\t\t }\n\t\t\t\t\t return `{\nconst __prevv = ${arg[0].jsname}; try{ ${argCode}; ${bodyCode}; }finally{ ${arg[0].jsname} = __prevv;}}`\n\t\t\t\t\t\t  \n\n\t\t\t\t}\n\t\t\t\t// Add more cases for other operators as needed\n\t\t\t\t\n\t\t  default:\n\t\t\t\tif(operator == undefined){\n\t\t\t\t\t throw new Error(\"undefined operator in \", code)\n\t\t\t\t}\n\t\t\t\tif (macroLookup.has(operator)) {\n\t\t\t\t\t let macroFcn = macroLookup.get(operator)\n\t\t\t\t\t let newcode = null;\n\t\t\t\t\t // replace\n\t\t\t\t\t //console.log(operands)\n\t\t\t\t\t newcode = macroFcn(...operands)\n\t\t\t\t\t \n\t\t\t\t\t return lispCompile(newcode)\n\t\t\t\t}\n\t\t\t\targs = operands.map(op => lispCompile(op))\n\t\t\t\tif(args.some(isScope)){\n\t\t\t\t\t let callargs = args.map((x,i) => \"arg\"+i)\n\t\t\t\t\t let argCall = args.map((x,i) => {\n\t\t\t\t\t\t  if(isScope(x)){\n\t\t\t\t\t\t\t\treturn \"var arg\" + i + \";\" + x.replaceAll(value_marker, \"arg\" + i + \"=\") + \";\";\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t  }else{\n\t\t\t\t\t\t\t\treturn \"let arg\" + i + \"=\" + x + \";\";\n\t\t\t\t\t\t  }\n\t\t\t\t\t });\n\t\t\t\t\t return `{${argCall.join(\"\")} ${value_marker} ${operator.jsname}(${callargs.join(\",\")})}`\n\t\t\t\t}\n\t\t\t\treturn `${operator.jsname}(${args})`;\n\t\t  }\n\t }finally{\n\t\t  codeStack.pop()\n\t }\n}\n\nlisp_reader = function(code) {\n\t return code;\n}\n\nfunction lispCompileAst(ast){\n    js = \"'use strict'\\n; return \"+ lispCompile(lisp_reader(ast))\n    return Function(js)\n}\n\nfunction lispCompileString(code) {\n    const [ast, next] = parser.ParseLisp(code)\n    if (next == null){\n        throw \"unable to parse code\"\n    }\n    return lispCompileAst(ast)\n}\n\nfunction evalLisp(code){\n\t let fn = lispCompileAst(code)\n\t return fn();\n}\n\nfunction countNewlinesBeforeIndex(str, index) {\n    if (index < 0 || index > str.length) {\n        throw new Error('Index out of bounds');\n    }\n\n    let newlineCount = 0;\n    for (let i = 0; i < index; i++) {\n        if (str[i] === '\\n') {\n            newlineCount++;\n        }\n    }\n\n    return newlineCount;\n}\n\n\nfunction on_lisp_error(e){\n\t console.log(e)\n}\n\nlet onErrorSym = lisp.sym(\"lisp-parser:on-error\")\n\n__webpack_require__.g[onErrorSym.jsname] = on_lisp_error;\n\neval2 = evalLisp\nloadFileAsync = null\nloadcontext = \"\"\ncurrentEval = null\nerror = null\n\nasync function LispEvalBlock(code, file) {\n\t let len1 = code.length\n\t \n\t const originalCode = code\n\t for(;;){\n\t\t  let offset = len1 - code.length\n\t\t  parser.fileOffset = len1 - code.length\n\t\t  parser.codeBase = originalCode\n\t\t  parser.setCodeBase(originalCode)\n\t\t  const [ast, next] = parser.ParseLisp(code)\n\t\t  if (ast == parser.UnexpectedEOF){\t\n\t\t\t\tthrow new Error(`Unexpected EOF in file ${file}`)\n\t\t  }\n\t\t  \n\t\t  if (next == null){\n\t\t\t\t\n\t\t\t\treturn;\n\t\t  }\n\t\t  code = next;\n\n\t\t  try{\n\t\t\t\tvar js = lispCompile(lisp_reader(ast));\n\t\t\t\tif(isScope(js)){\n\t\t\t\t\t js = js.replaceAll(value_marker, \"returnValue =\");\n\t\t\t\t\t js = \"{'use strict'; var returnValue;\" + js + \"return returnValue;}\";\n\t\t\t\t}else{\n\t\t\t\t\t js = \"{'use strict'; return \" + js + \"}\";\n\t\t\t\t}\n\t\t  \n\t\t  \n\t\t\t\t// there are two ways of doing this, which may be the same\n\t\t\t\tconst ncode = \"function currentEval()\" + js;\n\t\t\t\t//console.log(ncode, file, \" line: \" + countNewlinesBeforeIndex(originalCode, offset))\n\t\t\t\teval?.(ncode)\n\t\t  \t\tconst result = currentEval();\n\t\t\t\t\n\t\t\t\tif(result != null && typeof(result) == \"object\" && result.type == \"load\"){\n\t\t\t\t\t \n\t\t\t\t\t const data = await loadFileAsync(result.value)\n\t\t\t\t\t const prevContext = loadcontext\n\t\t\t\t\t loadcontext = result.value\n\t\t\t\t\t await LispEvalBlock(data, result.value)\n\t\t\t\t\t loadcontext = prevContext\n\t\t\t\t}\n\t\t  }catch(e){\n\t\t\t\t\n\t\t\t\tif(!e._at){\n\t\t\t\t\t e._at = file + \" line: \" + (1 + countNewlinesBeforeIndex(originalCode, offset))\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthrow e\n\t\t  }\n\t }\n}\n\n// do-eval can be used to eval as single line of code.\nfunction do_eval(code){\n\t code = \"return \" + code.trim()\n\t const func = new Function(code)\n\t return func()\n}\n\njs_eval = do_eval\n\nlisp.lisp.eval = evalLisp\nlisp.lisp.LispEvalBlock = LispEvalBlock\n\nmodule.exports = {\n\t EvalLisp: evalLisp,\n\t LispEvalBlock: LispEvalBlock,\n\t lispCompile: lispCompile\n};\n\n\n//# sourceURL=webpack:///../../src/lisp.js?");

/***/ }),

/***/ "../../src/lispy_parser.js":
/*!*********************************!*\
  !*** ../../src/lispy_parser.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const lisp = __webpack_require__(/*! ./symbols */ \"../../src/symbols.js\")\n\ncodeBase = null\n\nfunction setCodeBase(code){\n\t codeBase = code\n}\n\nclass ParserCondition {\n    constructor(err) {\n      this.err = err;\n    }\n  \n    toString() {\n      return \"Error parsing lisp code\";\n    }\n  }\n  \n  class NothingParsed2 {}\n  \n  const NothingParsed = new ParserCondition();\n  const UnexpectedEOF = new ParserCondition();\n  \n  // Helper function to skip whitespace\n  function skipWhitespace(input) {\n    while (input.length > 0 && /\\s|\\n|\\t/.test(input[0])) {\n      input = input.slice(1);\n    }\n    return input\n  }\n\n  function skipComment(input) {\n    if(input.length == 0 || input[0] != ';'){\n      return input;\n    }\n    while (input.length > 0 && input[0] !== '\\n') {\n            \n      input = input.slice(1);\n    }\n    if (input.length > 0) {\n      input = input.slice(1);\n    }\n    return input;\n  }\n\n  function skipCommentAndWhitespace(input){\n    while(true){\n      const input1 = input;\n      input = skipComment(skipWhitespace(input))\n      if(input == input1){\n        return input;\n      }\n    }\n  }\n\n  \n  // Helper function to parse a number\nfunction parseNumber(input) {\n\t let value = \"\";\n\t let isFloat = false;\n\t let isNegative = false;\n\t let pattern = /\\d/\n\t let base = 10;\n\t if(input[0] == '#' && input[1] == 'x'){\n\t\t  pattern = /[0-9a-fA-F]/;\n\t\t  base = 16\n\t\t  input = input.slice(2)\n\t }else if(input[0] == '#' && input[1] == 'o'){\n\t\t  pattern = /[0-7]/\n\t\t  base = 8\n\t\t  input = input.slice(2)\n\t }else if(input[0] == '#' && input[1] == 'b'){\n\t\t  pattern = /[0-1]/;\n\t\t  base = 2\n\t\t  input = input.slice(2)\n\t }\n\t\t\n    if(input[0] == '-'){\n      isNegative = true;\n      input = input.slice(1);\n    }\n    if(input[0] == '+'){\n      input = input.slice(1)\n    }\n  \n    while (input.length > 0 && (pattern.test(input[0]) || (!isFloat && input[0] === '.'))) {\n      value += input[0];\n      if (input[0] === '.') {\n        isFloat = true;\n      }\n      input = input.slice(1);\n    }\n  \n    if (value === \"\") {\n      return [null, null];\n    }\n  \n    if (input.length > 0) {\n      const nextchr = input[0];\n        if (/\\s|;|\\)|\\(/.test(nextchr)) {\n  \n      } else {\n        return [null, null];\n      }\n    }\n  \n    if (isFloat) {\n      const num = parseFloat(value);\n      if (isNaN(num)) {\n        return [null, null];\n      }\n      if(isNegative){\n        return [-num, input];  \n      }\n      return [num, input];\n    }\n  \n    const num = parseInt(value, base);\n    if (isNaN(num)) {\n      return [null, null];\n    }\n    if(isNegative){\n      return [-num, input];  \n    }\n    return [num, input];  \n  }\n  \n  function parseString(input) {\n    if (input.length === 0 || input[0] !== '\"') {\n      return [null, null];\n    }\n  \n    input = input.slice(1); // Consume opening quote\n    let value = \"\";\n    let escaped = false;\n  \n    while (input.length > 0) {\n      const char = input[0];\n      input = input.slice(1);\n  \n      if (char === '\\\\' && !escaped) {\n        escaped = true;\n        continue;\n      }\n  \n      if (char === '\"' && !escaped) {\n        // Closing quote found\n        return [value, input];\n      }\n  \n      value += char;\n      escaped = false;\n    }\n  \n    return [null, null]; // Unclosed string\n  }\n\n  // ParseLisp0 function\n  function ParseLisp0(input) {\n    \n    // Parsing loop\n    while (true) {\n      input = skipCommentAndWhitespace(input);\n      if (input.length === 0) {\n        \n        return [NothingParsed, null];\n      }\n      \n      switch (input[0]) {\n        \n        case '(':\n          let offset = codeBase.length - input.lengt\n\t\t\t let input0 = input\n\t\t\t input = skipCommentAndWhitespace(input.slice(1));\n          \n          if(input[0] == ')'){  \n            return [[], input.slice(1)];\n          }\n          let out = []\n\t\t\t \n          for(;;){\n            const [result,next] = ParseLisp0(input)\n            if(next){\n              input = next;\n              out.push(result)\n              input = skipCommentAndWhitespace(input);\n\t\t\t\t\t if(input[0] == ')'){\n\t\t\t\t\t\t  out.codeBase = codeBase\n\t\t\t\t\t\t  out.offset = offset\n\t\t\t\t\t\t  \n\t\t\t\t\t\t  Object.freeze(out)\n\t\t\t\t\t\t  return [out, input.slice(1)];\n\t\t\t\t\t\t  \n\t\t\t\t\t }\n            }else{\n              return [UnexpectedEOF, null]\n            }\n          }\n          break;\n        case ':':\n          {\n            // Parse keyword\n            const [r, next] = ParseLisp0(input.slice(1));\n            return [[lisp.keyword_sym, r], next]\n          }\n\n        break;\n        case '\\'':\n          {\n            // Parse quote\n\n            const [r, next] = ParseLisp0(input.slice(1));\n            return [[lisp.quote_sym, r], next]\n          }\n\t\tcase '`':\n\t\t\t {\n\t\t\t\t  const [r, next] = ParseLisp0(input.slice(1));\n              return [[lisp.quasiquote_sym, r], next]\n\n\t\t\t }\n\t\tcase ',':\n\t\t\t {\n\t\t\t\t  if(input[1] == '@'){\n\t\t\t\t\t\tconst [r, next] = ParseLisp0(input.slice(2));\n\t\t\t\t\t\treturn [[lisp.quasiunquotesplice_sym, r], next]\n\t\t\t\t  }\n\t\t\t\t  const [r, next] = ParseLisp0(input.slice(1));\n              return [[lisp.quasiunquote_sym, r], next]\n\n\t\t\t }\n      case '\"':\n          return parseString(input);\n\n  \n        default:\n          \n          const [num, next] = parseNumber(input);\n  \n          if (next) {\n            return [num, next];\n          }\n          \n          // parse symbol\n          value = \"\"\n          while (input.length > 0 && !/\\s|\\n|\\t|\\(|\\)/.test(input[0])) {\n            value += input[0];\n            input = input.slice(1);\n          }\n          if (value === \"\"){\n            return [null, null]\n          }\n           \n          s = lisp.sym(value);\n          return [s, input]          \n      }\n    }\n  }\n\n\n\nfunction ParseLisp (codestring){\n    return ParseLisp0(codestring);\n}\n  \nmodule.exports = {\n    ParseLisp: ParseLisp,\n    UnexpectedEOF: UnexpectedEOF,\n\t setCodeBase: setCodeBase\n};\n\n\n//# sourceURL=webpack:///../../src/lispy_parser.js?");

/***/ }),

/***/ "../../src/symbols.js":
/*!****************************!*\
  !*** ../../src/symbols.js ***!
  \****************************/
/***/ ((module) => {

eval("\nlisp = { symbolName: {}, symbols: [] }\nconst reserved = {\n\t\"true\": true, \"false\": true, \"null\": true, \"case\": true,\n\t \"tmp\": true, \"undefined\": true, \"new\": true, \"eval\": true, \"typeof\" : true, \"delete\": true, \"function\": true, \"continue\": true, \"break\":true, \"try\" : true, \"catch\": true, \"finally\": true, \"throw\": true, \"new\": true, \"var\": true\n}\n\nconst sanitizedLookup = {}\nconst sanitizedLookupRev = {}\nconst symbolArray = []\n\nfunction register_symbol(name, sanitized){\n\tsanitizedLookup[name] = sanitized\n\tsanitizedLookupRev[sanitized] = name\n}\n\nfunction sanitizeSymbolName(name) {\n\tif (name in sanitizedLookup) {\n\t\treturn sanitizedLookup[name]\n\t}\n\n\tconst sanitized = name.replace(/[^\\.a-zA-Z0-9_]/g, '_')\n\n\tisreserved = reserved[name];\n\n\tif (sanitized == name && !isreserved)\n\t\treturn sanitized;\n\n\tif (sanitized in sanitizedLookupRev || isreserved) {\n\t\tfor (i = 0; true; i = i + 1) {\n\t\t\tconst test = `_${sanitized}_${i}`\n\t\t\tif (test in sanitizedLookupRev) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tregister_symbol(name, test);\n\t\t\treturn test;\n\t\t}\n\t}\n\n\tregister_symbol(name, sanitized);\n\treturn sanitized;\n\n}\n\nfunction getsym(str) {\n\treturn lisp.symbolName[str]\n}\n\nfunction sym(str, jsname) {\n\tif (!lisp.symbolName[str]) {\n\t\tif (jsname == null) {\n\t\t\tjsname = str;\n\t\t\tjsname = sanitizeSymbolName(jsname)\n\t\t}\n\n\t\tconst symbol = {\n\t\t\ttype: \"symbol\",\n\t\t\tvalue: str,\n\t\t\tjsname: jsname,\n\t\t\tindex: lisp.symbols.length\n\t\t};\n\t\tObject.freeze(symbol)\n\t\tlisp.symbolName[str] = symbol;\n\t\tlisp.symbols.push(symbol);\n\t\t\n\t}\n\treturn lisp.symbolName[str];\n}\n\nconst quote_sym = sym(\"quote\");\nconst keyword_sym = sym(\"keyword\");\nconst quasiquote_sym = sym(\"quasiquote\")\nconst quasiunquote_sym = sym(\"quasiunquote\")\nconst quasiunquotesplice_sym = sym(\"quasiunquote-splice\")\n\nmodule.exports = {\n\t sym: sym,\n\t getsym: getsym,\n\t lisp: lisp,\t\n\t quote_sym: quote_sym,\n\t keyword_sym: keyword_sym,\n\t quasiquote_sym: quasiquote_sym,\n\t quasiunquote_sym: quasiunquote_sym,\n\t quasiunquotesplice_sym: quasiunquotesplice_sym\n};\n\n\n//# sourceURL=webpack:///../../src/symbols.js?");

/***/ }),

/***/ "./node_modules/nats.ws/esm/nats.js":
/*!******************************************!*\
  !*** ./node_modules/nats.ws/esm/nats.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AckPolicy: () => (/* binding */ AckPolicy),\n/* harmony export */   AdvisoryKind: () => (/* binding */ AdvisoryKind),\n/* harmony export */   Bench: () => (/* binding */ Bench),\n/* harmony export */   ConsumerDebugEvents: () => (/* binding */ ConsumerDebugEvents),\n/* harmony export */   ConsumerEvents: () => (/* binding */ ConsumerEvents),\n/* harmony export */   DebugEvents: () => (/* binding */ DebugEvents),\n/* harmony export */   DeliverPolicy: () => (/* binding */ DeliverPolicy),\n/* harmony export */   DirectMsgHeaders: () => (/* binding */ DirectMsgHeaders),\n/* harmony export */   DiscardPolicy: () => (/* binding */ DiscardPolicy),\n/* harmony export */   Empty: () => (/* binding */ Empty),\n/* harmony export */   ErrorCode: () => (/* binding */ ErrorCode),\n/* harmony export */   Events: () => (/* binding */ Events),\n/* harmony export */   JSONCodec: () => (/* binding */ JSONCodec),\n/* harmony export */   JsHeaders: () => (/* binding */ JsHeaders),\n/* harmony export */   KvWatchInclude: () => (/* binding */ KvWatchInclude),\n/* harmony export */   Match: () => (/* binding */ Match),\n/* harmony export */   Metric: () => (/* binding */ Metric),\n/* harmony export */   MsgHdrsImpl: () => (/* binding */ MsgHdrsImpl),\n/* harmony export */   NatsError: () => (/* binding */ NatsError),\n/* harmony export */   Nuid: () => (/* binding */ Nuid),\n/* harmony export */   ReplayPolicy: () => (/* binding */ ReplayPolicy),\n/* harmony export */   RepublishHeaders: () => (/* binding */ RepublishHeaders),\n/* harmony export */   RequestStrategy: () => (/* binding */ RequestStrategy),\n/* harmony export */   RetentionPolicy: () => (/* binding */ RetentionPolicy),\n/* harmony export */   ServiceError: () => (/* binding */ ServiceError),\n/* harmony export */   ServiceErrorCodeHeader: () => (/* binding */ ServiceErrorCodeHeader),\n/* harmony export */   ServiceErrorHeader: () => (/* binding */ ServiceErrorHeader),\n/* harmony export */   ServiceResponseType: () => (/* binding */ ServiceResponseType),\n/* harmony export */   ServiceVerb: () => (/* binding */ ServiceVerb),\n/* harmony export */   StorageType: () => (/* binding */ StorageType),\n/* harmony export */   StoreCompression: () => (/* binding */ StoreCompression),\n/* harmony export */   StringCodec: () => (/* binding */ StringCodec),\n/* harmony export */   backoff: () => (/* binding */ backoff),\n/* harmony export */   buildAuthenticator: () => (/* binding */ buildAuthenticator),\n/* harmony export */   canonicalMIMEHeaderKey: () => (/* binding */ canonicalMIMEHeaderKey),\n/* harmony export */   checkJsError: () => (/* binding */ checkJsError),\n/* harmony export */   connect: () => (/* binding */ connect),\n/* harmony export */   consumerOpts: () => (/* binding */ consumerOpts),\n/* harmony export */   createInbox: () => (/* binding */ createInbox),\n/* harmony export */   credsAuthenticator: () => (/* binding */ credsAuthenticator),\n/* harmony export */   deadline: () => (/* binding */ deadline),\n/* harmony export */   deferred: () => (/* binding */ deferred),\n/* harmony export */   delay: () => (/* binding */ delay),\n/* harmony export */   headers: () => (/* binding */ headers),\n/* harmony export */   isFlowControlMsg: () => (/* binding */ isFlowControlMsg),\n/* harmony export */   isHeartbeatMsg: () => (/* binding */ isHeartbeatMsg),\n/* harmony export */   jwtAuthenticator: () => (/* binding */ jwtAuthenticator),\n/* harmony export */   millis: () => (/* binding */ millis),\n/* harmony export */   nanos: () => (/* binding */ nanos),\n/* harmony export */   nkeyAuthenticator: () => (/* binding */ nkeyAuthenticator),\n/* harmony export */   nkeys: () => (/* binding */ mod),\n/* harmony export */   nuid: () => (/* binding */ nuid),\n/* harmony export */   syncIterator: () => (/* binding */ syncIterator),\n/* harmony export */   tokenAuthenticator: () => (/* binding */ tokenAuthenticator),\n/* harmony export */   usernamePasswordAuthenticator: () => (/* binding */ usernamePasswordAuthenticator)\n/* harmony export */ });\n// deno-fmt-ignore-file\n// deno-lint-ignore-file\n// This code was bundled using `deno bundle` and it's not recommended to edit it manually\n\nconst Empty = new Uint8Array(0);\nconst TE = new TextEncoder();\nconst TD = new TextDecoder();\nfunction concat(...bufs) {\n    let max = 0;\n    for(let i = 0; i < bufs.length; i++){\n        max += bufs[i].length;\n    }\n    const out = new Uint8Array(max);\n    let index = 0;\n    for(let i = 0; i < bufs.length; i++){\n        out.set(bufs[i], index);\n        index += bufs[i].length;\n    }\n    return out;\n}\nfunction encode(...a) {\n    const bufs = [];\n    for(let i = 0; i < a.length; i++){\n        bufs.push(TE.encode(a[i]));\n    }\n    if (bufs.length === 0) {\n        return Empty;\n    }\n    if (bufs.length === 1) {\n        return bufs[0];\n    }\n    return concat(...bufs);\n}\nfunction decode(a) {\n    if (!a || a.length === 0) {\n        return \"\";\n    }\n    return TD.decode(a);\n}\n\"use strict\";\nconst digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nconst base = 36;\nconst maxSeq = 3656158440062976;\nconst minInc = 33;\nconst maxInc = 333;\nconst totalLen = 12 + 10;\nfunction _getRandomValues(a) {\n    for(let i = 0; i < a.length; i++){\n        a[i] = Math.floor(Math.random() * 255);\n    }\n}\nfunction fillRandom(a) {\n    if (globalThis?.crypto?.getRandomValues) {\n        globalThis.crypto.getRandomValues(a);\n    } else {\n        _getRandomValues(a);\n    }\n}\nclass Nuid {\n    buf;\n    seq;\n    inc;\n    inited;\n    constructor(){\n        this.buf = new Uint8Array(totalLen);\n        this.inited = false;\n    }\n    init() {\n        this.inited = true;\n        this.setPre();\n        this.initSeqAndInc();\n        this.fillSeq();\n    }\n    initSeqAndInc() {\n        this.seq = Math.floor(Math.random() * maxSeq);\n        this.inc = Math.floor(Math.random() * (maxInc - minInc) + minInc);\n    }\n    setPre() {\n        const cbuf = new Uint8Array(12);\n        fillRandom(cbuf);\n        for(let i = 0; i < 12; i++){\n            const di = cbuf[i] % 36;\n            this.buf[i] = digits.charCodeAt(di);\n        }\n    }\n    fillSeq() {\n        let n = this.seq;\n        for(let i = totalLen - 1; i >= 12; i--){\n            this.buf[i] = digits.charCodeAt(n % base);\n            n = Math.floor(n / base);\n        }\n    }\n    next() {\n        if (!this.inited) {\n            this.init();\n        }\n        this.seq += this.inc;\n        if (this.seq > 3656158440062976) {\n            this.setPre();\n            this.initSeqAndInc();\n        }\n        this.fillSeq();\n        return String.fromCharCode.apply(String, this.buf);\n    }\n    reset() {\n        this.init();\n    }\n}\nconst nuid = new Nuid();\nvar Events;\n(function(Events) {\n    Events[\"Disconnect\"] = \"disconnect\";\n    Events[\"Reconnect\"] = \"reconnect\";\n    Events[\"Update\"] = \"update\";\n    Events[\"LDM\"] = \"ldm\";\n    Events[\"Error\"] = \"error\";\n})(Events || (Events = {}));\nvar DebugEvents;\n(function(DebugEvents) {\n    DebugEvents[\"Reconnecting\"] = \"reconnecting\";\n    DebugEvents[\"PingTimer\"] = \"pingTimer\";\n    DebugEvents[\"StaleConnection\"] = \"staleConnection\";\n    DebugEvents[\"ClientInitiatedReconnect\"] = \"client initiated reconnect\";\n})(DebugEvents || (DebugEvents = {}));\nvar ErrorCode;\n(function(ErrorCode) {\n    ErrorCode[\"ApiError\"] = \"BAD API\";\n    ErrorCode[\"BadAuthentication\"] = \"BAD_AUTHENTICATION\";\n    ErrorCode[\"BadCreds\"] = \"BAD_CREDS\";\n    ErrorCode[\"BadHeader\"] = \"BAD_HEADER\";\n    ErrorCode[\"BadJson\"] = \"BAD_JSON\";\n    ErrorCode[\"BadPayload\"] = \"BAD_PAYLOAD\";\n    ErrorCode[\"BadSubject\"] = \"BAD_SUBJECT\";\n    ErrorCode[\"Cancelled\"] = \"CANCELLED\";\n    ErrorCode[\"ConnectionClosed\"] = \"CONNECTION_CLOSED\";\n    ErrorCode[\"ConnectionDraining\"] = \"CONNECTION_DRAINING\";\n    ErrorCode[\"ConnectionRefused\"] = \"CONNECTION_REFUSED\";\n    ErrorCode[\"ConnectionTimeout\"] = \"CONNECTION_TIMEOUT\";\n    ErrorCode[\"Disconnect\"] = \"DISCONNECT\";\n    ErrorCode[\"InvalidOption\"] = \"INVALID_OPTION\";\n    ErrorCode[\"InvalidPayload\"] = \"INVALID_PAYLOAD\";\n    ErrorCode[\"MaxPayloadExceeded\"] = \"MAX_PAYLOAD_EXCEEDED\";\n    ErrorCode[\"NoResponders\"] = \"503\";\n    ErrorCode[\"NotFunction\"] = \"NOT_FUNC\";\n    ErrorCode[\"RequestError\"] = \"REQUEST_ERROR\";\n    ErrorCode[\"ServerOptionNotAvailable\"] = \"SERVER_OPT_NA\";\n    ErrorCode[\"SubClosed\"] = \"SUB_CLOSED\";\n    ErrorCode[\"SubDraining\"] = \"SUB_DRAINING\";\n    ErrorCode[\"Timeout\"] = \"TIMEOUT\";\n    ErrorCode[\"Tls\"] = \"TLS\";\n    ErrorCode[\"Unknown\"] = \"UNKNOWN_ERROR\";\n    ErrorCode[\"WssRequired\"] = \"WSS_REQUIRED\";\n    ErrorCode[\"JetStreamInvalidAck\"] = \"JESTREAM_INVALID_ACK\";\n    ErrorCode[\"JetStream404NoMessages\"] = \"404\";\n    ErrorCode[\"JetStream408RequestTimeout\"] = \"408\";\n    ErrorCode[\"JetStream409MaxAckPendingExceeded\"] = \"409\";\n    ErrorCode[\"JetStream409\"] = \"409\";\n    ErrorCode[\"JetStreamNotEnabled\"] = \"503\";\n    ErrorCode[\"JetStreamIdleHeartBeat\"] = \"IDLE_HEARTBEAT\";\n    ErrorCode[\"AuthorizationViolation\"] = \"AUTHORIZATION_VIOLATION\";\n    ErrorCode[\"AuthenticationExpired\"] = \"AUTHENTICATION_EXPIRED\";\n    ErrorCode[\"ProtocolError\"] = \"NATS_PROTOCOL_ERR\";\n    ErrorCode[\"PermissionsViolation\"] = \"PERMISSIONS_VIOLATION\";\n    ErrorCode[\"AuthenticationTimeout\"] = \"AUTHENTICATION_TIMEOUT\";\n    ErrorCode[\"AccountExpired\"] = \"ACCOUNT_EXPIRED\";\n})(ErrorCode || (ErrorCode = {}));\nfunction isNatsError(err) {\n    return typeof err.code === \"string\";\n}\nclass Messages {\n    messages;\n    constructor(){\n        this.messages = new Map();\n        this.messages.set(ErrorCode.InvalidPayload, \"Invalid payload type - payloads can be 'binary', 'string', or 'json'\");\n        this.messages.set(ErrorCode.BadJson, \"Bad JSON\");\n        this.messages.set(ErrorCode.WssRequired, \"TLS is required, therefore a secure websocket connection is also required\");\n    }\n    static getMessage(s) {\n        return messages.getMessage(s);\n    }\n    getMessage(s) {\n        return this.messages.get(s) || s;\n    }\n}\nconst messages = new Messages();\nclass NatsError extends Error {\n    name;\n    message;\n    code;\n    permissionContext;\n    chainedError;\n    api_error;\n    constructor(message, code, chainedError){\n        super(message);\n        this.name = \"NatsError\";\n        this.message = message;\n        this.code = code;\n        this.chainedError = chainedError;\n    }\n    static errorForCode(code, chainedError) {\n        const m = Messages.getMessage(code);\n        return new NatsError(m, code, chainedError);\n    }\n    isAuthError() {\n        return this.code === ErrorCode.AuthenticationExpired || this.code === ErrorCode.AuthorizationViolation || this.code === ErrorCode.AccountExpired;\n    }\n    isAuthTimeout() {\n        return this.code === ErrorCode.AuthenticationTimeout;\n    }\n    isPermissionError() {\n        return this.code === ErrorCode.PermissionsViolation;\n    }\n    isProtocolError() {\n        return this.code === ErrorCode.ProtocolError;\n    }\n    isJetStreamError() {\n        return this.api_error !== undefined;\n    }\n    jsError() {\n        return this.api_error ? this.api_error : null;\n    }\n}\nvar Match;\n(function(Match) {\n    Match[Match[\"Exact\"] = 0] = \"Exact\";\n    Match[Match[\"CanonicalMIME\"] = 1] = \"CanonicalMIME\";\n    Match[Match[\"IgnoreCase\"] = 2] = \"IgnoreCase\";\n})(Match || (Match = {}));\nvar RequestStrategy;\n(function(RequestStrategy) {\n    RequestStrategy[\"Timer\"] = \"timer\";\n    RequestStrategy[\"Count\"] = \"count\";\n    RequestStrategy[\"JitterTimer\"] = \"jitterTimer\";\n    RequestStrategy[\"SentinelMsg\"] = \"sentinelMsg\";\n})(RequestStrategy || (RequestStrategy = {}));\nfunction syncIterator(src) {\n    const iter = src[Symbol.asyncIterator]();\n    return {\n        async next () {\n            const m = await iter.next();\n            if (m.done) {\n                return Promise.resolve(null);\n            }\n            return Promise.resolve(m.value);\n        }\n    };\n}\nvar ServiceResponseType;\n(function(ServiceResponseType) {\n    ServiceResponseType[\"STATS\"] = \"io.nats.micro.v1.stats_response\";\n    ServiceResponseType[\"INFO\"] = \"io.nats.micro.v1.info_response\";\n    ServiceResponseType[\"PING\"] = \"io.nats.micro.v1.ping_response\";\n})(ServiceResponseType || (ServiceResponseType = {}));\nconst ServiceErrorHeader = \"Nats-Service-Error\";\nconst ServiceErrorCodeHeader = \"Nats-Service-Error-Code\";\nclass ServiceError extends Error {\n    code;\n    constructor(code, message){\n        super(message);\n        this.code = code;\n    }\n    static isServiceError(msg) {\n        return ServiceError.toServiceError(msg) !== null;\n    }\n    static toServiceError(msg) {\n        const scode = msg?.headers?.get(ServiceErrorCodeHeader) || \"\";\n        if (scode !== \"\") {\n            const code = parseInt(scode) || 400;\n            const description = msg?.headers?.get(ServiceErrorHeader) || \"\";\n            return new ServiceError(code, description.length ? description : scode);\n        }\n        return null;\n    }\n}\nfunction createInbox(prefix = \"\") {\n    prefix = prefix || \"_INBOX\";\n    if (typeof prefix !== \"string\") {\n        throw new Error(\"prefix must be a string\");\n    }\n    prefix.split(\".\").forEach((v)=>{\n        if (v === \"*\" || v === \">\") {\n            throw new Error(`inbox prefixes cannot have wildcards '${prefix}'`);\n        }\n    });\n    return `${prefix}.${nuid.next()}`;\n}\nconst DEFAULT_HOST = \"127.0.0.1\";\nvar ServiceVerb;\n(function(ServiceVerb) {\n    ServiceVerb[\"PING\"] = \"PING\";\n    ServiceVerb[\"STATS\"] = \"STATS\";\n    ServiceVerb[\"INFO\"] = \"INFO\";\n})(ServiceVerb || (ServiceVerb = {}));\nfunction extend(a, ...b) {\n    for(let i = 0; i < b.length; i++){\n        const o = b[i];\n        Object.keys(o).forEach(function(k) {\n            a[k] = o[k];\n        });\n    }\n    return a;\n}\nfunction render(frame) {\n    const cr = \"\";\n    const lf = \"\";\n    return TD.decode(frame).replace(/\\n/g, lf).replace(/\\r/g, cr);\n}\nfunction timeout(ms, asyncTraces = true) {\n    const err = asyncTraces ? NatsError.errorForCode(ErrorCode.Timeout) : null;\n    let methods;\n    let timer;\n    const p = new Promise((_resolve, reject)=>{\n        const cancel = ()=>{\n            if (timer) {\n                clearTimeout(timer);\n            }\n        };\n        methods = {\n            cancel\n        };\n        timer = setTimeout(()=>{\n            if (err === null) {\n                reject(NatsError.errorForCode(ErrorCode.Timeout));\n            } else {\n                reject(err);\n            }\n        }, ms);\n    });\n    return Object.assign(p, methods);\n}\nfunction delay(ms = 0) {\n    let methods;\n    const p = new Promise((resolve)=>{\n        const timer = setTimeout(()=>{\n            resolve();\n        }, ms);\n        const cancel = ()=>{\n            if (timer) {\n                clearTimeout(timer);\n            }\n        };\n        methods = {\n            cancel\n        };\n    });\n    return Object.assign(p, methods);\n}\nfunction deadline(p, millis = 1000) {\n    const err = new Error(`deadline exceeded`);\n    const d = deferred();\n    const timer = setTimeout(()=>d.reject(err), millis);\n    return Promise.race([\n        p,\n        d\n    ]).finally(()=>clearTimeout(timer));\n}\nfunction deferred() {\n    let methods = {};\n    const p = new Promise((resolve, reject)=>{\n        methods = {\n            resolve,\n            reject\n        };\n    });\n    return Object.assign(p, methods);\n}\nfunction shuffle(a) {\n    for(let i = a.length - 1; i > 0; i--){\n        const j = Math.floor(Math.random() * (i + 1));\n        [a[i], a[j]] = [\n            a[j],\n            a[i]\n        ];\n    }\n    return a;\n}\nclass Perf {\n    timers;\n    measures;\n    constructor(){\n        this.timers = new Map();\n        this.measures = new Map();\n    }\n    mark(key) {\n        this.timers.set(key, performance.now());\n    }\n    measure(key, startKey, endKey) {\n        const s = this.timers.get(startKey);\n        if (s === undefined) {\n            throw new Error(`${startKey} is not defined`);\n        }\n        const e = this.timers.get(endKey);\n        if (e === undefined) {\n            throw new Error(`${endKey} is not defined`);\n        }\n        this.measures.set(key, e - s);\n    }\n    getEntries() {\n        const values = [];\n        this.measures.forEach((v, k)=>{\n            values.push({\n                name: k,\n                duration: v\n            });\n        });\n        return values;\n    }\n}\nfunction jitter(n) {\n    if (n === 0) {\n        return 0;\n    }\n    return Math.floor(n / 2 + Math.random() * n);\n}\nfunction backoff(policy = [\n    0,\n    250,\n    250,\n    500,\n    500,\n    3000,\n    5000\n]) {\n    if (!Array.isArray(policy)) {\n        policy = [\n            0,\n            250,\n            250,\n            500,\n            500,\n            3000,\n            5000\n        ];\n    }\n    const max = policy.length - 1;\n    return {\n        backoff (attempt) {\n            return jitter(attempt > max ? policy[max] : policy[attempt]);\n        }\n    };\n}\nfunction nanos(millis) {\n    return millis * 1000000;\n}\nfunction millis(ns) {\n    return Math.floor(ns / 1000000);\n}\nfunction canonicalMIMEHeaderKey(k) {\n    const dash = 45;\n    const toLower = 97 - 65;\n    let upper = true;\n    const buf = new Array(k.length);\n    for(let i = 0; i < k.length; i++){\n        let c = k.charCodeAt(i);\n        if (c === 58 || c < 33 || c > 126) {\n            throw new NatsError(`'${k[i]}' is not a valid character for a header key`, ErrorCode.BadHeader);\n        }\n        if (upper && 97 <= c && c <= 122) {\n            c -= toLower;\n        } else if (!upper && 65 <= c && c <= 90) {\n            c += toLower;\n        }\n        buf[i] = c;\n        upper = c == dash;\n    }\n    return String.fromCharCode(...buf);\n}\nfunction headers(code = 0, description = \"\") {\n    if (code === 0 && description !== \"\" || code > 0 && description === \"\") {\n        throw new Error(\"setting status requires both code and description\");\n    }\n    return new MsgHdrsImpl(code, description);\n}\nconst HEADER = \"NATS/1.0\";\nclass MsgHdrsImpl {\n    _code;\n    headers;\n    _description;\n    constructor(code = 0, description = \"\"){\n        this._code = code;\n        this._description = description;\n        this.headers = new Map();\n    }\n    [Symbol.iterator]() {\n        return this.headers.entries();\n    }\n    size() {\n        return this.headers.size;\n    }\n    equals(mh) {\n        if (mh && this.headers.size === mh.headers.size && this._code === mh._code) {\n            for (const [k, v] of this.headers){\n                const a = mh.values(k);\n                if (v.length !== a.length) {\n                    return false;\n                }\n                const vv = [\n                    ...v\n                ].sort();\n                const aa = [\n                    ...a\n                ].sort();\n                for(let i = 0; i < vv.length; i++){\n                    if (vv[i] !== aa[i]) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    static decode(a) {\n        const mh = new MsgHdrsImpl();\n        const s = TD.decode(a);\n        const lines = s.split(\"\\r\\n\");\n        const h = lines[0];\n        if (h !== HEADER) {\n            let str = h.replace(HEADER, \"\").trim();\n            if (str.length > 0) {\n                mh._code = parseInt(str, 10);\n                if (isNaN(mh._code)) {\n                    mh._code = 0;\n                }\n                const scode = mh._code.toString();\n                str = str.replace(scode, \"\");\n                mh._description = str.trim();\n            }\n        }\n        if (lines.length >= 1) {\n            lines.slice(1).map((s)=>{\n                if (s) {\n                    const idx = s.indexOf(\":\");\n                    if (idx > -1) {\n                        const k = s.slice(0, idx);\n                        const v = s.slice(idx + 1).trim();\n                        mh.append(k, v);\n                    }\n                }\n            });\n        }\n        return mh;\n    }\n    toString() {\n        if (this.headers.size === 0 && this._code === 0) {\n            return \"\";\n        }\n        let s = HEADER;\n        if (this._code > 0 && this._description !== \"\") {\n            s += ` ${this._code} ${this._description}`;\n        }\n        for (const [k, v] of this.headers){\n            for(let i = 0; i < v.length; i++){\n                s = `${s}\\r\\n${k}: ${v[i]}`;\n            }\n        }\n        return `${s}\\r\\n\\r\\n`;\n    }\n    encode() {\n        return TE.encode(this.toString());\n    }\n    static validHeaderValue(k) {\n        const inv = /[\\r\\n]/;\n        if (inv.test(k)) {\n            throw new NatsError(\"invalid header value - \\\\r and \\\\n are not allowed.\", ErrorCode.BadHeader);\n        }\n        return k.trim();\n    }\n    keys() {\n        const keys = [];\n        for (const sk of this.headers.keys()){\n            keys.push(sk);\n        }\n        return keys;\n    }\n    findKeys(k, match = Match.Exact) {\n        const keys = this.keys();\n        switch(match){\n            case Match.Exact:\n                return keys.filter((v)=>{\n                    return v === k;\n                });\n            case Match.CanonicalMIME:\n                k = canonicalMIMEHeaderKey(k);\n                return keys.filter((v)=>{\n                    return v === k;\n                });\n            default:\n                {\n                    const lci = k.toLowerCase();\n                    return keys.filter((v)=>{\n                        return lci === v.toLowerCase();\n                    });\n                }\n        }\n    }\n    get(k, match = Match.Exact) {\n        const keys = this.findKeys(k, match);\n        if (keys.length) {\n            const v = this.headers.get(keys[0]);\n            if (v) {\n                return Array.isArray(v) ? v[0] : v;\n            }\n        }\n        return \"\";\n    }\n    last(k, match = Match.Exact) {\n        const keys = this.findKeys(k, match);\n        if (keys.length) {\n            const v = this.headers.get(keys[0]);\n            if (v) {\n                return Array.isArray(v) ? v[v.length - 1] : v;\n            }\n        }\n        return \"\";\n    }\n    has(k, match = Match.Exact) {\n        return this.findKeys(k, match).length > 0;\n    }\n    set(k, v, match = Match.Exact) {\n        this.delete(k, match);\n        this.append(k, v, match);\n    }\n    append(k, v, match = Match.Exact) {\n        const ck = canonicalMIMEHeaderKey(k);\n        if (match === Match.CanonicalMIME) {\n            k = ck;\n        }\n        const keys = this.findKeys(k, match);\n        k = keys.length > 0 ? keys[0] : k;\n        const value = MsgHdrsImpl.validHeaderValue(v);\n        let a = this.headers.get(k);\n        if (!a) {\n            a = [];\n            this.headers.set(k, a);\n        }\n        a.push(value);\n    }\n    values(k, match = Match.Exact) {\n        const buf = [];\n        const keys = this.findKeys(k, match);\n        keys.forEach((v)=>{\n            const values = this.headers.get(v);\n            if (values) {\n                buf.push(...values);\n            }\n        });\n        return buf;\n    }\n    delete(k, match = Match.Exact) {\n        const keys = this.findKeys(k, match);\n        keys.forEach((v)=>{\n            this.headers.delete(v);\n        });\n    }\n    get hasError() {\n        return this._code >= 300;\n    }\n    get status() {\n        return `${this._code} ${this._description}`.trim();\n    }\n    toRecord() {\n        const data = {};\n        this.keys().forEach((v)=>{\n            data[v] = this.values(v);\n        });\n        return data;\n    }\n    get code() {\n        return this._code;\n    }\n    get description() {\n        return this._description;\n    }\n    static fromRecord(r) {\n        const h = new MsgHdrsImpl();\n        for(const k in r){\n            h.headers.set(k, r[k]);\n        }\n        return h;\n    }\n}\nfunction StringCodec() {\n    return {\n        encode (d) {\n            return TE.encode(d);\n        },\n        decode (a) {\n            return TD.decode(a);\n        }\n    };\n}\nfunction JSONCodec(reviver) {\n    return {\n        encode (d) {\n            try {\n                if (d === undefined) {\n                    d = null;\n                }\n                return TE.encode(JSON.stringify(d));\n            } catch (err) {\n                throw NatsError.errorForCode(ErrorCode.BadJson, err);\n            }\n        },\n        decode (a) {\n            try {\n                return JSON.parse(TD.decode(a), reviver);\n            } catch (err) {\n                throw NatsError.errorForCode(ErrorCode.BadJson, err);\n            }\n        }\n    };\n}\nfunction isRequestError(msg) {\n    if (msg && msg.data.length === 0 && msg.headers?.code === 503) {\n        return NatsError.errorForCode(ErrorCode.NoResponders);\n    }\n    return null;\n}\nclass MsgImpl {\n    _headers;\n    _msg;\n    _rdata;\n    _reply;\n    _subject;\n    publisher;\n    static jc;\n    constructor(msg, data, publisher){\n        this._msg = msg;\n        this._rdata = data;\n        this.publisher = publisher;\n    }\n    get subject() {\n        if (this._subject) {\n            return this._subject;\n        }\n        this._subject = TD.decode(this._msg.subject);\n        return this._subject;\n    }\n    get reply() {\n        if (this._reply) {\n            return this._reply;\n        }\n        this._reply = TD.decode(this._msg.reply);\n        return this._reply;\n    }\n    get sid() {\n        return this._msg.sid;\n    }\n    get headers() {\n        if (this._msg.hdr > -1 && !this._headers) {\n            const buf = this._rdata.subarray(0, this._msg.hdr);\n            this._headers = MsgHdrsImpl.decode(buf);\n        }\n        return this._headers;\n    }\n    get data() {\n        if (!this._rdata) {\n            return new Uint8Array(0);\n        }\n        return this._msg.hdr > -1 ? this._rdata.subarray(this._msg.hdr) : this._rdata;\n    }\n    respond(data = Empty, opts) {\n        if (this.reply) {\n            this.publisher.publish(this.reply, data, opts);\n            return true;\n        }\n        return false;\n    }\n    size() {\n        const subj = this._msg.subject.length;\n        const reply = this._msg.reply?.length || 0;\n        const payloadAndHeaders = this._msg.size === -1 ? 0 : this._msg.size;\n        return subj + reply + payloadAndHeaders;\n    }\n    json(reviver) {\n        return JSONCodec(reviver).decode(this.data);\n    }\n    string() {\n        return TD.decode(this.data);\n    }\n    requestInfo() {\n        const v = this.headers?.get(\"Nats-Request-Info\");\n        if (v) {\n            return JSON.parse(v, function(key, value) {\n                if ((key === \"start\" || key === \"stop\") && value !== \"\") {\n                    return new Date(Date.parse(value));\n                }\n                return value;\n            });\n        }\n        return null;\n    }\n}\nfunction validateDurableName(name) {\n    return minValidation(\"durable\", name);\n}\nfunction validateStreamName(name) {\n    return minValidation(\"stream\", name);\n}\nfunction minValidation(context, name = \"\") {\n    if (name === \"\") {\n        throw Error(`${context} name required`);\n    }\n    const bad = [\n        \".\",\n        \"*\",\n        \">\",\n        \"/\",\n        \"\\\\\",\n        \" \",\n        \"\\t\",\n        \"\\n\",\n        \"\\r\"\n    ];\n    bad.forEach((v)=>{\n        if (name.indexOf(v) !== -1) {\n            switch(v){\n                case \"\\n\":\n                    v = \"\\\\n\";\n                    break;\n                case \"\\r\":\n                    v = \"\\\\r\";\n                    break;\n                case \"\\t\":\n                    v = \"\\\\t\";\n                    break;\n                default:\n            }\n            throw Error(`invalid ${context} name - ${context} name cannot contain '${v}'`);\n        }\n    });\n    return \"\";\n}\nfunction validateName(context, name = \"\") {\n    if (name === \"\") {\n        throw Error(`${context} name required`);\n    }\n    const m = validName(name);\n    if (m.length) {\n        throw new Error(`invalid ${context} name - ${context} name ${m}`);\n    }\n}\nfunction validName(name = \"\") {\n    if (name === \"\") {\n        throw Error(`name required`);\n    }\n    const RE = /^[-\\w]+$/g;\n    const m = name.match(RE);\n    if (m === null) {\n        for (const c of name.split(\"\")){\n            const mm = c.match(RE);\n            if (mm === null) {\n                return `cannot contain '${c}'`;\n            }\n        }\n    }\n    return \"\";\n}\nfunction isFlowControlMsg(msg) {\n    if (msg.data.length > 0) {\n        return false;\n    }\n    const h = msg.headers;\n    if (!h) {\n        return false;\n    }\n    return h.code >= 100 && h.code < 200;\n}\nfunction isHeartbeatMsg(msg) {\n    return isFlowControlMsg(msg) && msg.headers?.description === \"Idle Heartbeat\";\n}\nfunction newJsErrorMsg(code, description, subject) {\n    const h = headers(code, description);\n    const arg = {\n        hdr: 1,\n        sid: 0,\n        size: 0\n    };\n    const msg = new MsgImpl(arg, Empty, {});\n    msg._headers = h;\n    msg._subject = subject;\n    return msg;\n}\nfunction checkJsError(msg) {\n    if (msg.data.length !== 0) {\n        return null;\n    }\n    const h = msg.headers;\n    if (!h) {\n        return null;\n    }\n    return checkJsErrorCode(h.code, h.description);\n}\nvar Js409Errors;\n(function(Js409Errors) {\n    Js409Errors[\"MaxBatchExceeded\"] = \"exceeded maxrequestbatch of\";\n    Js409Errors[\"MaxExpiresExceeded\"] = \"exceeded maxrequestexpires of\";\n    Js409Errors[\"MaxBytesExceeded\"] = \"exceeded maxrequestmaxbytes of\";\n    Js409Errors[\"MaxMessageSizeExceeded\"] = \"message size exceeds maxbytes\";\n    Js409Errors[\"PushConsumer\"] = \"consumer is push based\";\n    Js409Errors[\"MaxWaitingExceeded\"] = \"exceeded maxwaiting\";\n    Js409Errors[\"IdleHeartbeatMissed\"] = \"idle heartbeats missed\";\n    Js409Errors[\"ConsumerDeleted\"] = \"consumer deleted\";\n})(Js409Errors || (Js409Errors = {}));\nlet MAX_WAITING_FAIL = false;\nfunction isTerminal409(err) {\n    if (err.code !== ErrorCode.JetStream409) {\n        return false;\n    }\n    const fatal = [\n        Js409Errors.MaxBatchExceeded,\n        Js409Errors.MaxExpiresExceeded,\n        Js409Errors.MaxBytesExceeded,\n        Js409Errors.MaxMessageSizeExceeded,\n        Js409Errors.PushConsumer,\n        Js409Errors.IdleHeartbeatMissed,\n        Js409Errors.ConsumerDeleted\n    ];\n    if (MAX_WAITING_FAIL) {\n        fatal.push(Js409Errors.MaxWaitingExceeded);\n    }\n    return fatal.find((s)=>{\n        return err.message.indexOf(s) !== -1;\n    }) !== undefined;\n}\nfunction checkJsErrorCode(code, description = \"\") {\n    if (code < 300) {\n        return null;\n    }\n    description = description.toLowerCase();\n    switch(code){\n        case 404:\n            return new NatsError(description, ErrorCode.JetStream404NoMessages);\n        case 408:\n            return new NatsError(description, ErrorCode.JetStream408RequestTimeout);\n        case 409:\n            {\n                const ec = description.startsWith(Js409Errors.IdleHeartbeatMissed) ? ErrorCode.JetStreamIdleHeartBeat : ErrorCode.JetStream409;\n                return new NatsError(description, ec);\n            }\n        case 503:\n            return NatsError.errorForCode(ErrorCode.JetStreamNotEnabled, new Error(description));\n        default:\n            if (description === \"\") {\n                description = ErrorCode.Unknown;\n            }\n            return new NatsError(description, `${code}`);\n    }\n}\nclass QueuedIteratorImpl {\n    inflight;\n    processed;\n    received;\n    noIterator;\n    iterClosed;\n    done;\n    signal;\n    yields;\n    filtered;\n    pendingFiltered;\n    ingestionFilterFn;\n    protocolFilterFn;\n    dispatchedFn;\n    ctx;\n    _data;\n    err;\n    time;\n    yielding;\n    constructor(){\n        this.inflight = 0;\n        this.filtered = 0;\n        this.pendingFiltered = 0;\n        this.processed = 0;\n        this.received = 0;\n        this.noIterator = false;\n        this.done = false;\n        this.signal = deferred();\n        this.yields = [];\n        this.iterClosed = deferred();\n        this.time = 0;\n        this.yielding = false;\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n    push(v) {\n        if (this.done) {\n            return;\n        }\n        if (typeof v === \"function\") {\n            this.yields.push(v);\n            this.signal.resolve();\n            return;\n        }\n        const { ingest, protocol } = this.ingestionFilterFn ? this.ingestionFilterFn(v, this.ctx || this) : {\n            ingest: true,\n            protocol: false\n        };\n        if (ingest) {\n            if (protocol) {\n                this.filtered++;\n                this.pendingFiltered++;\n            }\n            this.yields.push(v);\n            this.signal.resolve();\n        }\n    }\n    async *iterate() {\n        if (this.noIterator) {\n            throw new NatsError(\"unsupported iterator\", ErrorCode.ApiError);\n        }\n        if (this.yielding) {\n            throw new NatsError(\"already yielding\", ErrorCode.ApiError);\n        }\n        this.yielding = true;\n        try {\n            while(true){\n                if (this.yields.length === 0) {\n                    await this.signal;\n                }\n                if (this.err) {\n                    throw this.err;\n                }\n                const yields = this.yields;\n                this.inflight = yields.length;\n                this.yields = [];\n                for(let i = 0; i < yields.length; i++){\n                    if (typeof yields[i] === \"function\") {\n                        const fn = yields[i];\n                        try {\n                            fn();\n                        } catch (err) {\n                            throw err;\n                        }\n                        if (this.err) {\n                            throw this.err;\n                        }\n                        continue;\n                    }\n                    const ok = this.protocolFilterFn ? this.protocolFilterFn(yields[i]) : true;\n                    if (ok) {\n                        this.processed++;\n                        const start = Date.now();\n                        yield yields[i];\n                        this.time = Date.now() - start;\n                        if (this.dispatchedFn && yields[i]) {\n                            this.dispatchedFn(yields[i]);\n                        }\n                    } else {\n                        this.pendingFiltered--;\n                    }\n                    this.inflight--;\n                }\n                if (this.done) {\n                    break;\n                } else if (this.yields.length === 0) {\n                    yields.length = 0;\n                    this.yields = yields;\n                    this.signal = deferred();\n                }\n            }\n        } finally{\n            this.stop();\n        }\n    }\n    stop(err) {\n        if (this.done) {\n            return;\n        }\n        this.err = err;\n        this.done = true;\n        this.signal.resolve();\n        this.iterClosed.resolve(err);\n    }\n    getProcessed() {\n        return this.noIterator ? this.received : this.processed;\n    }\n    getPending() {\n        return this.yields.length + this.inflight - this.pendingFiltered;\n    }\n    getReceived() {\n        return this.received - this.filtered;\n    }\n}\nclass IdleHeartbeatMonitor {\n    interval;\n    maxOut;\n    cancelAfter;\n    timer;\n    autoCancelTimer;\n    last;\n    missed;\n    count;\n    callback;\n    constructor(interval, cb, opts = {\n        maxOut: 2\n    }){\n        this.interval = interval;\n        this.maxOut = opts?.maxOut || 2;\n        this.cancelAfter = opts?.cancelAfter || 0;\n        this.last = Date.now();\n        this.missed = 0;\n        this.count = 0;\n        this.callback = cb;\n        this._schedule();\n    }\n    cancel() {\n        if (this.autoCancelTimer) {\n            clearTimeout(this.autoCancelTimer);\n        }\n        if (this.timer) {\n            clearInterval(this.timer);\n        }\n        this.timer = 0;\n        this.autoCancelTimer = 0;\n        this.missed = 0;\n    }\n    work() {\n        this.last = Date.now();\n        this.missed = 0;\n    }\n    _change(interval, cancelAfter = 0, maxOut = 2) {\n        this.interval = interval;\n        this.maxOut = maxOut;\n        this.cancelAfter = cancelAfter;\n        this.restart();\n    }\n    restart() {\n        this.cancel();\n        this._schedule();\n    }\n    _schedule() {\n        if (this.cancelAfter > 0) {\n            this.autoCancelTimer = setTimeout(()=>{\n                this.cancel();\n            }, this.cancelAfter);\n        }\n        this.timer = setInterval(()=>{\n            this.count++;\n            if (Date.now() - this.last > this.interval) {\n                this.missed++;\n            }\n            if (this.missed >= this.maxOut) {\n                try {\n                    if (this.callback(this.missed) === true) {\n                        this.cancel();\n                    }\n                } catch (err) {\n                    console.log(err);\n                }\n            }\n        }, this.interval);\n    }\n}\nvar RetentionPolicy;\n(function(RetentionPolicy) {\n    RetentionPolicy[\"Limits\"] = \"limits\";\n    RetentionPolicy[\"Interest\"] = \"interest\";\n    RetentionPolicy[\"Workqueue\"] = \"workqueue\";\n})(RetentionPolicy || (RetentionPolicy = {}));\nvar DiscardPolicy;\n(function(DiscardPolicy) {\n    DiscardPolicy[\"Old\"] = \"old\";\n    DiscardPolicy[\"New\"] = \"new\";\n})(DiscardPolicy || (DiscardPolicy = {}));\nvar StorageType;\n(function(StorageType) {\n    StorageType[\"File\"] = \"file\";\n    StorageType[\"Memory\"] = \"memory\";\n})(StorageType || (StorageType = {}));\nvar DeliverPolicy;\n(function(DeliverPolicy) {\n    DeliverPolicy[\"All\"] = \"all\";\n    DeliverPolicy[\"Last\"] = \"last\";\n    DeliverPolicy[\"New\"] = \"new\";\n    DeliverPolicy[\"StartSequence\"] = \"by_start_sequence\";\n    DeliverPolicy[\"StartTime\"] = \"by_start_time\";\n    DeliverPolicy[\"LastPerSubject\"] = \"last_per_subject\";\n})(DeliverPolicy || (DeliverPolicy = {}));\nvar AckPolicy;\n(function(AckPolicy) {\n    AckPolicy[\"None\"] = \"none\";\n    AckPolicy[\"All\"] = \"all\";\n    AckPolicy[\"Explicit\"] = \"explicit\";\n    AckPolicy[\"NotSet\"] = \"\";\n})(AckPolicy || (AckPolicy = {}));\nvar ReplayPolicy;\n(function(ReplayPolicy) {\n    ReplayPolicy[\"Instant\"] = \"instant\";\n    ReplayPolicy[\"Original\"] = \"original\";\n})(ReplayPolicy || (ReplayPolicy = {}));\nvar StoreCompression;\n(function(StoreCompression) {\n    StoreCompression[\"None\"] = \"none\";\n    StoreCompression[\"S2\"] = \"s2\";\n})(StoreCompression || (StoreCompression = {}));\nvar ConsumerApiAction;\n(function(ConsumerApiAction) {\n    ConsumerApiAction[\"CreateOrUpdate\"] = \"\";\n    ConsumerApiAction[\"Update\"] = \"update\";\n    ConsumerApiAction[\"Create\"] = \"create\";\n})(ConsumerApiAction || (ConsumerApiAction = {}));\nfunction defaultConsumer(name, opts = {}) {\n    return Object.assign({\n        name: name,\n        deliver_policy: DeliverPolicy.All,\n        ack_policy: AckPolicy.Explicit,\n        ack_wait: nanos(30 * 1000),\n        replay_policy: ReplayPolicy.Instant\n    }, opts);\n}\nvar AdvisoryKind;\n(function(AdvisoryKind) {\n    AdvisoryKind[\"API\"] = \"api_audit\";\n    AdvisoryKind[\"StreamAction\"] = \"stream_action\";\n    AdvisoryKind[\"ConsumerAction\"] = \"consumer_action\";\n    AdvisoryKind[\"SnapshotCreate\"] = \"snapshot_create\";\n    AdvisoryKind[\"SnapshotComplete\"] = \"snapshot_complete\";\n    AdvisoryKind[\"RestoreCreate\"] = \"restore_create\";\n    AdvisoryKind[\"RestoreComplete\"] = \"restore_complete\";\n    AdvisoryKind[\"MaxDeliver\"] = \"max_deliver\";\n    AdvisoryKind[\"Terminated\"] = \"terminated\";\n    AdvisoryKind[\"Ack\"] = \"consumer_ack\";\n    AdvisoryKind[\"StreamLeaderElected\"] = \"stream_leader_elected\";\n    AdvisoryKind[\"StreamQuorumLost\"] = \"stream_quorum_lost\";\n    AdvisoryKind[\"ConsumerLeaderElected\"] = \"consumer_leader_elected\";\n    AdvisoryKind[\"ConsumerQuorumLost\"] = \"consumer_quorum_lost\";\n})(AdvisoryKind || (AdvisoryKind = {}));\nvar JsHeaders;\n(function(JsHeaders) {\n    JsHeaders[\"StreamSourceHdr\"] = \"Nats-Stream-Source\";\n    JsHeaders[\"LastConsumerSeqHdr\"] = \"Nats-Last-Consumer\";\n    JsHeaders[\"LastStreamSeqHdr\"] = \"Nats-Last-Stream\";\n    JsHeaders[\"ConsumerStalledHdr\"] = \"Nats-Consumer-Stalled\";\n    JsHeaders[\"MessageSizeHdr\"] = \"Nats-Msg-Size\";\n    JsHeaders[\"RollupHdr\"] = \"Nats-Rollup\";\n    JsHeaders[\"RollupValueSubject\"] = \"sub\";\n    JsHeaders[\"RollupValueAll\"] = \"all\";\n    JsHeaders[\"PendingMessagesHdr\"] = \"Nats-Pending-Messages\";\n    JsHeaders[\"PendingBytesHdr\"] = \"Nats-Pending-Bytes\";\n})(JsHeaders || (JsHeaders = {}));\nvar KvWatchInclude;\n(function(KvWatchInclude) {\n    KvWatchInclude[\"LastValue\"] = \"\";\n    KvWatchInclude[\"AllHistory\"] = \"history\";\n    KvWatchInclude[\"UpdatesOnly\"] = \"updates\";\n})(KvWatchInclude || (KvWatchInclude = {}));\nvar DirectMsgHeaders;\n(function(DirectMsgHeaders) {\n    DirectMsgHeaders[\"Stream\"] = \"Nats-Stream\";\n    DirectMsgHeaders[\"Sequence\"] = \"Nats-Sequence\";\n    DirectMsgHeaders[\"TimeStamp\"] = \"Nats-Time-Stamp\";\n    DirectMsgHeaders[\"Subject\"] = \"Nats-Subject\";\n})(DirectMsgHeaders || (DirectMsgHeaders = {}));\nvar RepublishHeaders;\n(function(RepublishHeaders) {\n    RepublishHeaders[\"Stream\"] = \"Nats-Stream\";\n    RepublishHeaders[\"Subject\"] = \"Nats-Subject\";\n    RepublishHeaders[\"Sequence\"] = \"Nats-Sequence\";\n    RepublishHeaders[\"LastSequence\"] = \"Nats-Last-Sequence\";\n    RepublishHeaders[\"Size\"] = \"Nats-Msg-Size\";\n})(RepublishHeaders || (RepublishHeaders = {}));\nconst kvPrefix = \"KV_\";\nclass ConsumerOptsBuilderImpl {\n    config;\n    ordered;\n    mack;\n    stream;\n    callbackFn;\n    max;\n    qname;\n    isBind;\n    filters;\n    constructor(opts){\n        this.stream = \"\";\n        this.mack = false;\n        this.ordered = false;\n        this.config = defaultConsumer(\"\", opts || {});\n    }\n    getOpts() {\n        const o = {};\n        o.config = Object.assign({}, this.config);\n        if (o.config.filter_subject) {\n            this.filterSubject(o.config.filter_subject);\n            o.config.filter_subject = undefined;\n        }\n        if (o.config.filter_subjects) {\n            o.config.filter_subjects?.forEach((v)=>{\n                this.filterSubject(v);\n            });\n            o.config.filter_subjects = undefined;\n        }\n        o.mack = this.mack;\n        o.stream = this.stream;\n        o.callbackFn = this.callbackFn;\n        o.max = this.max;\n        o.queue = this.qname;\n        o.ordered = this.ordered;\n        o.config.ack_policy = o.ordered ? AckPolicy.None : o.config.ack_policy;\n        o.isBind = o.isBind || false;\n        if (this.filters) {\n            switch(this.filters.length){\n                case 0:\n                    break;\n                case 1:\n                    o.config.filter_subject = this.filters[0];\n                    break;\n                default:\n                    o.config.filter_subjects = this.filters;\n            }\n        }\n        return o;\n    }\n    description(description) {\n        this.config.description = description;\n        return this;\n    }\n    deliverTo(subject) {\n        this.config.deliver_subject = subject;\n        return this;\n    }\n    durable(name) {\n        validateDurableName(name);\n        this.config.durable_name = name;\n        return this;\n    }\n    startSequence(seq) {\n        if (seq <= 0) {\n            throw new Error(\"sequence must be greater than 0\");\n        }\n        this.config.deliver_policy = DeliverPolicy.StartSequence;\n        this.config.opt_start_seq = seq;\n        return this;\n    }\n    startTime(time) {\n        this.config.deliver_policy = DeliverPolicy.StartTime;\n        this.config.opt_start_time = time.toISOString();\n        return this;\n    }\n    deliverAll() {\n        this.config.deliver_policy = DeliverPolicy.All;\n        return this;\n    }\n    deliverLastPerSubject() {\n        this.config.deliver_policy = DeliverPolicy.LastPerSubject;\n        return this;\n    }\n    deliverLast() {\n        this.config.deliver_policy = DeliverPolicy.Last;\n        return this;\n    }\n    deliverNew() {\n        this.config.deliver_policy = DeliverPolicy.New;\n        return this;\n    }\n    startAtTimeDelta(millis) {\n        this.startTime(new Date(Date.now() - millis));\n        return this;\n    }\n    headersOnly() {\n        this.config.headers_only = true;\n        return this;\n    }\n    ackNone() {\n        this.config.ack_policy = AckPolicy.None;\n        return this;\n    }\n    ackAll() {\n        this.config.ack_policy = AckPolicy.All;\n        return this;\n    }\n    ackExplicit() {\n        this.config.ack_policy = AckPolicy.Explicit;\n        return this;\n    }\n    ackWait(millis) {\n        this.config.ack_wait = nanos(millis);\n        return this;\n    }\n    maxDeliver(max) {\n        this.config.max_deliver = max;\n        return this;\n    }\n    filterSubject(s) {\n        this.filters = this.filters || [];\n        this.filters.push(s);\n        return this;\n    }\n    replayInstantly() {\n        this.config.replay_policy = ReplayPolicy.Instant;\n        return this;\n    }\n    replayOriginal() {\n        this.config.replay_policy = ReplayPolicy.Original;\n        return this;\n    }\n    sample(n) {\n        n = Math.trunc(n);\n        if (n < 0 || n > 100) {\n            throw new Error(`value must be between 0-100`);\n        }\n        this.config.sample_freq = `${n}%`;\n        return this;\n    }\n    limit(n) {\n        this.config.rate_limit_bps = n;\n        return this;\n    }\n    maxWaiting(max) {\n        this.config.max_waiting = max;\n        return this;\n    }\n    maxAckPending(max) {\n        this.config.max_ack_pending = max;\n        return this;\n    }\n    idleHeartbeat(millis) {\n        this.config.idle_heartbeat = nanos(millis);\n        return this;\n    }\n    flowControl() {\n        this.config.flow_control = true;\n        return this;\n    }\n    deliverGroup(name) {\n        this.queue(name);\n        return this;\n    }\n    manualAck() {\n        this.mack = true;\n        return this;\n    }\n    maxMessages(max) {\n        this.max = max;\n        return this;\n    }\n    callback(fn) {\n        this.callbackFn = fn;\n        return this;\n    }\n    queue(n) {\n        this.qname = n;\n        this.config.deliver_group = n;\n        return this;\n    }\n    orderedConsumer() {\n        this.ordered = true;\n        return this;\n    }\n    bind(stream, durable) {\n        this.stream = stream;\n        this.config.durable_name = durable;\n        this.isBind = true;\n        return this;\n    }\n    bindStream(stream) {\n        this.stream = stream;\n        return this;\n    }\n    inactiveEphemeralThreshold(millis) {\n        this.config.inactive_threshold = nanos(millis);\n        return this;\n    }\n    maxPullBatch(n) {\n        this.config.max_batch = n;\n        return this;\n    }\n    maxPullRequestExpires(millis) {\n        this.config.max_expires = nanos(millis);\n        return this;\n    }\n    memory() {\n        this.config.mem_storage = true;\n        return this;\n    }\n    numReplicas(n) {\n        this.config.num_replicas = n;\n        return this;\n    }\n    consumerName(n) {\n        this.config.name = n;\n        return this;\n    }\n}\nfunction consumerOpts(opts) {\n    return new ConsumerOptsBuilderImpl(opts);\n}\nfunction isConsumerOptsBuilder(o) {\n    return typeof o.getOpts === \"function\";\n}\nclass Base64Codec {\n    static encode(bytes) {\n        if (typeof bytes === \"string\") {\n            return btoa(bytes);\n        }\n        const a = Array.from(bytes);\n        return btoa(String.fromCharCode(...a));\n    }\n    static decode(s, binary = false) {\n        const bin = atob(s);\n        if (!binary) {\n            return bin;\n        }\n        return Uint8Array.from(bin, (c)=>c.charCodeAt(0));\n    }\n}\nclass Base64UrlPaddedCodec {\n    static encode(bytes) {\n        return Base64UrlPaddedCodec.toB64URLEncoding(Base64Codec.encode(bytes));\n    }\n    static decode(s, binary = false) {\n        return Base64UrlPaddedCodec.decode(Base64UrlPaddedCodec.fromB64URLEncoding(s), binary);\n    }\n    static toB64URLEncoding(b64str) {\n        return b64str.replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n    }\n    static fromB64URLEncoding(b64str) {\n        return b64str.replace(/_/g, \"/\").replace(/-/g, \"+\");\n    }\n}\nclass DataBuffer {\n    buffers;\n    byteLength;\n    constructor(){\n        this.buffers = [];\n        this.byteLength = 0;\n    }\n    static concat(...bufs) {\n        let max = 0;\n        for(let i = 0; i < bufs.length; i++){\n            max += bufs[i].length;\n        }\n        const out = new Uint8Array(max);\n        let index = 0;\n        for(let i = 0; i < bufs.length; i++){\n            out.set(bufs[i], index);\n            index += bufs[i].length;\n        }\n        return out;\n    }\n    static fromAscii(m) {\n        if (!m) {\n            m = \"\";\n        }\n        return TE.encode(m);\n    }\n    static toAscii(a) {\n        return TD.decode(a);\n    }\n    reset() {\n        this.buffers.length = 0;\n        this.byteLength = 0;\n    }\n    pack() {\n        if (this.buffers.length > 1) {\n            const v = new Uint8Array(this.byteLength);\n            let index = 0;\n            for(let i = 0; i < this.buffers.length; i++){\n                v.set(this.buffers[i], index);\n                index += this.buffers[i].length;\n            }\n            this.buffers.length = 0;\n            this.buffers.push(v);\n        }\n    }\n    shift() {\n        if (this.buffers.length) {\n            const a = this.buffers.shift();\n            if (a) {\n                this.byteLength -= a.length;\n                return a;\n            }\n        }\n        return new Uint8Array(0);\n    }\n    drain(n) {\n        if (this.buffers.length) {\n            this.pack();\n            const v = this.buffers.pop();\n            if (v) {\n                const max = this.byteLength;\n                if (n === undefined || n > max) {\n                    n = max;\n                }\n                const d = v.subarray(0, n);\n                if (max > n) {\n                    this.buffers.push(v.subarray(n));\n                }\n                this.byteLength = max - n;\n                return d;\n            }\n        }\n        return new Uint8Array(0);\n    }\n    fill(a, ...bufs) {\n        if (a) {\n            this.buffers.push(a);\n            this.byteLength += a.length;\n        }\n        for(let i = 0; i < bufs.length; i++){\n            if (bufs[i] && bufs[i].length) {\n                this.buffers.push(bufs[i]);\n                this.byteLength += bufs[i].length;\n            }\n        }\n    }\n    peek() {\n        if (this.buffers.length) {\n            this.pack();\n            return this.buffers[0];\n        }\n        return new Uint8Array(0);\n    }\n    size() {\n        return this.byteLength;\n    }\n    length() {\n        return this.buffers.length;\n    }\n}\nfunction getLengths(b64) {\n    const len = b64.length;\n    let validLen = b64.indexOf(\"=\");\n    if (validLen === -1) {\n        validLen = len;\n    }\n    const placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n    return [\n        validLen,\n        placeHoldersLen\n    ];\n}\nfunction init(lookup, revLookup, urlsafe = false) {\n    function _byteLength(validLen, placeHoldersLen) {\n        return Math.floor((validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen);\n    }\n    function tripletToBase64(num) {\n        return lookup[num >> 18 & 0x3f] + lookup[num >> 12 & 0x3f] + lookup[num >> 6 & 0x3f] + lookup[num & 0x3f];\n    }\n    function encodeChunk(buf, start, end) {\n        const out = new Array((end - start) / 3);\n        for(let i = start, curTriplet = 0; i < end; i += 3){\n            out[curTriplet++] = tripletToBase64((buf[i] << 16) + (buf[i + 1] << 8) + buf[i + 2]);\n        }\n        return out.join(\"\");\n    }\n    return {\n        byteLength (b64) {\n            return _byteLength.apply(null, getLengths(b64));\n        },\n        toUint8Array (b64) {\n            const [validLen, placeHoldersLen] = getLengths(b64);\n            const buf = new Uint8Array(_byteLength(validLen, placeHoldersLen));\n            const len = placeHoldersLen ? validLen - 4 : validLen;\n            let tmp;\n            let curByte = 0;\n            let i;\n            for(i = 0; i < len; i += 4){\n                tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n                buf[curByte++] = tmp >> 16 & 0xff;\n                buf[curByte++] = tmp >> 8 & 0xff;\n                buf[curByte++] = tmp & 0xff;\n            }\n            if (placeHoldersLen === 2) {\n                tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n                buf[curByte++] = tmp & 0xff;\n            } else if (placeHoldersLen === 1) {\n                tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n                buf[curByte++] = tmp >> 8 & 0xff;\n                buf[curByte++] = tmp & 0xff;\n            }\n            return buf;\n        },\n        fromUint8Array (buf) {\n            const maxChunkLength = 16383;\n            const len = buf.length;\n            const extraBytes = len % 3;\n            const len2 = len - extraBytes;\n            const parts = new Array(Math.ceil(len2 / 16383) + (extraBytes ? 1 : 0));\n            let curChunk = 0;\n            let chunkEnd;\n            for(let i = 0; i < len2; i += maxChunkLength){\n                chunkEnd = i + maxChunkLength;\n                parts[curChunk++] = encodeChunk(buf, i, chunkEnd > len2 ? len2 : chunkEnd);\n            }\n            let tmp;\n            if (extraBytes === 1) {\n                tmp = buf[len2];\n                parts[curChunk] = lookup[tmp >> 2] + lookup[tmp << 4 & 0x3f];\n                if (!urlsafe) parts[curChunk] += \"==\";\n            } else if (extraBytes === 2) {\n                tmp = buf[len2] << 8 | buf[len2 + 1] & 0xff;\n                parts[curChunk] = lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3f] + lookup[tmp << 2 & 0x3f];\n                if (!urlsafe) parts[curChunk] += \"=\";\n            }\n            return parts.join(\"\");\n        }\n    };\n}\nconst lookup = [];\nconst revLookup = [];\nconst code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\nfor(let i = 0, l = code.length; i < l; ++i){\n    lookup[i] = code[i];\n    revLookup[code.charCodeAt(i)] = i;\n}\nconst { byteLength, toUint8Array, fromUint8Array } = init(lookup, revLookup, true);\nconst decoder = new TextDecoder();\nconst encoder = new TextEncoder();\nfunction toHexString(buf) {\n    return buf.reduce((hex, __byte)=>`${hex}${__byte < 16 ? \"0\" : \"\"}${__byte.toString(16)}`, \"\");\n}\nfunction fromHexString(hex) {\n    const len = hex.length;\n    if (len % 2 || !/^[0-9a-fA-F]+$/.test(hex)) {\n        throw new TypeError(\"Invalid hex string.\");\n    }\n    hex = hex.toLowerCase();\n    const buf = new Uint8Array(Math.floor(len / 2));\n    const end = len / 2;\n    for(let i = 0; i < end; ++i){\n        buf[i] = parseInt(hex.substr(i * 2, 2), 16);\n    }\n    return buf;\n}\nfunction decode1(buf, encoding = \"utf8\") {\n    if (/^utf-?8$/i.test(encoding)) {\n        return decoder.decode(buf);\n    } else if (/^base64$/i.test(encoding)) {\n        return fromUint8Array(buf);\n    } else if (/^hex(?:adecimal)?$/i.test(encoding)) {\n        return toHexString(buf);\n    } else {\n        throw new TypeError(\"Unsupported string encoding.\");\n    }\n}\nfunction encode1(str, encoding = \"utf8\") {\n    if (/^utf-?8$/i.test(encoding)) {\n        return encoder.encode(str);\n    } else if (/^base64$/i.test(encoding)) {\n        return toUint8Array(str);\n    } else if (/^hex(?:adecimal)?$/i.test(encoding)) {\n        return fromHexString(str);\n    } else {\n        throw new TypeError(\"Unsupported string encoding.\");\n    }\n}\nclass SHA256 {\n    hashSize = 32;\n    _buf;\n    _bufIdx;\n    _count;\n    _K;\n    _H;\n    _finalized;\n    constructor(){\n        this._buf = new Uint8Array(64);\n        this._K = new Uint32Array([\n            0x428a2f98,\n            0x71374491,\n            0xb5c0fbcf,\n            0xe9b5dba5,\n            0x3956c25b,\n            0x59f111f1,\n            0x923f82a4,\n            0xab1c5ed5,\n            0xd807aa98,\n            0x12835b01,\n            0x243185be,\n            0x550c7dc3,\n            0x72be5d74,\n            0x80deb1fe,\n            0x9bdc06a7,\n            0xc19bf174,\n            0xe49b69c1,\n            0xefbe4786,\n            0x0fc19dc6,\n            0x240ca1cc,\n            0x2de92c6f,\n            0x4a7484aa,\n            0x5cb0a9dc,\n            0x76f988da,\n            0x983e5152,\n            0xa831c66d,\n            0xb00327c8,\n            0xbf597fc7,\n            0xc6e00bf3,\n            0xd5a79147,\n            0x06ca6351,\n            0x14292967,\n            0x27b70a85,\n            0x2e1b2138,\n            0x4d2c6dfc,\n            0x53380d13,\n            0x650a7354,\n            0x766a0abb,\n            0x81c2c92e,\n            0x92722c85,\n            0xa2bfe8a1,\n            0xa81a664b,\n            0xc24b8b70,\n            0xc76c51a3,\n            0xd192e819,\n            0xd6990624,\n            0xf40e3585,\n            0x106aa070,\n            0x19a4c116,\n            0x1e376c08,\n            0x2748774c,\n            0x34b0bcb5,\n            0x391c0cb3,\n            0x4ed8aa4a,\n            0x5b9cca4f,\n            0x682e6ff3,\n            0x748f82ee,\n            0x78a5636f,\n            0x84c87814,\n            0x8cc70208,\n            0x90befffa,\n            0xa4506ceb,\n            0xbef9a3f7,\n            0xc67178f2\n        ]);\n        this.init();\n    }\n    init() {\n        this._H = new Uint32Array([\n            0x6a09e667,\n            0xbb67ae85,\n            0x3c6ef372,\n            0xa54ff53a,\n            0x510e527f,\n            0x9b05688c,\n            0x1f83d9ab,\n            0x5be0cd19\n        ]);\n        this._bufIdx = 0;\n        this._count = new Uint32Array(2);\n        this._buf.fill(0);\n        this._finalized = false;\n        return this;\n    }\n    update(msg, inputEncoding) {\n        if (msg === null) {\n            throw new TypeError(\"msg must be a string or Uint8Array.\");\n        } else if (typeof msg === \"string\") {\n            msg = encode1(msg, inputEncoding);\n        }\n        for(let i = 0, len = msg.length; i < len; i++){\n            this._buf[this._bufIdx++] = msg[i];\n            if (this._bufIdx === 64) {\n                this._transform();\n                this._bufIdx = 0;\n            }\n        }\n        const c = this._count;\n        if ((c[0] += msg.length << 3) < msg.length << 3) {\n            c[1]++;\n        }\n        c[1] += msg.length >>> 29;\n        return this;\n    }\n    digest(outputEncoding) {\n        if (this._finalized) {\n            throw new Error(\"digest has already been called.\");\n        }\n        this._finalized = true;\n        const b = this._buf;\n        let idx = this._bufIdx;\n        b[idx++] = 0x80;\n        while(idx !== 56){\n            if (idx === 64) {\n                this._transform();\n                idx = 0;\n            }\n            b[idx++] = 0;\n        }\n        const c = this._count;\n        b[56] = c[1] >>> 24 & 0xff;\n        b[57] = c[1] >>> 16 & 0xff;\n        b[58] = c[1] >>> 8 & 0xff;\n        b[59] = c[1] >>> 0 & 0xff;\n        b[60] = c[0] >>> 24 & 0xff;\n        b[61] = c[0] >>> 16 & 0xff;\n        b[62] = c[0] >>> 8 & 0xff;\n        b[63] = c[0] >>> 0 & 0xff;\n        this._transform();\n        const hash = new Uint8Array(32);\n        for(let i = 0; i < 8; i++){\n            hash[(i << 2) + 0] = this._H[i] >>> 24 & 0xff;\n            hash[(i << 2) + 1] = this._H[i] >>> 16 & 0xff;\n            hash[(i << 2) + 2] = this._H[i] >>> 8 & 0xff;\n            hash[(i << 2) + 3] = this._H[i] >>> 0 & 0xff;\n        }\n        this.init();\n        return outputEncoding ? decode1(hash, outputEncoding) : hash;\n    }\n    _transform() {\n        const h = this._H;\n        let h0 = h[0];\n        let h1 = h[1];\n        let h2 = h[2];\n        let h3 = h[3];\n        let h4 = h[4];\n        let h5 = h[5];\n        let h6 = h[6];\n        let h7 = h[7];\n        const w = new Uint32Array(16);\n        let i;\n        for(i = 0; i < 16; i++){\n            w[i] = this._buf[(i << 2) + 3] | this._buf[(i << 2) + 2] << 8 | this._buf[(i << 2) + 1] << 16 | this._buf[i << 2] << 24;\n        }\n        for(i = 0; i < 64; i++){\n            let tmp;\n            if (i < 16) {\n                tmp = w[i];\n            } else {\n                let a = w[i + 1 & 15];\n                let b = w[i + 14 & 15];\n                tmp = w[i & 15] = (a >>> 7 ^ a >>> 18 ^ a >>> 3 ^ a << 25 ^ a << 14) + (b >>> 17 ^ b >>> 19 ^ b >>> 10 ^ b << 15 ^ b << 13) + w[i & 15] + w[i + 9 & 15] | 0;\n            }\n            tmp = tmp + h7 + (h4 >>> 6 ^ h4 >>> 11 ^ h4 >>> 25 ^ h4 << 26 ^ h4 << 21 ^ h4 << 7) + (h6 ^ h4 & (h5 ^ h6)) + this._K[i] | 0;\n            h7 = h6;\n            h6 = h5;\n            h5 = h4;\n            h4 = h3 + tmp;\n            h3 = h2;\n            h2 = h1;\n            h1 = h0;\n            h0 = tmp + (h1 & h2 ^ h3 & (h1 ^ h2)) + (h1 >>> 2 ^ h1 >>> 13 ^ h1 >>> 22 ^ h1 << 30 ^ h1 << 19 ^ h1 << 10) | 0;\n        }\n        h[0] = h[0] + h0 | 0;\n        h[1] = h[1] + h1 | 0;\n        h[2] = h[2] + h2 | 0;\n        h[3] = h[3] + h3 | 0;\n        h[4] = h[4] + h4 | 0;\n        h[5] = h[5] + h5 | 0;\n        h[6] = h[6] + h6 | 0;\n        h[7] = h[7] + h7 | 0;\n    }\n}\nclass BaseRequest {\n    token;\n    received;\n    ctx;\n    requestSubject;\n    mux;\n    constructor(mux, requestSubject, asyncTraces = true){\n        this.mux = mux;\n        this.requestSubject = requestSubject;\n        this.received = 0;\n        this.token = nuid.next();\n        if (asyncTraces) {\n            this.ctx = new Error();\n        }\n    }\n}\nclass RequestMany extends BaseRequest {\n    callback;\n    done;\n    timer;\n    max;\n    opts;\n    constructor(mux, requestSubject, opts = {\n        maxWait: 1000\n    }){\n        super(mux, requestSubject);\n        this.opts = opts;\n        if (typeof this.opts.callback !== \"function\") {\n            throw new Error(\"callback is required\");\n        }\n        this.callback = this.opts.callback;\n        this.max = typeof opts.maxMessages === \"number\" && opts.maxMessages > 0 ? opts.maxMessages : -1;\n        this.done = deferred();\n        this.done.then(()=>{\n            this.callback(null, null);\n        });\n        this.timer = setTimeout(()=>{\n            this.cancel();\n        }, opts.maxWait);\n    }\n    cancel(err) {\n        if (err) {\n            this.callback(err, null);\n        }\n        clearTimeout(this.timer);\n        this.mux.cancel(this);\n        this.done.resolve();\n    }\n    resolver(err, msg) {\n        if (err) {\n            if (this.ctx) {\n                err.stack += `\\n\\n${this.ctx.stack}`;\n            }\n            this.cancel(err);\n        } else {\n            this.callback(null, msg);\n            if (this.opts.strategy === RequestStrategy.Count) {\n                this.max--;\n                if (this.max === 0) {\n                    this.cancel();\n                }\n            }\n            if (this.opts.strategy === RequestStrategy.JitterTimer) {\n                clearTimeout(this.timer);\n                this.timer = setTimeout(()=>{\n                    this.cancel();\n                }, this.opts.jitter || 300);\n            }\n            if (this.opts.strategy === RequestStrategy.SentinelMsg) {\n                if (msg && msg.data.length === 0) {\n                    this.cancel();\n                }\n            }\n        }\n    }\n}\nclass RequestOne extends BaseRequest {\n    deferred;\n    timer;\n    constructor(mux, requestSubject, opts = {\n        timeout: 1000\n    }, asyncTraces = true){\n        super(mux, requestSubject, asyncTraces);\n        this.deferred = deferred();\n        this.timer = timeout(opts.timeout, asyncTraces);\n    }\n    resolver(err, msg) {\n        if (this.timer) {\n            this.timer.cancel();\n        }\n        if (err) {\n            if (this.ctx) {\n                err.stack += `\\n\\n${this.ctx.stack}`;\n            }\n            this.deferred.reject(err);\n        } else {\n            this.deferred.resolve(msg);\n        }\n        this.cancel();\n    }\n    cancel(err) {\n        if (this.timer) {\n            this.timer.cancel();\n        }\n        this.mux.cancel(this);\n        this.deferred.reject(err ? err : NatsError.errorForCode(ErrorCode.Cancelled));\n    }\n}\nconst defaultPrefix = \"$JS.API\";\nfunction defaultJsOptions(opts) {\n    opts = opts || {};\n    if (opts.domain) {\n        opts.apiPrefix = `$JS.${opts.domain}.API`;\n        delete opts.domain;\n    }\n    return extend({\n        apiPrefix: defaultPrefix,\n        timeout: 5000\n    }, opts);\n}\nclass BaseApiClient {\n    nc;\n    opts;\n    prefix;\n    timeout;\n    jc;\n    constructor(nc, opts){\n        this.nc = nc;\n        this.opts = defaultJsOptions(opts);\n        this._parseOpts();\n        this.prefix = this.opts.apiPrefix;\n        this.timeout = this.opts.timeout;\n        this.jc = JSONCodec();\n    }\n    getOptions() {\n        return Object.assign({}, this.opts);\n    }\n    _parseOpts() {\n        let prefix = this.opts.apiPrefix;\n        if (!prefix || prefix.length === 0) {\n            throw new Error(\"invalid empty prefix\");\n        }\n        const c = prefix[prefix.length - 1];\n        if (c === \".\") {\n            prefix = prefix.substr(0, prefix.length - 1);\n        }\n        this.opts.apiPrefix = prefix;\n    }\n    async _request(subj, data = null, opts) {\n        opts = opts || {};\n        opts.timeout = this.timeout;\n        let a = Empty;\n        if (data) {\n            a = this.jc.encode(data);\n        }\n        let { retries } = opts;\n        retries = retries || 1;\n        retries = retries === -1 ? Number.MAX_SAFE_INTEGER : retries;\n        const bo = backoff();\n        for(let i = 0; i < retries; i++){\n            try {\n                const m = await this.nc.request(subj, a, opts);\n                return this.parseJsResponse(m);\n            } catch (err) {\n                const ne = err;\n                if ((ne.code === \"503\" || ne.code === ErrorCode.Timeout) && i + 1 < retries) {\n                    await delay(bo.backoff(i));\n                } else {\n                    throw err;\n                }\n            }\n        }\n    }\n    async findStream(subject) {\n        const q = {\n            subject\n        };\n        const r = await this._request(`${this.prefix}.STREAM.NAMES`, q);\n        const names = r;\n        if (!names.streams || names.streams.length !== 1) {\n            throw new Error(\"no stream matches subject\");\n        }\n        return names.streams[0];\n    }\n    getConnection() {\n        return this.nc;\n    }\n    parseJsResponse(m) {\n        const v = this.jc.decode(m.data);\n        const r = v;\n        if (r.error) {\n            const err = checkJsErrorCode(r.error.code, r.error.description);\n            if (err !== null) {\n                err.api_error = r.error;\n                throw err;\n            }\n        }\n        return v;\n    }\n}\nclass ListerImpl {\n    err;\n    offset;\n    pageInfo;\n    subject;\n    jsm;\n    filter;\n    payload;\n    constructor(subject, filter, jsm, payload){\n        if (!subject) {\n            throw new Error(\"subject is required\");\n        }\n        this.subject = subject;\n        this.jsm = jsm;\n        this.offset = 0;\n        this.pageInfo = {};\n        this.filter = filter;\n        this.payload = payload || {};\n    }\n    async next() {\n        if (this.err) {\n            return [];\n        }\n        if (this.pageInfo && this.offset >= this.pageInfo.total) {\n            return [];\n        }\n        const offset = {\n            offset: this.offset\n        };\n        if (this.payload) {\n            Object.assign(offset, this.payload);\n        }\n        try {\n            const r = await this.jsm._request(this.subject, offset, {\n                timeout: this.jsm.timeout\n            });\n            this.pageInfo = r;\n            const count = this.countResponse(r);\n            if (count === 0) {\n                return [];\n            }\n            this.offset += count;\n            const a = this.filter(r);\n            return a;\n        } catch (err) {\n            this.err = err;\n            throw err;\n        }\n    }\n    countResponse(r) {\n        switch(r?.type){\n            case \"io.nats.jetstream.api.v1.stream_names_response\":\n            case \"io.nats.jetstream.api.v1.stream_list_response\":\n                return r.streams?.length || 0;\n            case \"io.nats.jetstream.api.v1.consumer_list_response\":\n                return r.consumers?.length || 0;\n            default:\n                console.error(`jslister.ts: unknown API response for paged output: ${r?.type}`);\n                return r.streams?.length || 0;\n        }\n        return 0;\n    }\n    async *[Symbol.asyncIterator]() {\n        let page = await this.next();\n        while(page.length > 0){\n            for (const item of page){\n                yield item;\n            }\n            page = await this.next();\n        }\n    }\n}\nfunction parseSemVer(s = \"\") {\n    const m = s.match(/(\\d+).(\\d+).(\\d+)/);\n    if (m) {\n        return {\n            major: parseInt(m[1]),\n            minor: parseInt(m[2]),\n            micro: parseInt(m[3])\n        };\n    }\n    throw new Error(`'${s}' is not a semver value`);\n}\nfunction compare(a, b) {\n    if (a.major < b.major) return -1;\n    if (a.major > b.major) return 1;\n    if (a.minor < b.minor) return -1;\n    if (a.minor > b.minor) return 1;\n    if (a.micro < b.micro) return -1;\n    if (a.micro > b.micro) return 1;\n    return 0;\n}\nvar Feature;\n(function(Feature) {\n    Feature[\"JS_KV\"] = \"js_kv\";\n    Feature[\"JS_OBJECTSTORE\"] = \"js_objectstore\";\n    Feature[\"JS_PULL_MAX_BYTES\"] = \"js_pull_max_bytes\";\n    Feature[\"JS_NEW_CONSUMER_CREATE_API\"] = \"js_new_consumer_create\";\n    Feature[\"JS_ALLOW_DIRECT\"] = \"js_allow_direct\";\n    Feature[\"JS_MULTIPLE_CONSUMER_FILTER\"] = \"js_multiple_consumer_filter\";\n    Feature[\"JS_SIMPLIFICATION\"] = \"js_simplification\";\n    Feature[\"JS_STREAM_CONSUMER_METADATA\"] = \"js_stream_consumer_metadata\";\n    Feature[\"JS_CONSUMER_FILTER_SUBJECTS\"] = \"js_consumer_filter_subjects\";\n    Feature[\"JS_STREAM_FIRST_SEQ\"] = \"js_stream_first_seq\";\n    Feature[\"JS_STREAM_SUBJECT_TRANSFORM\"] = \"js_stream_subject_transform\";\n    Feature[\"JS_STREAM_SOURCE_SUBJECT_TRANSFORM\"] = \"js_stream_source_subject_transform\";\n    Feature[\"JS_STREAM_COMPRESSION\"] = \"js_stream_compression\";\n    Feature[\"JS_DEFAULT_CONSUMER_LIMITS\"] = \"js_default_consumer_limits\";\n    Feature[\"JS_BATCH_DIRECT_GET\"] = \"js_batch_direct_get\";\n})(Feature || (Feature = {}));\nclass Features {\n    server;\n    features;\n    disabled;\n    constructor(v){\n        this.features = new Map();\n        this.disabled = [];\n        this.update(v);\n    }\n    resetDisabled() {\n        this.disabled.length = 0;\n        this.update(this.server);\n    }\n    disable(f) {\n        this.disabled.push(f);\n        this.update(this.server);\n    }\n    isDisabled(f) {\n        return this.disabled.indexOf(f) !== -1;\n    }\n    update(v) {\n        if (typeof v === \"string\") {\n            v = parseSemVer(v);\n        }\n        this.server = v;\n        this.set(Feature.JS_KV, \"2.6.2\");\n        this.set(Feature.JS_OBJECTSTORE, \"2.6.3\");\n        this.set(Feature.JS_PULL_MAX_BYTES, \"2.8.3\");\n        this.set(Feature.JS_NEW_CONSUMER_CREATE_API, \"2.9.0\");\n        this.set(Feature.JS_ALLOW_DIRECT, \"2.9.0\");\n        this.set(Feature.JS_MULTIPLE_CONSUMER_FILTER, \"2.10.0\");\n        this.set(Feature.JS_SIMPLIFICATION, \"2.9.4\");\n        this.set(Feature.JS_STREAM_CONSUMER_METADATA, \"2.10.0\");\n        this.set(Feature.JS_CONSUMER_FILTER_SUBJECTS, \"2.10.0\");\n        this.set(Feature.JS_STREAM_FIRST_SEQ, \"2.10.0\");\n        this.set(Feature.JS_STREAM_SUBJECT_TRANSFORM, \"2.10.0\");\n        this.set(Feature.JS_STREAM_SOURCE_SUBJECT_TRANSFORM, \"2.10.0\");\n        this.set(Feature.JS_STREAM_COMPRESSION, \"2.10.0\");\n        this.set(Feature.JS_DEFAULT_CONSUMER_LIMITS, \"2.10.0\");\n        this.set(Feature.JS_BATCH_DIRECT_GET, \"2.11.0\");\n        this.disabled.forEach((f)=>{\n            this.features.delete(f);\n        });\n    }\n    set(f, requires) {\n        this.features.set(f, {\n            min: requires,\n            ok: compare(this.server, parseSemVer(requires)) >= 0\n        });\n    }\n    get(f) {\n        return this.features.get(f) || {\n            min: \"unknown\",\n            ok: false\n        };\n    }\n    supports(f) {\n        return this.get(f)?.ok || false;\n    }\n    require(v) {\n        if (typeof v === \"string\") {\n            v = parseSemVer(v);\n        }\n        return compare(this.server, v) >= 0;\n    }\n}\nclass ConsumerAPIImpl extends BaseApiClient {\n    constructor(nc, opts){\n        super(nc, opts);\n    }\n    async add(stream, cfg, action = ConsumerApiAction.Create) {\n        validateStreamName(stream);\n        if (cfg.deliver_group && cfg.flow_control) {\n            throw new Error(\"jetstream flow control is not supported with queue groups\");\n        }\n        if (cfg.deliver_group && cfg.idle_heartbeat) {\n            throw new Error(\"jetstream idle heartbeat is not supported with queue groups\");\n        }\n        const cr = {};\n        cr.config = cfg;\n        cr.stream_name = stream;\n        cr.action = action;\n        if (cr.config.durable_name) {\n            validateDurableName(cr.config.durable_name);\n        }\n        const nci = this.nc;\n        let { min, ok: newAPI } = nci.features.get(Feature.JS_NEW_CONSUMER_CREATE_API);\n        const name = cfg.name === \"\" ? undefined : cfg.name;\n        if (name && !newAPI) {\n            throw new Error(`consumer 'name' requires server ${min}`);\n        }\n        if (name) {\n            try {\n                minValidation(\"name\", name);\n            } catch (err) {\n                const m = err.message;\n                const idx = m.indexOf(\"cannot contain\");\n                if (idx !== -1) {\n                    throw new Error(`consumer 'name' ${m.substring(idx)}`);\n                }\n                throw err;\n            }\n        }\n        let subj;\n        let consumerName = \"\";\n        if (Array.isArray(cfg.filter_subjects)) {\n            const { min, ok } = nci.features.get(Feature.JS_MULTIPLE_CONSUMER_FILTER);\n            if (!ok) {\n                throw new Error(`consumer 'filter_subjects' requires server ${min}`);\n            }\n            newAPI = false;\n        }\n        if (cfg.metadata) {\n            const { min, ok } = nci.features.get(Feature.JS_STREAM_CONSUMER_METADATA);\n            if (!ok) {\n                throw new Error(`consumer 'metadata' requires server ${min}`);\n            }\n        }\n        if (newAPI) {\n            consumerName = cfg.name ?? cfg.durable_name ?? \"\";\n        }\n        if (consumerName !== \"\") {\n            let fs = cfg.filter_subject ?? undefined;\n            if (fs === \">\") {\n                fs = undefined;\n            }\n            subj = fs !== undefined ? `${this.prefix}.CONSUMER.CREATE.${stream}.${consumerName}.${fs}` : `${this.prefix}.CONSUMER.CREATE.${stream}.${consumerName}`;\n        } else {\n            subj = cfg.durable_name ? `${this.prefix}.CONSUMER.DURABLE.CREATE.${stream}.${cfg.durable_name}` : `${this.prefix}.CONSUMER.CREATE.${stream}`;\n        }\n        const r = await this._request(subj, cr);\n        return r;\n    }\n    async update(stream, durable, cfg) {\n        const ci = await this.info(stream, durable);\n        const changable = cfg;\n        return this.add(stream, Object.assign(ci.config, changable), ConsumerApiAction.Update);\n    }\n    async info(stream, name) {\n        validateStreamName(stream);\n        validateDurableName(name);\n        const r = await this._request(`${this.prefix}.CONSUMER.INFO.${stream}.${name}`);\n        return r;\n    }\n    async delete(stream, name) {\n        validateStreamName(stream);\n        validateDurableName(name);\n        const r = await this._request(`${this.prefix}.CONSUMER.DELETE.${stream}.${name}`);\n        const cr = r;\n        return cr.success;\n    }\n    list(stream) {\n        validateStreamName(stream);\n        const filter = (v)=>{\n            const clr = v;\n            return clr.consumers;\n        };\n        const subj = `${this.prefix}.CONSUMER.LIST.${stream}`;\n        return new ListerImpl(subj, filter, this);\n    }\n    pause(stream, name, until) {\n        const subj = `${this.prefix}.CONSUMER.PAUSE.${stream}.${name}`;\n        const opts = {\n            pause_until: until.toISOString()\n        };\n        return this._request(subj, opts);\n    }\n    resume(stream, name) {\n        return this.pause(stream, name, new Date(0));\n    }\n}\nfunction checkFn(fn, name, required = false) {\n    if (required === true && !fn) {\n        throw NatsError.errorForCode(ErrorCode.ApiError, new Error(`${name} is not a function`));\n    }\n    if (fn && typeof fn !== \"function\") {\n        throw NatsError.errorForCode(ErrorCode.ApiError, new Error(`${name} is not a function`));\n    }\n}\nclass TypedSubscription extends QueuedIteratorImpl {\n    sub;\n    adapter;\n    subIterDone;\n    constructor(nc, subject, opts){\n        super();\n        checkFn(opts.adapter, \"adapter\", true);\n        this.adapter = opts.adapter;\n        if (opts.callback) {\n            checkFn(opts.callback, \"callback\");\n        }\n        this.noIterator = typeof opts.callback === \"function\";\n        if (opts.ingestionFilterFn) {\n            checkFn(opts.ingestionFilterFn, \"ingestionFilterFn\");\n            this.ingestionFilterFn = opts.ingestionFilterFn;\n        }\n        if (opts.protocolFilterFn) {\n            checkFn(opts.protocolFilterFn, \"protocolFilterFn\");\n            this.protocolFilterFn = opts.protocolFilterFn;\n        }\n        if (opts.dispatchedFn) {\n            checkFn(opts.dispatchedFn, \"dispatchedFn\");\n            this.dispatchedFn = opts.dispatchedFn;\n        }\n        if (opts.cleanupFn) {\n            checkFn(opts.cleanupFn, \"cleanupFn\");\n        }\n        let callback = (err, msg)=>{\n            this.callback(err, msg);\n        };\n        if (opts.callback) {\n            const uh = opts.callback;\n            callback = (err, msg)=>{\n                const [jer, tm] = this.adapter(err, msg);\n                if (jer) {\n                    uh(jer, null);\n                    return;\n                }\n                const { ingest } = this.ingestionFilterFn ? this.ingestionFilterFn(tm, this) : {\n                    ingest: true\n                };\n                if (ingest) {\n                    const ok = this.protocolFilterFn ? this.protocolFilterFn(tm) : true;\n                    if (ok) {\n                        uh(jer, tm);\n                        if (this.dispatchedFn && tm) {\n                            this.dispatchedFn(tm);\n                        }\n                    }\n                }\n            };\n        }\n        const { max, queue, timeout } = opts;\n        const sopts = {\n            queue,\n            timeout,\n            callback\n        };\n        if (max && max > 0) {\n            sopts.max = max;\n        }\n        this.sub = nc.subscribe(subject, sopts);\n        if (opts.cleanupFn) {\n            this.sub.cleanupFn = opts.cleanupFn;\n        }\n        if (!this.noIterator) {\n            this.iterClosed.then(()=>{\n                this.unsubscribe();\n            });\n        }\n        this.subIterDone = deferred();\n        Promise.all([\n            this.sub.closed,\n            this.iterClosed\n        ]).then(()=>{\n            this.subIterDone.resolve();\n        }).catch(()=>{\n            this.subIterDone.resolve();\n        });\n        (async (s)=>{\n            await s.closed;\n            this.stop();\n        })(this.sub).then().catch();\n    }\n    unsubscribe(max) {\n        this.sub.unsubscribe(max);\n    }\n    drain() {\n        return this.sub.drain();\n    }\n    isDraining() {\n        return this.sub.isDraining();\n    }\n    isClosed() {\n        return this.sub.isClosed();\n    }\n    callback(e, msg) {\n        this.sub.cancelTimeout();\n        const [err, tm] = this.adapter(e, msg);\n        if (err) {\n            this.stop(err);\n        }\n        if (tm) {\n            this.push(tm);\n        }\n    }\n    getSubject() {\n        return this.sub.getSubject();\n    }\n    getReceived() {\n        return this.sub.getReceived();\n    }\n    getProcessed() {\n        return this.sub.getProcessed();\n    }\n    getPending() {\n        return this.sub.getPending();\n    }\n    getID() {\n        return this.sub.getID();\n    }\n    getMax() {\n        return this.sub.getMax();\n    }\n    get closed() {\n        return this.sub.closed;\n    }\n}\nlet transportConfig;\nfunction setTransportFactory(config) {\n    transportConfig = config;\n}\nfunction defaultPort() {\n    return transportConfig !== undefined && transportConfig.defaultPort !== undefined ? transportConfig.defaultPort : 4222;\n}\nfunction getUrlParseFn() {\n    return transportConfig !== undefined && transportConfig.urlParseFn ? transportConfig.urlParseFn : undefined;\n}\nfunction newTransport() {\n    if (!transportConfig || typeof transportConfig.factory !== \"function\") {\n        throw new Error(\"transport fn is not set\");\n    }\n    return transportConfig.factory();\n}\nfunction getResolveFn() {\n    return transportConfig !== undefined && transportConfig.dnsResolveFn ? transportConfig.dnsResolveFn : undefined;\n}\nconst CR_LF = \"\\r\\n\";\nCR_LF.length;\nconst CRLF = DataBuffer.fromAscii(CR_LF);\nconst CR = new Uint8Array(CRLF)[0];\nconst LF = new Uint8Array(CRLF)[1];\nfunction protoLen(ba) {\n    for(let i = 0; i < ba.length; i++){\n        const n = i + 1;\n        if (ba.byteLength > n && ba[i] === CR && ba[n] === LF) {\n            return n + 1;\n        }\n    }\n    return 0;\n}\nfunction extractProtocolMessage(a) {\n    const len = protoLen(a);\n    if (len > 0) {\n        const ba = new Uint8Array(a);\n        const out = ba.slice(0, len);\n        return TD.decode(out);\n    }\n    return \"\";\n}\nconst IPv4LEN = 4;\nconst ASCII0 = 48;\nconst ASCIIA = 65;\nconst ASCIIa = 97;\nfunction ipV4(a, b, c, d) {\n    const ip = new Uint8Array(16);\n    const prefix = [\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0xff,\n        0xff\n    ];\n    prefix.forEach((v, idx)=>{\n        ip[idx] = v;\n    });\n    ip[12] = a;\n    ip[13] = b;\n    ip[14] = c;\n    ip[15] = d;\n    return ip;\n}\nfunction isIP(h) {\n    return parseIP(h) !== undefined;\n}\nfunction parseIP(h) {\n    for(let i = 0; i < h.length; i++){\n        switch(h[i]){\n            case \".\":\n                return parseIPv4(h);\n            case \":\":\n                return parseIPv6(h);\n        }\n    }\n    return;\n}\nfunction parseIPv4(s) {\n    const ip = new Uint8Array(4);\n    for(let i = 0; i < 4; i++){\n        if (s.length === 0) {\n            return undefined;\n        }\n        if (i > 0) {\n            if (s[0] !== \".\") {\n                return undefined;\n            }\n            s = s.substring(1);\n        }\n        const { n, c, ok } = dtoi(s);\n        if (!ok || n > 0xFF) {\n            return undefined;\n        }\n        s = s.substring(c);\n        ip[i] = n;\n    }\n    return ipV4(ip[0], ip[1], ip[2], ip[3]);\n}\nfunction parseIPv6(s) {\n    const ip = new Uint8Array(16);\n    let ellipsis = -1;\n    if (s.length >= 2 && s[0] === \":\" && s[1] === \":\") {\n        ellipsis = 0;\n        s = s.substring(2);\n        if (s.length === 0) {\n            return ip;\n        }\n    }\n    let i = 0;\n    while(i < 16){\n        const { n, c, ok } = xtoi(s);\n        if (!ok || n > 0xFFFF) {\n            return undefined;\n        }\n        if (c < s.length && s[c] === \".\") {\n            if (ellipsis < 0 && i != 16 - 4) {\n                return undefined;\n            }\n            if (i + 4 > 16) {\n                return undefined;\n            }\n            const ip4 = parseIPv4(s);\n            if (ip4 === undefined) {\n                return undefined;\n            }\n            ip[i] = ip4[12];\n            ip[i + 1] = ip4[13];\n            ip[i + 2] = ip4[14];\n            ip[i + 3] = ip4[15];\n            s = \"\";\n            i += IPv4LEN;\n            break;\n        }\n        ip[i] = n >> 8;\n        ip[i + 1] = n;\n        i += 2;\n        s = s.substring(c);\n        if (s.length === 0) {\n            break;\n        }\n        if (s[0] !== \":\" || s.length == 1) {\n            return undefined;\n        }\n        s = s.substring(1);\n        if (s[0] === \":\") {\n            if (ellipsis >= 0) {\n                return undefined;\n            }\n            ellipsis = i;\n            s = s.substring(1);\n            if (s.length === 0) {\n                break;\n            }\n        }\n    }\n    if (s.length !== 0) {\n        return undefined;\n    }\n    if (i < 16) {\n        if (ellipsis < 0) {\n            return undefined;\n        }\n        const n = 16 - i;\n        for(let j = i - 1; j >= ellipsis; j--){\n            ip[j + n] = ip[j];\n        }\n        for(let j = ellipsis + n - 1; j >= ellipsis; j--){\n            ip[j] = 0;\n        }\n    } else if (ellipsis >= 0) {\n        return undefined;\n    }\n    return ip;\n}\nfunction dtoi(s) {\n    let i = 0;\n    let n = 0;\n    for(i = 0; i < s.length && 48 <= s.charCodeAt(i) && s.charCodeAt(i) <= 57; i++){\n        n = n * 10 + (s.charCodeAt(i) - ASCII0);\n        if (n >= 0xFFFFFF) {\n            return {\n                n: 0xFFFFFF,\n                c: i,\n                ok: false\n            };\n        }\n    }\n    if (i === 0) {\n        return {\n            n: 0,\n            c: 0,\n            ok: false\n        };\n    }\n    return {\n        n: n,\n        c: i,\n        ok: true\n    };\n}\nfunction xtoi(s) {\n    let n = 0;\n    let i = 0;\n    for(i = 0; i < s.length; i++){\n        if (48 <= s.charCodeAt(i) && s.charCodeAt(i) <= 57) {\n            n *= 16;\n            n += s.charCodeAt(i) - ASCII0;\n        } else if (97 <= s.charCodeAt(i) && s.charCodeAt(i) <= 102) {\n            n *= 16;\n            n += s.charCodeAt(i) - ASCIIa + 10;\n        } else if (65 <= s.charCodeAt(i) && s.charCodeAt(i) <= 70) {\n            n *= 16;\n            n += s.charCodeAt(i) - ASCIIA + 10;\n        } else {\n            break;\n        }\n        if (n >= 0xFFFFFF) {\n            return {\n                n: 0,\n                c: i,\n                ok: false\n            };\n        }\n    }\n    if (i === 0) {\n        return {\n            n: 0,\n            c: i,\n            ok: false\n        };\n    }\n    return {\n        n: n,\n        c: i,\n        ok: true\n    };\n}\nfunction isIPV4OrHostname(hp) {\n    if (hp.indexOf(\"[\") !== -1 || hp.indexOf(\"::\") !== -1) {\n        return false;\n    }\n    if (hp.indexOf(\".\") !== -1) {\n        return true;\n    }\n    if (hp.split(\":\").length <= 2) {\n        return true;\n    }\n    return false;\n}\nfunction isIPV6(hp) {\n    return !isIPV4OrHostname(hp);\n}\nfunction filterIpv6MappedToIpv4(hp) {\n    const prefix = \"::FFFF:\";\n    const idx = hp.toUpperCase().indexOf(prefix);\n    if (idx !== -1 && hp.indexOf(\".\") !== -1) {\n        let ip = hp.substring(idx + prefix.length);\n        ip = ip.replace(\"[\", \"\");\n        return ip.replace(\"]\", \"\");\n    }\n    return hp;\n}\nfunction hostPort(u) {\n    u = u.trim();\n    if (u.match(/^(.*:\\/\\/)(.*)/m)) {\n        u = u.replace(/^(.*:\\/\\/)(.*)/gm, \"$2\");\n    }\n    u = filterIpv6MappedToIpv4(u);\n    if (isIPV6(u) && u.indexOf(\"[\") === -1) {\n        u = `[${u}]`;\n    }\n    const op = isIPV6(u) ? u.match(/(]:)(\\d+)/) : u.match(/(:)(\\d+)/);\n    const port = op && op.length === 3 && op[1] && op[2] ? parseInt(op[2]) : 4222;\n    const protocol = port === 80 ? \"https\" : \"http\";\n    const url = new URL(`${protocol}://${u}`);\n    url.port = `${port}`;\n    let hostname = url.hostname;\n    if (hostname.charAt(0) === \"[\") {\n        hostname = hostname.substring(1, hostname.length - 1);\n    }\n    const listen = url.host;\n    return {\n        listen,\n        hostname,\n        port\n    };\n}\nclass ServerImpl {\n    src;\n    listen;\n    hostname;\n    port;\n    didConnect;\n    reconnects;\n    lastConnect;\n    gossiped;\n    tlsName;\n    resolves;\n    constructor(u, gossiped = false){\n        this.src = u;\n        this.tlsName = \"\";\n        const v = hostPort(u);\n        this.listen = v.listen;\n        this.hostname = v.hostname;\n        this.port = v.port;\n        this.didConnect = false;\n        this.reconnects = 0;\n        this.lastConnect = 0;\n        this.gossiped = gossiped;\n    }\n    toString() {\n        return this.listen;\n    }\n    async resolve(opts) {\n        if (!opts.fn || opts.resolve === false) {\n            return [\n                this\n            ];\n        }\n        const buf = [];\n        if (isIP(this.hostname)) {\n            return [\n                this\n            ];\n        } else {\n            const ips = await opts.fn(this.hostname);\n            if (opts.debug) {\n                console.log(`resolve ${this.hostname} = ${ips.join(\",\")}`);\n            }\n            for (const ip of ips){\n                const proto = this.port === 80 ? \"https\" : \"http\";\n                const url = new URL(`${proto}://${isIPV6(ip) ? \"[\" + ip + \"]\" : ip}`);\n                url.port = `${this.port}`;\n                const ss = new ServerImpl(url.host, false);\n                ss.tlsName = this.hostname;\n                buf.push(ss);\n            }\n        }\n        if (opts.randomize) {\n            shuffle(buf);\n        }\n        this.resolves = buf;\n        return buf;\n    }\n}\nclass Servers {\n    firstSelect;\n    servers;\n    currentServer;\n    tlsName;\n    randomize;\n    constructor(listens = [], opts = {}){\n        this.firstSelect = true;\n        this.servers = [];\n        this.tlsName = \"\";\n        this.randomize = opts.randomize || false;\n        const urlParseFn = getUrlParseFn();\n        if (listens) {\n            listens.forEach((hp)=>{\n                hp = urlParseFn ? urlParseFn(hp) : hp;\n                this.servers.push(new ServerImpl(hp));\n            });\n            if (this.randomize) {\n                this.servers = shuffle(this.servers);\n            }\n        }\n        if (this.servers.length === 0) {\n            this.addServer(`${DEFAULT_HOST}:${defaultPort()}`, false);\n        }\n        this.currentServer = this.servers[0];\n    }\n    clear() {\n        this.servers.length = 0;\n    }\n    updateTLSName() {\n        const cs = this.getCurrentServer();\n        if (!isIP(cs.hostname)) {\n            this.tlsName = cs.hostname;\n            this.servers.forEach((s)=>{\n                if (s.gossiped) {\n                    s.tlsName = this.tlsName;\n                }\n            });\n        }\n    }\n    getCurrentServer() {\n        return this.currentServer;\n    }\n    addServer(u, implicit = false) {\n        const urlParseFn = getUrlParseFn();\n        u = urlParseFn ? urlParseFn(u) : u;\n        const s = new ServerImpl(u, implicit);\n        if (isIP(s.hostname)) {\n            s.tlsName = this.tlsName;\n        }\n        this.servers.push(s);\n    }\n    selectServer() {\n        if (this.firstSelect) {\n            this.firstSelect = false;\n            return this.currentServer;\n        }\n        const t = this.servers.shift();\n        if (t) {\n            this.servers.push(t);\n            this.currentServer = t;\n        }\n        return t;\n    }\n    removeCurrentServer() {\n        this.removeServer(this.currentServer);\n    }\n    removeServer(server) {\n        if (server) {\n            const index = this.servers.indexOf(server);\n            this.servers.splice(index, 1);\n        }\n    }\n    length() {\n        return this.servers.length;\n    }\n    next() {\n        return this.servers.length ? this.servers[0] : undefined;\n    }\n    getServers() {\n        return this.servers;\n    }\n    update(info, encrypted) {\n        const added = [];\n        let deleted = [];\n        const urlParseFn = getUrlParseFn();\n        const discovered = new Map();\n        if (info.connect_urls && info.connect_urls.length > 0) {\n            info.connect_urls.forEach((hp)=>{\n                hp = urlParseFn ? urlParseFn(hp, encrypted) : hp;\n                const s = new ServerImpl(hp, true);\n                discovered.set(hp, s);\n            });\n        }\n        const toDelete = [];\n        this.servers.forEach((s, index)=>{\n            const u = s.listen;\n            if (s.gossiped && this.currentServer.listen !== u && discovered.get(u) === undefined) {\n                toDelete.push(index);\n            }\n            discovered.delete(u);\n        });\n        toDelete.reverse();\n        toDelete.forEach((index)=>{\n            const removed = this.servers.splice(index, 1);\n            deleted = deleted.concat(removed[0].listen);\n        });\n        discovered.forEach((v, k)=>{\n            this.servers.push(v);\n            added.push(k);\n        });\n        return {\n            added,\n            deleted\n        };\n    }\n}\nclass MuxSubscription {\n    baseInbox;\n    reqs;\n    constructor(){\n        this.reqs = new Map();\n    }\n    size() {\n        return this.reqs.size;\n    }\n    init(prefix) {\n        this.baseInbox = `${createInbox(prefix)}.`;\n        return this.baseInbox;\n    }\n    add(r) {\n        if (!isNaN(r.received)) {\n            r.received = 0;\n        }\n        this.reqs.set(r.token, r);\n    }\n    get(token) {\n        return this.reqs.get(token);\n    }\n    cancel(r) {\n        this.reqs.delete(r.token);\n    }\n    getToken(m) {\n        const s = m.subject || \"\";\n        if (s.indexOf(this.baseInbox) === 0) {\n            return s.substring(this.baseInbox.length);\n        }\n        return null;\n    }\n    all() {\n        return Array.from(this.reqs.values());\n    }\n    handleError(isMuxPermissionError, err) {\n        if (err && err.permissionContext) {\n            if (isMuxPermissionError) {\n                this.all().forEach((r)=>{\n                    r.resolver(err, {});\n                });\n                return true;\n            }\n            const ctx = err.permissionContext;\n            if (ctx.operation === \"publish\") {\n                const req = this.all().find((s)=>{\n                    return s.requestSubject === ctx.subject;\n                });\n                if (req) {\n                    req.resolver(err, {});\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    dispatcher() {\n        return (err, m)=>{\n            const token = this.getToken(m);\n            if (token) {\n                const r = this.get(token);\n                if (r) {\n                    if (err === null && m.headers) {\n                        err = isRequestError(m);\n                    }\n                    r.resolver(err, m);\n                }\n            }\n        };\n    }\n    close() {\n        const err = NatsError.errorForCode(ErrorCode.Timeout);\n        this.reqs.forEach((req)=>{\n            req.resolver(err, {});\n        });\n    }\n}\nclass Heartbeat {\n    ph;\n    interval;\n    maxOut;\n    timer;\n    pendings;\n    constructor(ph, interval, maxOut){\n        this.ph = ph;\n        this.interval = interval;\n        this.maxOut = maxOut;\n        this.pendings = [];\n    }\n    start() {\n        this.cancel();\n        this._schedule();\n    }\n    cancel(stale) {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = undefined;\n        }\n        this._reset();\n        if (stale) {\n            this.ph.disconnect();\n        }\n    }\n    _schedule() {\n        this.timer = setTimeout(()=>{\n            this.ph.dispatchStatus({\n                type: DebugEvents.PingTimer,\n                data: `${this.pendings.length + 1}`\n            });\n            if (this.pendings.length === this.maxOut) {\n                this.cancel(true);\n                return;\n            }\n            const ping = deferred();\n            this.ph.flush(ping).then(()=>{\n                this._reset();\n            }).catch(()=>{\n                this.cancel();\n            });\n            this.pendings.push(ping);\n            this._schedule();\n        }, this.interval);\n    }\n    _reset() {\n        this.pendings = this.pendings.filter((p)=>{\n            const d = p;\n            d.resolve();\n            return false;\n        });\n    }\n}\nclass AssertionError extends Error {\n    constructor(msg){\n        super(msg);\n        this.name = \"AssertionError\";\n    }\n}\nfunction assert(cond, msg = \"Assertion failed.\") {\n    if (!cond) {\n        throw new AssertionError(msg);\n    }\n}\nconst MIN_READ = 32 * 1024;\nconst MAX_SIZE = 2 ** 32 - 2;\nfunction copy(src, dst, off = 0) {\n    const r = dst.byteLength - off;\n    if (src.byteLength > r) {\n        src = src.subarray(0, r);\n    }\n    dst.set(src, off);\n    return src.byteLength;\n}\nclass DenoBuffer {\n    _buf;\n    _off;\n    constructor(ab){\n        this._off = 0;\n        if (ab == null) {\n            this._buf = new Uint8Array(0);\n            return;\n        }\n        this._buf = new Uint8Array(ab);\n    }\n    bytes(options = {\n        copy: true\n    }) {\n        if (options.copy === false) return this._buf.subarray(this._off);\n        return this._buf.slice(this._off);\n    }\n    empty() {\n        return this._buf.byteLength <= this._off;\n    }\n    get length() {\n        return this._buf.byteLength - this._off;\n    }\n    get capacity() {\n        return this._buf.buffer.byteLength;\n    }\n    truncate(n) {\n        if (n === 0) {\n            this.reset();\n            return;\n        }\n        if (n < 0 || n > this.length) {\n            throw Error(\"bytes.Buffer: truncation out of range\");\n        }\n        this._reslice(this._off + n);\n    }\n    reset() {\n        this._reslice(0);\n        this._off = 0;\n    }\n    _tryGrowByReslice(n) {\n        const l = this._buf.byteLength;\n        if (n <= this.capacity - l) {\n            this._reslice(l + n);\n            return l;\n        }\n        return -1;\n    }\n    _reslice(len) {\n        assert(len <= this._buf.buffer.byteLength);\n        this._buf = new Uint8Array(this._buf.buffer, 0, len);\n    }\n    readByte() {\n        const a = new Uint8Array(1);\n        if (this.read(a)) {\n            return a[0];\n        }\n        return null;\n    }\n    read(p) {\n        if (this.empty()) {\n            this.reset();\n            if (p.byteLength === 0) {\n                return 0;\n            }\n            return null;\n        }\n        const nread = copy(this._buf.subarray(this._off), p);\n        this._off += nread;\n        return nread;\n    }\n    writeByte(n) {\n        return this.write(Uint8Array.of(n));\n    }\n    writeString(s) {\n        return this.write(TE.encode(s));\n    }\n    write(p) {\n        const m = this._grow(p.byteLength);\n        return copy(p, this._buf, m);\n    }\n    _grow(n) {\n        const m = this.length;\n        if (m === 0 && this._off !== 0) {\n            this.reset();\n        }\n        const i = this._tryGrowByReslice(n);\n        if (i >= 0) {\n            return i;\n        }\n        const c = this.capacity;\n        if (n <= Math.floor(c / 2) - m) {\n            copy(this._buf.subarray(this._off), this._buf);\n        } else if (c + n > MAX_SIZE) {\n            throw new Error(\"The buffer cannot be grown beyond the maximum size.\");\n        } else {\n            const buf = new Uint8Array(Math.min(2 * c + n, MAX_SIZE));\n            copy(this._buf.subarray(this._off), buf);\n            this._buf = buf;\n        }\n        this._off = 0;\n        this._reslice(Math.min(m + n, MAX_SIZE));\n        return m;\n    }\n    grow(n) {\n        if (n < 0) {\n            throw Error(\"Buffer._grow: negative count\");\n        }\n        const m = this._grow(n);\n        this._reslice(m);\n    }\n    readFrom(r) {\n        let n = 0;\n        const tmp = new Uint8Array(MIN_READ);\n        while(true){\n            const shouldGrow = this.capacity - this.length < MIN_READ;\n            const buf = shouldGrow ? tmp : new Uint8Array(this._buf.buffer, this.length);\n            const nread = r.read(buf);\n            if (nread === null) {\n                return n;\n            }\n            if (shouldGrow) this.write(buf.subarray(0, nread));\n            else this._reslice(this.length + nread);\n            n += nread;\n        }\n    }\n}\nvar Kind;\n(function(Kind) {\n    Kind[Kind[\"OK\"] = 0] = \"OK\";\n    Kind[Kind[\"ERR\"] = 1] = \"ERR\";\n    Kind[Kind[\"MSG\"] = 2] = \"MSG\";\n    Kind[Kind[\"INFO\"] = 3] = \"INFO\";\n    Kind[Kind[\"PING\"] = 4] = \"PING\";\n    Kind[Kind[\"PONG\"] = 5] = \"PONG\";\n})(Kind || (Kind = {}));\nfunction newMsgArg() {\n    const ma = {};\n    ma.sid = -1;\n    ma.hdr = -1;\n    ma.size = -1;\n    return ma;\n}\nconst ASCII_0 = 48;\nclass Parser {\n    dispatcher;\n    state;\n    as;\n    drop;\n    hdr;\n    ma;\n    argBuf;\n    msgBuf;\n    constructor(dispatcher){\n        this.dispatcher = dispatcher;\n        this.state = State.OP_START;\n        this.as = 0;\n        this.drop = 0;\n        this.hdr = 0;\n    }\n    parse(buf) {\n        let i;\n        for(i = 0; i < buf.length; i++){\n            const b = buf[i];\n            switch(this.state){\n                case State.OP_START:\n                    switch(b){\n                        case cc.M:\n                        case cc.m:\n                            this.state = State.OP_M;\n                            this.hdr = -1;\n                            this.ma = newMsgArg();\n                            break;\n                        case cc.H:\n                        case cc.h:\n                            this.state = State.OP_H;\n                            this.hdr = 0;\n                            this.ma = newMsgArg();\n                            break;\n                        case cc.P:\n                        case cc.p:\n                            this.state = State.OP_P;\n                            break;\n                        case cc.PLUS:\n                            this.state = State.OP_PLUS;\n                            break;\n                        case cc.MINUS:\n                            this.state = State.OP_MINUS;\n                            break;\n                        case cc.I:\n                        case cc.i:\n                            this.state = State.OP_I;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_H:\n                    switch(b){\n                        case cc.M:\n                        case cc.m:\n                            this.state = State.OP_M;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_M:\n                    switch(b){\n                        case cc.S:\n                        case cc.s:\n                            this.state = State.OP_MS;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MS:\n                    switch(b){\n                        case cc.G:\n                        case cc.g:\n                            this.state = State.OP_MSG;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MSG:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            this.state = State.OP_MSG_SPC;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MSG_SPC:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            continue;\n                        default:\n                            this.state = State.MSG_ARG;\n                            this.as = i;\n                    }\n                    break;\n                case State.MSG_ARG:\n                    switch(b){\n                        case cc.CR:\n                            this.drop = 1;\n                            break;\n                        case cc.NL:\n                            {\n                                const arg = this.argBuf ? this.argBuf.bytes() : buf.subarray(this.as, i - this.drop);\n                                this.processMsgArgs(arg);\n                                this.drop = 0;\n                                this.as = i + 1;\n                                this.state = State.MSG_PAYLOAD;\n                                i = this.as + this.ma.size - 1;\n                                break;\n                            }\n                        default:\n                            if (this.argBuf) {\n                                this.argBuf.writeByte(b);\n                            }\n                    }\n                    break;\n                case State.MSG_PAYLOAD:\n                    if (this.msgBuf) {\n                        if (this.msgBuf.length >= this.ma.size) {\n                            const data = this.msgBuf.bytes({\n                                copy: false\n                            });\n                            this.dispatcher.push({\n                                kind: Kind.MSG,\n                                msg: this.ma,\n                                data: data\n                            });\n                            this.argBuf = undefined;\n                            this.msgBuf = undefined;\n                            this.state = State.MSG_END;\n                        } else {\n                            let toCopy = this.ma.size - this.msgBuf.length;\n                            const avail = buf.length - i;\n                            if (avail < toCopy) {\n                                toCopy = avail;\n                            }\n                            if (toCopy > 0) {\n                                this.msgBuf.write(buf.subarray(i, i + toCopy));\n                                i = i + toCopy - 1;\n                            } else {\n                                this.msgBuf.writeByte(b);\n                            }\n                        }\n                    } else if (i - this.as >= this.ma.size) {\n                        this.dispatcher.push({\n                            kind: Kind.MSG,\n                            msg: this.ma,\n                            data: buf.subarray(this.as, i)\n                        });\n                        this.argBuf = undefined;\n                        this.msgBuf = undefined;\n                        this.state = State.MSG_END;\n                    }\n                    break;\n                case State.MSG_END:\n                    switch(b){\n                        case cc.NL:\n                            this.drop = 0;\n                            this.as = i + 1;\n                            this.state = State.OP_START;\n                            break;\n                        default:\n                            continue;\n                    }\n                    break;\n                case State.OP_PLUS:\n                    switch(b){\n                        case cc.O:\n                        case cc.o:\n                            this.state = State.OP_PLUS_O;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PLUS_O:\n                    switch(b){\n                        case cc.K:\n                        case cc.k:\n                            this.state = State.OP_PLUS_OK;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PLUS_OK:\n                    switch(b){\n                        case cc.NL:\n                            this.dispatcher.push({\n                                kind: Kind.OK\n                            });\n                            this.drop = 0;\n                            this.state = State.OP_START;\n                            break;\n                    }\n                    break;\n                case State.OP_MINUS:\n                    switch(b){\n                        case cc.E:\n                        case cc.e:\n                            this.state = State.OP_MINUS_E;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MINUS_E:\n                    switch(b){\n                        case cc.R:\n                        case cc.r:\n                            this.state = State.OP_MINUS_ER;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MINUS_ER:\n                    switch(b){\n                        case cc.R:\n                        case cc.r:\n                            this.state = State.OP_MINUS_ERR;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MINUS_ERR:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            this.state = State.OP_MINUS_ERR_SPC;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MINUS_ERR_SPC:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            continue;\n                        default:\n                            this.state = State.MINUS_ERR_ARG;\n                            this.as = i;\n                    }\n                    break;\n                case State.MINUS_ERR_ARG:\n                    switch(b){\n                        case cc.CR:\n                            this.drop = 1;\n                            break;\n                        case cc.NL:\n                            {\n                                let arg;\n                                if (this.argBuf) {\n                                    arg = this.argBuf.bytes();\n                                    this.argBuf = undefined;\n                                } else {\n                                    arg = buf.subarray(this.as, i - this.drop);\n                                }\n                                this.dispatcher.push({\n                                    kind: Kind.ERR,\n                                    data: arg\n                                });\n                                this.drop = 0;\n                                this.as = i + 1;\n                                this.state = State.OP_START;\n                                break;\n                            }\n                        default:\n                            if (this.argBuf) {\n                                this.argBuf.write(Uint8Array.of(b));\n                            }\n                    }\n                    break;\n                case State.OP_P:\n                    switch(b){\n                        case cc.I:\n                        case cc.i:\n                            this.state = State.OP_PI;\n                            break;\n                        case cc.O:\n                        case cc.o:\n                            this.state = State.OP_PO;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PO:\n                    switch(b){\n                        case cc.N:\n                        case cc.n:\n                            this.state = State.OP_PON;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PON:\n                    switch(b){\n                        case cc.G:\n                        case cc.g:\n                            this.state = State.OP_PONG;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PONG:\n                    switch(b){\n                        case cc.NL:\n                            this.dispatcher.push({\n                                kind: Kind.PONG\n                            });\n                            this.drop = 0;\n                            this.state = State.OP_START;\n                            break;\n                    }\n                    break;\n                case State.OP_PI:\n                    switch(b){\n                        case cc.N:\n                        case cc.n:\n                            this.state = State.OP_PIN;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PIN:\n                    switch(b){\n                        case cc.G:\n                        case cc.g:\n                            this.state = State.OP_PING;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PING:\n                    switch(b){\n                        case cc.NL:\n                            this.dispatcher.push({\n                                kind: Kind.PING\n                            });\n                            this.drop = 0;\n                            this.state = State.OP_START;\n                            break;\n                    }\n                    break;\n                case State.OP_I:\n                    switch(b){\n                        case cc.N:\n                        case cc.n:\n                            this.state = State.OP_IN;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_IN:\n                    switch(b){\n                        case cc.F:\n                        case cc.f:\n                            this.state = State.OP_INF;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_INF:\n                    switch(b){\n                        case cc.O:\n                        case cc.o:\n                            this.state = State.OP_INFO;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_INFO:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            this.state = State.OP_INFO_SPC;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_INFO_SPC:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            continue;\n                        default:\n                            this.state = State.INFO_ARG;\n                            this.as = i;\n                    }\n                    break;\n                case State.INFO_ARG:\n                    switch(b){\n                        case cc.CR:\n                            this.drop = 1;\n                            break;\n                        case cc.NL:\n                            {\n                                let arg;\n                                if (this.argBuf) {\n                                    arg = this.argBuf.bytes();\n                                    this.argBuf = undefined;\n                                } else {\n                                    arg = buf.subarray(this.as, i - this.drop);\n                                }\n                                this.dispatcher.push({\n                                    kind: Kind.INFO,\n                                    data: arg\n                                });\n                                this.drop = 0;\n                                this.as = i + 1;\n                                this.state = State.OP_START;\n                                break;\n                            }\n                        default:\n                            if (this.argBuf) {\n                                this.argBuf.writeByte(b);\n                            }\n                    }\n                    break;\n                default:\n                    throw this.fail(buf.subarray(i));\n            }\n        }\n        if ((this.state === State.MSG_ARG || this.state === State.MINUS_ERR_ARG || this.state === State.INFO_ARG) && !this.argBuf) {\n            this.argBuf = new DenoBuffer(buf.subarray(this.as, i - this.drop));\n        }\n        if (this.state === State.MSG_PAYLOAD && !this.msgBuf) {\n            if (!this.argBuf) {\n                this.cloneMsgArg();\n            }\n            this.msgBuf = new DenoBuffer(buf.subarray(this.as));\n        }\n    }\n    cloneMsgArg() {\n        const s = this.ma.subject.length;\n        const r = this.ma.reply ? this.ma.reply.length : 0;\n        const buf = new Uint8Array(s + r);\n        buf.set(this.ma.subject);\n        if (this.ma.reply) {\n            buf.set(this.ma.reply, s);\n        }\n        this.argBuf = new DenoBuffer(buf);\n        this.ma.subject = buf.subarray(0, s);\n        if (this.ma.reply) {\n            this.ma.reply = buf.subarray(s);\n        }\n    }\n    processMsgArgs(arg) {\n        if (this.hdr >= 0) {\n            return this.processHeaderMsgArgs(arg);\n        }\n        const args = [];\n        let start = -1;\n        for(let i = 0; i < arg.length; i++){\n            const b = arg[i];\n            switch(b){\n                case cc.SPACE:\n                case cc.TAB:\n                case cc.CR:\n                case cc.NL:\n                    if (start >= 0) {\n                        args.push(arg.subarray(start, i));\n                        start = -1;\n                    }\n                    break;\n                default:\n                    if (start < 0) {\n                        start = i;\n                    }\n            }\n        }\n        if (start >= 0) {\n            args.push(arg.subarray(start));\n        }\n        switch(args.length){\n            case 3:\n                this.ma.subject = args[0];\n                this.ma.sid = this.protoParseInt(args[1]);\n                this.ma.reply = undefined;\n                this.ma.size = this.protoParseInt(args[2]);\n                break;\n            case 4:\n                this.ma.subject = args[0];\n                this.ma.sid = this.protoParseInt(args[1]);\n                this.ma.reply = args[2];\n                this.ma.size = this.protoParseInt(args[3]);\n                break;\n            default:\n                throw this.fail(arg, \"processMsgArgs Parse Error\");\n        }\n        if (this.ma.sid < 0) {\n            throw this.fail(arg, \"processMsgArgs Bad or Missing Sid Error\");\n        }\n        if (this.ma.size < 0) {\n            throw this.fail(arg, \"processMsgArgs Bad or Missing Size Error\");\n        }\n    }\n    fail(data, label = \"\") {\n        if (!label) {\n            label = `parse error [${this.state}]`;\n        } else {\n            label = `${label} [${this.state}]`;\n        }\n        return new Error(`${label}: ${TD.decode(data)}`);\n    }\n    processHeaderMsgArgs(arg) {\n        const args = [];\n        let start = -1;\n        for(let i = 0; i < arg.length; i++){\n            const b = arg[i];\n            switch(b){\n                case cc.SPACE:\n                case cc.TAB:\n                case cc.CR:\n                case cc.NL:\n                    if (start >= 0) {\n                        args.push(arg.subarray(start, i));\n                        start = -1;\n                    }\n                    break;\n                default:\n                    if (start < 0) {\n                        start = i;\n                    }\n            }\n        }\n        if (start >= 0) {\n            args.push(arg.subarray(start));\n        }\n        switch(args.length){\n            case 4:\n                this.ma.subject = args[0];\n                this.ma.sid = this.protoParseInt(args[1]);\n                this.ma.reply = undefined;\n                this.ma.hdr = this.protoParseInt(args[2]);\n                this.ma.size = this.protoParseInt(args[3]);\n                break;\n            case 5:\n                this.ma.subject = args[0];\n                this.ma.sid = this.protoParseInt(args[1]);\n                this.ma.reply = args[2];\n                this.ma.hdr = this.protoParseInt(args[3]);\n                this.ma.size = this.protoParseInt(args[4]);\n                break;\n            default:\n                throw this.fail(arg, \"processHeaderMsgArgs Parse Error\");\n        }\n        if (this.ma.sid < 0) {\n            throw this.fail(arg, \"processHeaderMsgArgs Bad or Missing Sid Error\");\n        }\n        if (this.ma.hdr < 0 || this.ma.hdr > this.ma.size) {\n            throw this.fail(arg, \"processHeaderMsgArgs Bad or Missing Header Size Error\");\n        }\n        if (this.ma.size < 0) {\n            throw this.fail(arg, \"processHeaderMsgArgs Bad or Missing Size Error\");\n        }\n    }\n    protoParseInt(a) {\n        if (a.length === 0) {\n            return -1;\n        }\n        let n = 0;\n        for(let i = 0; i < a.length; i++){\n            if (a[i] < 48 || a[i] > 57) {\n                return -1;\n            }\n            n = n * 10 + (a[i] - ASCII_0);\n        }\n        return n;\n    }\n}\nvar State;\n(function(State) {\n    State[State[\"OP_START\"] = 0] = \"OP_START\";\n    State[State[\"OP_PLUS\"] = 1] = \"OP_PLUS\";\n    State[State[\"OP_PLUS_O\"] = 2] = \"OP_PLUS_O\";\n    State[State[\"OP_PLUS_OK\"] = 3] = \"OP_PLUS_OK\";\n    State[State[\"OP_MINUS\"] = 4] = \"OP_MINUS\";\n    State[State[\"OP_MINUS_E\"] = 5] = \"OP_MINUS_E\";\n    State[State[\"OP_MINUS_ER\"] = 6] = \"OP_MINUS_ER\";\n    State[State[\"OP_MINUS_ERR\"] = 7] = \"OP_MINUS_ERR\";\n    State[State[\"OP_MINUS_ERR_SPC\"] = 8] = \"OP_MINUS_ERR_SPC\";\n    State[State[\"MINUS_ERR_ARG\"] = 9] = \"MINUS_ERR_ARG\";\n    State[State[\"OP_M\"] = 10] = \"OP_M\";\n    State[State[\"OP_MS\"] = 11] = \"OP_MS\";\n    State[State[\"OP_MSG\"] = 12] = \"OP_MSG\";\n    State[State[\"OP_MSG_SPC\"] = 13] = \"OP_MSG_SPC\";\n    State[State[\"MSG_ARG\"] = 14] = \"MSG_ARG\";\n    State[State[\"MSG_PAYLOAD\"] = 15] = \"MSG_PAYLOAD\";\n    State[State[\"MSG_END\"] = 16] = \"MSG_END\";\n    State[State[\"OP_H\"] = 17] = \"OP_H\";\n    State[State[\"OP_P\"] = 18] = \"OP_P\";\n    State[State[\"OP_PI\"] = 19] = \"OP_PI\";\n    State[State[\"OP_PIN\"] = 20] = \"OP_PIN\";\n    State[State[\"OP_PING\"] = 21] = \"OP_PING\";\n    State[State[\"OP_PO\"] = 22] = \"OP_PO\";\n    State[State[\"OP_PON\"] = 23] = \"OP_PON\";\n    State[State[\"OP_PONG\"] = 24] = \"OP_PONG\";\n    State[State[\"OP_I\"] = 25] = \"OP_I\";\n    State[State[\"OP_IN\"] = 26] = \"OP_IN\";\n    State[State[\"OP_INF\"] = 27] = \"OP_INF\";\n    State[State[\"OP_INFO\"] = 28] = \"OP_INFO\";\n    State[State[\"OP_INFO_SPC\"] = 29] = \"OP_INFO_SPC\";\n    State[State[\"INFO_ARG\"] = 30] = \"INFO_ARG\";\n})(State || (State = {}));\nvar cc;\n(function(cc) {\n    cc[cc[\"CR\"] = \"\\r\".charCodeAt(0)] = \"CR\";\n    cc[cc[\"E\"] = \"E\".charCodeAt(0)] = \"E\";\n    cc[cc[\"e\"] = \"e\".charCodeAt(0)] = \"e\";\n    cc[cc[\"F\"] = \"F\".charCodeAt(0)] = \"F\";\n    cc[cc[\"f\"] = \"f\".charCodeAt(0)] = \"f\";\n    cc[cc[\"G\"] = \"G\".charCodeAt(0)] = \"G\";\n    cc[cc[\"g\"] = \"g\".charCodeAt(0)] = \"g\";\n    cc[cc[\"H\"] = \"H\".charCodeAt(0)] = \"H\";\n    cc[cc[\"h\"] = \"h\".charCodeAt(0)] = \"h\";\n    cc[cc[\"I\"] = \"I\".charCodeAt(0)] = \"I\";\n    cc[cc[\"i\"] = \"i\".charCodeAt(0)] = \"i\";\n    cc[cc[\"K\"] = \"K\".charCodeAt(0)] = \"K\";\n    cc[cc[\"k\"] = \"k\".charCodeAt(0)] = \"k\";\n    cc[cc[\"M\"] = \"M\".charCodeAt(0)] = \"M\";\n    cc[cc[\"m\"] = \"m\".charCodeAt(0)] = \"m\";\n    cc[cc[\"MINUS\"] = \"-\".charCodeAt(0)] = \"MINUS\";\n    cc[cc[\"N\"] = \"N\".charCodeAt(0)] = \"N\";\n    cc[cc[\"n\"] = \"n\".charCodeAt(0)] = \"n\";\n    cc[cc[\"NL\"] = \"\\n\".charCodeAt(0)] = \"NL\";\n    cc[cc[\"O\"] = \"O\".charCodeAt(0)] = \"O\";\n    cc[cc[\"o\"] = \"o\".charCodeAt(0)] = \"o\";\n    cc[cc[\"P\"] = \"P\".charCodeAt(0)] = \"P\";\n    cc[cc[\"p\"] = \"p\".charCodeAt(0)] = \"p\";\n    cc[cc[\"PLUS\"] = \"+\".charCodeAt(0)] = \"PLUS\";\n    cc[cc[\"R\"] = \"R\".charCodeAt(0)] = \"R\";\n    cc[cc[\"r\"] = \"r\".charCodeAt(0)] = \"r\";\n    cc[cc[\"S\"] = \"S\".charCodeAt(0)] = \"S\";\n    cc[cc[\"s\"] = \"s\".charCodeAt(0)] = \"s\";\n    cc[cc[\"SPACE\"] = \" \".charCodeAt(0)] = \"SPACE\";\n    cc[cc[\"TAB\"] = \"\\t\".charCodeAt(0)] = \"TAB\";\n})(cc || (cc = {}));\n(function(nacl) {\n    'use strict';\n    var u64 = function(h, l) {\n        this.hi = h | 0 >>> 0;\n        this.lo = l | 0 >>> 0;\n    };\n    var gf = function(init) {\n        var i, r = new Float64Array(16);\n        if (init) for(i = 0; i < init.length; i++)r[i] = init[i];\n        return r;\n    };\n    var randombytes = function() {\n        throw new Error('no PRNG');\n    };\n    var _0 = new Uint8Array(16);\n    var _9 = new Uint8Array(32);\n    _9[0] = 9;\n    var gf0 = gf(), gf1 = gf([\n        1\n    ]), _121665 = gf([\n        0xdb41,\n        1\n    ]), D = gf([\n        0x78a3,\n        0x1359,\n        0x4dca,\n        0x75eb,\n        0xd8ab,\n        0x4141,\n        0x0a4d,\n        0x0070,\n        0xe898,\n        0x7779,\n        0x4079,\n        0x8cc7,\n        0xfe73,\n        0x2b6f,\n        0x6cee,\n        0x5203\n    ]), D2 = gf([\n        0xf159,\n        0x26b2,\n        0x9b94,\n        0xebd6,\n        0xb156,\n        0x8283,\n        0x149a,\n        0x00e0,\n        0xd130,\n        0xeef3,\n        0x80f2,\n        0x198e,\n        0xfce7,\n        0x56df,\n        0xd9dc,\n        0x2406\n    ]), X = gf([\n        0xd51a,\n        0x8f25,\n        0x2d60,\n        0xc956,\n        0xa7b2,\n        0x9525,\n        0xc760,\n        0x692c,\n        0xdc5c,\n        0xfdd6,\n        0xe231,\n        0xc0a4,\n        0x53fe,\n        0xcd6e,\n        0x36d3,\n        0x2169\n    ]), Y = gf([\n        0x6658,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666\n    ]), I = gf([\n        0xa0b0,\n        0x4a0e,\n        0x1b27,\n        0xc4ee,\n        0xe478,\n        0xad2f,\n        0x1806,\n        0x2f43,\n        0xd7a7,\n        0x3dfb,\n        0x0099,\n        0x2b4d,\n        0xdf0b,\n        0x4fc1,\n        0x2480,\n        0x2b83\n    ]);\n    function L32(x, c) {\n        return x << c | x >>> 32 - c;\n    }\n    function ld32(x, i) {\n        var u = x[i + 3] & 0xff;\n        u = u << 8 | x[i + 2] & 0xff;\n        u = u << 8 | x[i + 1] & 0xff;\n        return u << 8 | x[i + 0] & 0xff;\n    }\n    function dl64(x, i) {\n        var h = x[i] << 24 | x[i + 1] << 16 | x[i + 2] << 8 | x[i + 3];\n        var l = x[i + 4] << 24 | x[i + 5] << 16 | x[i + 6] << 8 | x[i + 7];\n        return new u64(h, l);\n    }\n    function st32(x, j, u) {\n        var i;\n        for(i = 0; i < 4; i++){\n            x[j + i] = u & 255;\n            u >>>= 8;\n        }\n    }\n    function ts64(x, i, u) {\n        x[i] = u.hi >> 24 & 0xff;\n        x[i + 1] = u.hi >> 16 & 0xff;\n        x[i + 2] = u.hi >> 8 & 0xff;\n        x[i + 3] = u.hi & 0xff;\n        x[i + 4] = u.lo >> 24 & 0xff;\n        x[i + 5] = u.lo >> 16 & 0xff;\n        x[i + 6] = u.lo >> 8 & 0xff;\n        x[i + 7] = u.lo & 0xff;\n    }\n    function vn(x, xi, y, yi, n) {\n        var i, d = 0;\n        for(i = 0; i < n; i++)d |= x[xi + i] ^ y[yi + i];\n        return (1 & d - 1 >>> 8) - 1;\n    }\n    function crypto_verify_16(x, xi, y, yi) {\n        return vn(x, xi, y, yi, 16);\n    }\n    function crypto_verify_32(x, xi, y, yi) {\n        return vn(x, xi, y, yi, 32);\n    }\n    function core(out, inp, k, c, h) {\n        var w = new Uint32Array(16), x = new Uint32Array(16), y = new Uint32Array(16), t = new Uint32Array(4);\n        var i, j, m;\n        for(i = 0; i < 4; i++){\n            x[5 * i] = ld32(c, 4 * i);\n            x[1 + i] = ld32(k, 4 * i);\n            x[6 + i] = ld32(inp, 4 * i);\n            x[11 + i] = ld32(k, 16 + 4 * i);\n        }\n        for(i = 0; i < 16; i++)y[i] = x[i];\n        for(i = 0; i < 20; i++){\n            for(j = 0; j < 4; j++){\n                for(m = 0; m < 4; m++)t[m] = x[(5 * j + 4 * m) % 16];\n                t[1] ^= L32(t[0] + t[3] | 0, 7);\n                t[2] ^= L32(t[1] + t[0] | 0, 9);\n                t[3] ^= L32(t[2] + t[1] | 0, 13);\n                t[0] ^= L32(t[3] + t[2] | 0, 18);\n                for(m = 0; m < 4; m++)w[4 * j + (j + m) % 4] = t[m];\n            }\n            for(m = 0; m < 16; m++)x[m] = w[m];\n        }\n        if (h) {\n            for(i = 0; i < 16; i++)x[i] = x[i] + y[i] | 0;\n            for(i = 0; i < 4; i++){\n                x[5 * i] = x[5 * i] - ld32(c, 4 * i) | 0;\n                x[6 + i] = x[6 + i] - ld32(inp, 4 * i) | 0;\n            }\n            for(i = 0; i < 4; i++){\n                st32(out, 4 * i, x[5 * i]);\n                st32(out, 16 + 4 * i, x[6 + i]);\n            }\n        } else {\n            for(i = 0; i < 16; i++)st32(out, 4 * i, x[i] + y[i] | 0);\n        }\n    }\n    function crypto_core_salsa20(out, inp, k, c) {\n        core(out, inp, k, c, false);\n        return 0;\n    }\n    function crypto_core_hsalsa20(out, inp, k, c) {\n        core(out, inp, k, c, true);\n        return 0;\n    }\n    var sigma = new Uint8Array([\n        101,\n        120,\n        112,\n        97,\n        110,\n        100,\n        32,\n        51,\n        50,\n        45,\n        98,\n        121,\n        116,\n        101,\n        32,\n        107\n    ]);\n    function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {\n        var z = new Uint8Array(16), x = new Uint8Array(64);\n        var u, i;\n        if (!b) return 0;\n        for(i = 0; i < 16; i++)z[i] = 0;\n        for(i = 0; i < 8; i++)z[i] = n[i];\n        while(b >= 64){\n            crypto_core_salsa20(x, z, k, sigma);\n            for(i = 0; i < 64; i++)c[cpos + i] = (m ? m[mpos + i] : 0) ^ x[i];\n            u = 1;\n            for(i = 8; i < 16; i++){\n                u = u + (z[i] & 0xff) | 0;\n                z[i] = u & 0xff;\n                u >>>= 8;\n            }\n            b -= 64;\n            cpos += 64;\n            if (m) mpos += 64;\n        }\n        if (b > 0) {\n            crypto_core_salsa20(x, z, k, sigma);\n            for(i = 0; i < b; i++)c[cpos + i] = (m ? m[mpos + i] : 0) ^ x[i];\n        }\n        return 0;\n    }\n    function crypto_stream_salsa20(c, cpos, d, n, k) {\n        return crypto_stream_salsa20_xor(c, cpos, null, 0, d, n, k);\n    }\n    function crypto_stream(c, cpos, d, n, k) {\n        var s = new Uint8Array(32);\n        crypto_core_hsalsa20(s, n, k, sigma);\n        return crypto_stream_salsa20(c, cpos, d, n.subarray(16), s);\n    }\n    function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {\n        var s = new Uint8Array(32);\n        crypto_core_hsalsa20(s, n, k, sigma);\n        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, n.subarray(16), s);\n    }\n    function add1305(h, c) {\n        var j, u = 0;\n        for(j = 0; j < 17; j++){\n            u = u + (h[j] + c[j] | 0) | 0;\n            h[j] = u & 255;\n            u >>>= 8;\n        }\n    }\n    var minusp = new Uint32Array([\n        5,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        252\n    ]);\n    function crypto_onetimeauth(out, outpos, m, mpos, n, k) {\n        var s, i, j, u;\n        var x = new Uint32Array(17), r = new Uint32Array(17), h = new Uint32Array(17), c = new Uint32Array(17), g = new Uint32Array(17);\n        for(j = 0; j < 17; j++)r[j] = h[j] = 0;\n        for(j = 0; j < 16; j++)r[j] = k[j];\n        r[3] &= 15;\n        r[4] &= 252;\n        r[7] &= 15;\n        r[8] &= 252;\n        r[11] &= 15;\n        r[12] &= 252;\n        r[15] &= 15;\n        while(n > 0){\n            for(j = 0; j < 17; j++)c[j] = 0;\n            for(j = 0; j < 16 && j < n; ++j)c[j] = m[mpos + j];\n            c[j] = 1;\n            mpos += j;\n            n -= j;\n            add1305(h, c);\n            for(i = 0; i < 17; i++){\n                x[i] = 0;\n                for(j = 0; j < 17; j++)x[i] = x[i] + h[j] * (j <= i ? r[i - j] : 320 * r[i + 17 - j] | 0) | 0 | 0;\n            }\n            for(i = 0; i < 17; i++)h[i] = x[i];\n            u = 0;\n            for(j = 0; j < 16; j++){\n                u = u + h[j] | 0;\n                h[j] = u & 255;\n                u >>>= 8;\n            }\n            u = u + h[16] | 0;\n            h[16] = u & 3;\n            u = 5 * (u >>> 2) | 0;\n            for(j = 0; j < 16; j++){\n                u = u + h[j] | 0;\n                h[j] = u & 255;\n                u >>>= 8;\n            }\n            u = u + h[16] | 0;\n            h[16] = u;\n        }\n        for(j = 0; j < 17; j++)g[j] = h[j];\n        add1305(h, minusp);\n        s = -(h[16] >>> 7) | 0;\n        for(j = 0; j < 17; j++)h[j] ^= s & (g[j] ^ h[j]);\n        for(j = 0; j < 16; j++)c[j] = k[j + 16];\n        c[16] = 0;\n        add1305(h, c);\n        for(j = 0; j < 16; j++)out[outpos + j] = h[j];\n        return 0;\n    }\n    function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {\n        var x = new Uint8Array(16);\n        crypto_onetimeauth(x, 0, m, mpos, n, k);\n        return crypto_verify_16(h, hpos, x, 0);\n    }\n    function crypto_secretbox(c, m, d, n, k) {\n        var i;\n        if (d < 32) return -1;\n        crypto_stream_xor(c, 0, m, 0, d, n, k);\n        crypto_onetimeauth(c, 16, c, 32, d - 32, c);\n        for(i = 0; i < 16; i++)c[i] = 0;\n        return 0;\n    }\n    function crypto_secretbox_open(m, c, d, n, k) {\n        var i;\n        var x = new Uint8Array(32);\n        if (d < 32) return -1;\n        crypto_stream(x, 0, 32, n, k);\n        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;\n        crypto_stream_xor(m, 0, c, 0, d, n, k);\n        for(i = 0; i < 32; i++)m[i] = 0;\n        return 0;\n    }\n    function set25519(r, a) {\n        var i;\n        for(i = 0; i < 16; i++)r[i] = a[i] | 0;\n    }\n    function car25519(o) {\n        var c;\n        var i;\n        for(i = 0; i < 16; i++){\n            o[i] += 65536;\n            c = Math.floor(o[i] / 65536);\n            o[(i + 1) * (i < 15 ? 1 : 0)] += c - 1 + 37 * (c - 1) * (i === 15 ? 1 : 0);\n            o[i] -= c * 65536;\n        }\n    }\n    function sel25519(p, q, b) {\n        var t, c = ~(b - 1);\n        for(var i = 0; i < 16; i++){\n            t = c & (p[i] ^ q[i]);\n            p[i] ^= t;\n            q[i] ^= t;\n        }\n    }\n    function pack25519(o, n) {\n        var i, j, b;\n        var m = gf(), t = gf();\n        for(i = 0; i < 16; i++)t[i] = n[i];\n        car25519(t);\n        car25519(t);\n        car25519(t);\n        for(j = 0; j < 2; j++){\n            m[0] = t[0] - 0xffed;\n            for(i = 1; i < 15; i++){\n                m[i] = t[i] - 0xffff - (m[i - 1] >> 16 & 1);\n                m[i - 1] &= 0xffff;\n            }\n            m[15] = t[15] - 0x7fff - (m[14] >> 16 & 1);\n            b = m[15] >> 16 & 1;\n            m[14] &= 0xffff;\n            sel25519(t, m, 1 - b);\n        }\n        for(i = 0; i < 16; i++){\n            o[2 * i] = t[i] & 0xff;\n            o[2 * i + 1] = t[i] >> 8;\n        }\n    }\n    function neq25519(a, b) {\n        var c = new Uint8Array(32), d = new Uint8Array(32);\n        pack25519(c, a);\n        pack25519(d, b);\n        return crypto_verify_32(c, 0, d, 0);\n    }\n    function par25519(a) {\n        var d = new Uint8Array(32);\n        pack25519(d, a);\n        return d[0] & 1;\n    }\n    function unpack25519(o, n) {\n        var i;\n        for(i = 0; i < 16; i++)o[i] = n[2 * i] + (n[2 * i + 1] << 8);\n        o[15] &= 0x7fff;\n    }\n    function A(o, a, b) {\n        var i;\n        for(i = 0; i < 16; i++)o[i] = a[i] + b[i] | 0;\n    }\n    function Z(o, a, b) {\n        var i;\n        for(i = 0; i < 16; i++)o[i] = a[i] - b[i] | 0;\n    }\n    function M(o, a, b) {\n        var i, j, t = new Float64Array(31);\n        for(i = 0; i < 31; i++)t[i] = 0;\n        for(i = 0; i < 16; i++){\n            for(j = 0; j < 16; j++){\n                t[i + j] += a[i] * b[j];\n            }\n        }\n        for(i = 0; i < 15; i++){\n            t[i] += 38 * t[i + 16];\n        }\n        for(i = 0; i < 16; i++)o[i] = t[i];\n        car25519(o);\n        car25519(o);\n    }\n    function S(o, a) {\n        M(o, a, a);\n    }\n    function inv25519(o, i) {\n        var c = gf();\n        var a;\n        for(a = 0; a < 16; a++)c[a] = i[a];\n        for(a = 253; a >= 0; a--){\n            S(c, c);\n            if (a !== 2 && a !== 4) M(c, c, i);\n        }\n        for(a = 0; a < 16; a++)o[a] = c[a];\n    }\n    function pow2523(o, i) {\n        var c = gf();\n        var a;\n        for(a = 0; a < 16; a++)c[a] = i[a];\n        for(a = 250; a >= 0; a--){\n            S(c, c);\n            if (a !== 1) M(c, c, i);\n        }\n        for(a = 0; a < 16; a++)o[a] = c[a];\n    }\n    function crypto_scalarmult(q, n, p) {\n        var z = new Uint8Array(32);\n        var x = new Float64Array(80), r, i;\n        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();\n        for(i = 0; i < 31; i++)z[i] = n[i];\n        z[31] = n[31] & 127 | 64;\n        z[0] &= 248;\n        unpack25519(x, p);\n        for(i = 0; i < 16; i++){\n            b[i] = x[i];\n            d[i] = a[i] = c[i] = 0;\n        }\n        a[0] = d[0] = 1;\n        for(i = 254; i >= 0; --i){\n            r = z[i >>> 3] >>> (i & 7) & 1;\n            sel25519(a, b, r);\n            sel25519(c, d, r);\n            A(e, a, c);\n            Z(a, a, c);\n            A(c, b, d);\n            Z(b, b, d);\n            S(d, e);\n            S(f, a);\n            M(a, c, a);\n            M(c, b, e);\n            A(e, a, c);\n            Z(a, a, c);\n            S(b, a);\n            Z(c, d, f);\n            M(a, c, _121665);\n            A(a, a, d);\n            M(c, c, a);\n            M(a, d, f);\n            M(d, b, x);\n            S(b, e);\n            sel25519(a, b, r);\n            sel25519(c, d, r);\n        }\n        for(i = 0; i < 16; i++){\n            x[i + 16] = a[i];\n            x[i + 32] = c[i];\n            x[i + 48] = b[i];\n            x[i + 64] = d[i];\n        }\n        var x32 = x.subarray(32);\n        var x16 = x.subarray(16);\n        inv25519(x32, x32);\n        M(x16, x16, x32);\n        pack25519(q, x16);\n        return 0;\n    }\n    function crypto_scalarmult_base(q, n) {\n        return crypto_scalarmult(q, n, _9);\n    }\n    function crypto_box_keypair(y, x) {\n        randombytes(x, 32);\n        return crypto_scalarmult_base(y, x);\n    }\n    function crypto_box_beforenm(k, y, x) {\n        var s = new Uint8Array(32);\n        crypto_scalarmult(s, x, y);\n        return crypto_core_hsalsa20(k, _0, s, sigma);\n    }\n    var crypto_box_afternm = crypto_secretbox;\n    var crypto_box_open_afternm = crypto_secretbox_open;\n    function crypto_box(c, m, d, n, y, x) {\n        var k = new Uint8Array(32);\n        crypto_box_beforenm(k, y, x);\n        return crypto_box_afternm(c, m, d, n, k);\n    }\n    function crypto_box_open(m, c, d, n, y, x) {\n        var k = new Uint8Array(32);\n        crypto_box_beforenm(k, y, x);\n        return crypto_box_open_afternm(m, c, d, n, k);\n    }\n    function add64() {\n        var a = 0, b = 0, c = 0, d = 0, m16 = 65535, l, h, i;\n        for(i = 0; i < arguments.length; i++){\n            l = arguments[i].lo;\n            h = arguments[i].hi;\n            a += l & m16;\n            b += l >>> 16;\n            c += h & m16;\n            d += h >>> 16;\n        }\n        b += a >>> 16;\n        c += b >>> 16;\n        d += c >>> 16;\n        return new u64(c & m16 | d << 16, a & m16 | b << 16);\n    }\n    function shr64(x, c) {\n        return new u64(x.hi >>> c, x.lo >>> c | x.hi << 32 - c);\n    }\n    function xor64() {\n        var l = 0, h = 0, i;\n        for(i = 0; i < arguments.length; i++){\n            l ^= arguments[i].lo;\n            h ^= arguments[i].hi;\n        }\n        return new u64(h, l);\n    }\n    function R(x, c) {\n        var h, l, c1 = 32 - c;\n        if (c < 32) {\n            h = x.hi >>> c | x.lo << c1;\n            l = x.lo >>> c | x.hi << c1;\n        } else if (c < 64) {\n            h = x.lo >>> c | x.hi << c1;\n            l = x.hi >>> c | x.lo << c1;\n        }\n        return new u64(h, l);\n    }\n    function Ch(x, y, z) {\n        var h = x.hi & y.hi ^ ~x.hi & z.hi, l = x.lo & y.lo ^ ~x.lo & z.lo;\n        return new u64(h, l);\n    }\n    function Maj(x, y, z) {\n        var h = x.hi & y.hi ^ x.hi & z.hi ^ y.hi & z.hi, l = x.lo & y.lo ^ x.lo & z.lo ^ y.lo & z.lo;\n        return new u64(h, l);\n    }\n    function Sigma0(x) {\n        return xor64(R(x, 28), R(x, 34), R(x, 39));\n    }\n    function Sigma1(x) {\n        return xor64(R(x, 14), R(x, 18), R(x, 41));\n    }\n    function sigma0(x) {\n        return xor64(R(x, 1), R(x, 8), shr64(x, 7));\n    }\n    function sigma1(x) {\n        return xor64(R(x, 19), R(x, 61), shr64(x, 6));\n    }\n    var K = [\n        new u64(0x428a2f98, 0xd728ae22),\n        new u64(0x71374491, 0x23ef65cd),\n        new u64(0xb5c0fbcf, 0xec4d3b2f),\n        new u64(0xe9b5dba5, 0x8189dbbc),\n        new u64(0x3956c25b, 0xf348b538),\n        new u64(0x59f111f1, 0xb605d019),\n        new u64(0x923f82a4, 0xaf194f9b),\n        new u64(0xab1c5ed5, 0xda6d8118),\n        new u64(0xd807aa98, 0xa3030242),\n        new u64(0x12835b01, 0x45706fbe),\n        new u64(0x243185be, 0x4ee4b28c),\n        new u64(0x550c7dc3, 0xd5ffb4e2),\n        new u64(0x72be5d74, 0xf27b896f),\n        new u64(0x80deb1fe, 0x3b1696b1),\n        new u64(0x9bdc06a7, 0x25c71235),\n        new u64(0xc19bf174, 0xcf692694),\n        new u64(0xe49b69c1, 0x9ef14ad2),\n        new u64(0xefbe4786, 0x384f25e3),\n        new u64(0x0fc19dc6, 0x8b8cd5b5),\n        new u64(0x240ca1cc, 0x77ac9c65),\n        new u64(0x2de92c6f, 0x592b0275),\n        new u64(0x4a7484aa, 0x6ea6e483),\n        new u64(0x5cb0a9dc, 0xbd41fbd4),\n        new u64(0x76f988da, 0x831153b5),\n        new u64(0x983e5152, 0xee66dfab),\n        new u64(0xa831c66d, 0x2db43210),\n        new u64(0xb00327c8, 0x98fb213f),\n        new u64(0xbf597fc7, 0xbeef0ee4),\n        new u64(0xc6e00bf3, 0x3da88fc2),\n        new u64(0xd5a79147, 0x930aa725),\n        new u64(0x06ca6351, 0xe003826f),\n        new u64(0x14292967, 0x0a0e6e70),\n        new u64(0x27b70a85, 0x46d22ffc),\n        new u64(0x2e1b2138, 0x5c26c926),\n        new u64(0x4d2c6dfc, 0x5ac42aed),\n        new u64(0x53380d13, 0x9d95b3df),\n        new u64(0x650a7354, 0x8baf63de),\n        new u64(0x766a0abb, 0x3c77b2a8),\n        new u64(0x81c2c92e, 0x47edaee6),\n        new u64(0x92722c85, 0x1482353b),\n        new u64(0xa2bfe8a1, 0x4cf10364),\n        new u64(0xa81a664b, 0xbc423001),\n        new u64(0xc24b8b70, 0xd0f89791),\n        new u64(0xc76c51a3, 0x0654be30),\n        new u64(0xd192e819, 0xd6ef5218),\n        new u64(0xd6990624, 0x5565a910),\n        new u64(0xf40e3585, 0x5771202a),\n        new u64(0x106aa070, 0x32bbd1b8),\n        new u64(0x19a4c116, 0xb8d2d0c8),\n        new u64(0x1e376c08, 0x5141ab53),\n        new u64(0x2748774c, 0xdf8eeb99),\n        new u64(0x34b0bcb5, 0xe19b48a8),\n        new u64(0x391c0cb3, 0xc5c95a63),\n        new u64(0x4ed8aa4a, 0xe3418acb),\n        new u64(0x5b9cca4f, 0x7763e373),\n        new u64(0x682e6ff3, 0xd6b2b8a3),\n        new u64(0x748f82ee, 0x5defb2fc),\n        new u64(0x78a5636f, 0x43172f60),\n        new u64(0x84c87814, 0xa1f0ab72),\n        new u64(0x8cc70208, 0x1a6439ec),\n        new u64(0x90befffa, 0x23631e28),\n        new u64(0xa4506ceb, 0xde82bde9),\n        new u64(0xbef9a3f7, 0xb2c67915),\n        new u64(0xc67178f2, 0xe372532b),\n        new u64(0xca273ece, 0xea26619c),\n        new u64(0xd186b8c7, 0x21c0c207),\n        new u64(0xeada7dd6, 0xcde0eb1e),\n        new u64(0xf57d4f7f, 0xee6ed178),\n        new u64(0x06f067aa, 0x72176fba),\n        new u64(0x0a637dc5, 0xa2c898a6),\n        new u64(0x113f9804, 0xbef90dae),\n        new u64(0x1b710b35, 0x131c471b),\n        new u64(0x28db77f5, 0x23047d84),\n        new u64(0x32caab7b, 0x40c72493),\n        new u64(0x3c9ebe0a, 0x15c9bebc),\n        new u64(0x431d67c4, 0x9c100d4c),\n        new u64(0x4cc5d4be, 0xcb3e42b6),\n        new u64(0x597f299c, 0xfc657e2a),\n        new u64(0x5fcb6fab, 0x3ad6faec),\n        new u64(0x6c44198c, 0x4a475817)\n    ];\n    function crypto_hashblocks(x, m, n) {\n        var z = [], b = [], a = [], w = [], t, i, j;\n        for(i = 0; i < 8; i++)z[i] = a[i] = dl64(x, 8 * i);\n        var pos = 0;\n        while(n >= 128){\n            for(i = 0; i < 16; i++)w[i] = dl64(m, 8 * i + pos);\n            for(i = 0; i < 80; i++){\n                for(j = 0; j < 8; j++)b[j] = a[j];\n                t = add64(a[7], Sigma1(a[4]), Ch(a[4], a[5], a[6]), K[i], w[i % 16]);\n                b[7] = add64(t, Sigma0(a[0]), Maj(a[0], a[1], a[2]));\n                b[3] = add64(b[3], t);\n                for(j = 0; j < 8; j++)a[(j + 1) % 8] = b[j];\n                if (i % 16 === 15) {\n                    for(j = 0; j < 16; j++){\n                        w[j] = add64(w[j], w[(j + 9) % 16], sigma0(w[(j + 1) % 16]), sigma1(w[(j + 14) % 16]));\n                    }\n                }\n            }\n            for(i = 0; i < 8; i++){\n                a[i] = add64(a[i], z[i]);\n                z[i] = a[i];\n            }\n            pos += 128;\n            n -= 128;\n        }\n        for(i = 0; i < 8; i++)ts64(x, 8 * i, z[i]);\n        return n;\n    }\n    var iv = new Uint8Array([\n        0x6a,\n        0x09,\n        0xe6,\n        0x67,\n        0xf3,\n        0xbc,\n        0xc9,\n        0x08,\n        0xbb,\n        0x67,\n        0xae,\n        0x85,\n        0x84,\n        0xca,\n        0xa7,\n        0x3b,\n        0x3c,\n        0x6e,\n        0xf3,\n        0x72,\n        0xfe,\n        0x94,\n        0xf8,\n        0x2b,\n        0xa5,\n        0x4f,\n        0xf5,\n        0x3a,\n        0x5f,\n        0x1d,\n        0x36,\n        0xf1,\n        0x51,\n        0x0e,\n        0x52,\n        0x7f,\n        0xad,\n        0xe6,\n        0x82,\n        0xd1,\n        0x9b,\n        0x05,\n        0x68,\n        0x8c,\n        0x2b,\n        0x3e,\n        0x6c,\n        0x1f,\n        0x1f,\n        0x83,\n        0xd9,\n        0xab,\n        0xfb,\n        0x41,\n        0xbd,\n        0x6b,\n        0x5b,\n        0xe0,\n        0xcd,\n        0x19,\n        0x13,\n        0x7e,\n        0x21,\n        0x79\n    ]);\n    function crypto_hash(out, m, n) {\n        var h = new Uint8Array(64), x = new Uint8Array(256);\n        var i, b = n;\n        for(i = 0; i < 64; i++)h[i] = iv[i];\n        crypto_hashblocks(h, m, n);\n        n %= 128;\n        for(i = 0; i < 256; i++)x[i] = 0;\n        for(i = 0; i < n; i++)x[i] = m[b - n + i];\n        x[n] = 128;\n        n = 256 - 128 * (n < 112 ? 1 : 0);\n        x[n - 9] = 0;\n        ts64(x, n - 8, new u64(b / 0x20000000 | 0, b << 3));\n        crypto_hashblocks(h, x, n);\n        for(i = 0; i < 64; i++)out[i] = h[i];\n        return 0;\n    }\n    function add(p, q) {\n        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();\n        Z(a, p[1], p[0]);\n        Z(t, q[1], q[0]);\n        M(a, a, t);\n        A(b, p[0], p[1]);\n        A(t, q[0], q[1]);\n        M(b, b, t);\n        M(c, p[3], q[3]);\n        M(c, c, D2);\n        M(d, p[2], q[2]);\n        A(d, d, d);\n        Z(e, b, a);\n        Z(f, d, c);\n        A(g, d, c);\n        A(h, b, a);\n        M(p[0], e, f);\n        M(p[1], h, g);\n        M(p[2], g, f);\n        M(p[3], e, h);\n    }\n    function cswap(p, q, b) {\n        var i;\n        for(i = 0; i < 4; i++){\n            sel25519(p[i], q[i], b);\n        }\n    }\n    function pack(r, p) {\n        var tx = gf(), ty = gf(), zi = gf();\n        inv25519(zi, p[2]);\n        M(tx, p[0], zi);\n        M(ty, p[1], zi);\n        pack25519(r, ty);\n        r[31] ^= par25519(tx) << 7;\n    }\n    function scalarmult(p, q, s) {\n        var b, i;\n        set25519(p[0], gf0);\n        set25519(p[1], gf1);\n        set25519(p[2], gf1);\n        set25519(p[3], gf0);\n        for(i = 255; i >= 0; --i){\n            b = s[i / 8 | 0] >> (i & 7) & 1;\n            cswap(p, q, b);\n            add(q, p);\n            add(p, p);\n            cswap(p, q, b);\n        }\n    }\n    function scalarbase(p, s) {\n        var q = [\n            gf(),\n            gf(),\n            gf(),\n            gf()\n        ];\n        set25519(q[0], X);\n        set25519(q[1], Y);\n        set25519(q[2], gf1);\n        M(q[3], X, Y);\n        scalarmult(p, q, s);\n    }\n    function crypto_sign_keypair(pk, sk, seeded) {\n        var d = new Uint8Array(64);\n        var p = [\n            gf(),\n            gf(),\n            gf(),\n            gf()\n        ];\n        var i;\n        if (!seeded) randombytes(sk, 32);\n        crypto_hash(d, sk, 32);\n        d[0] &= 248;\n        d[31] &= 127;\n        d[31] |= 64;\n        scalarbase(p, d);\n        pack(pk, p);\n        for(i = 0; i < 32; i++)sk[i + 32] = pk[i];\n        return 0;\n    }\n    var L = new Float64Array([\n        0xed,\n        0xd3,\n        0xf5,\n        0x5c,\n        0x1a,\n        0x63,\n        0x12,\n        0x58,\n        0xd6,\n        0x9c,\n        0xf7,\n        0xa2,\n        0xde,\n        0xf9,\n        0xde,\n        0x14,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0x10\n    ]);\n    function modL(r, x) {\n        var carry, i, j, k;\n        for(i = 63; i >= 32; --i){\n            carry = 0;\n            for(j = i - 32, k = i - 12; j < k; ++j){\n                x[j] += carry - 16 * x[i] * L[j - (i - 32)];\n                carry = Math.floor((x[j] + 128) / 256);\n                x[j] -= carry * 256;\n            }\n            x[j] += carry;\n            x[i] = 0;\n        }\n        carry = 0;\n        for(j = 0; j < 32; j++){\n            x[j] += carry - (x[31] >> 4) * L[j];\n            carry = x[j] >> 8;\n            x[j] &= 255;\n        }\n        for(j = 0; j < 32; j++)x[j] -= carry * L[j];\n        for(i = 0; i < 32; i++){\n            x[i + 1] += x[i] >> 8;\n            r[i] = x[i] & 255;\n        }\n    }\n    function reduce(r) {\n        var x = new Float64Array(64), i;\n        for(i = 0; i < 64; i++)x[i] = r[i];\n        for(i = 0; i < 64; i++)r[i] = 0;\n        modL(r, x);\n    }\n    function crypto_sign(sm, m, n, sk) {\n        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);\n        var i, j, x = new Float64Array(64);\n        var p = [\n            gf(),\n            gf(),\n            gf(),\n            gf()\n        ];\n        crypto_hash(d, sk, 32);\n        d[0] &= 248;\n        d[31] &= 127;\n        d[31] |= 64;\n        var smlen = n + 64;\n        for(i = 0; i < n; i++)sm[64 + i] = m[i];\n        for(i = 0; i < 32; i++)sm[32 + i] = d[32 + i];\n        crypto_hash(r, sm.subarray(32), n + 32);\n        reduce(r);\n        scalarbase(p, r);\n        pack(sm, p);\n        for(i = 32; i < 64; i++)sm[i] = sk[i];\n        crypto_hash(h, sm, n + 64);\n        reduce(h);\n        for(i = 0; i < 64; i++)x[i] = 0;\n        for(i = 0; i < 32; i++)x[i] = r[i];\n        for(i = 0; i < 32; i++){\n            for(j = 0; j < 32; j++){\n                x[i + j] += h[i] * d[j];\n            }\n        }\n        modL(sm.subarray(32), x);\n        return smlen;\n    }\n    function unpackneg(r, p) {\n        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();\n        set25519(r[2], gf1);\n        unpack25519(r[1], p);\n        S(num, r[1]);\n        M(den, num, D);\n        Z(num, num, r[2]);\n        A(den, r[2], den);\n        S(den2, den);\n        S(den4, den2);\n        M(den6, den4, den2);\n        M(t, den6, num);\n        M(t, t, den);\n        pow2523(t, t);\n        M(t, t, num);\n        M(t, t, den);\n        M(t, t, den);\n        M(r[0], t, den);\n        S(chk, r[0]);\n        M(chk, chk, den);\n        if (neq25519(chk, num)) M(r[0], r[0], I);\n        S(chk, r[0]);\n        M(chk, chk, den);\n        if (neq25519(chk, num)) return -1;\n        if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);\n        M(r[3], r[0], r[1]);\n        return 0;\n    }\n    function crypto_sign_open(m, sm, n, pk) {\n        var i;\n        var t = new Uint8Array(32), h = new Uint8Array(64);\n        var p = [\n            gf(),\n            gf(),\n            gf(),\n            gf()\n        ], q = [\n            gf(),\n            gf(),\n            gf(),\n            gf()\n        ];\n        if (n < 64) return -1;\n        if (unpackneg(q, pk)) return -1;\n        for(i = 0; i < n; i++)m[i] = sm[i];\n        for(i = 0; i < 32; i++)m[i + 32] = pk[i];\n        crypto_hash(h, m, n);\n        reduce(h);\n        scalarmult(p, q, h);\n        scalarbase(q, sm.subarray(32));\n        add(p, q);\n        pack(t, p);\n        n -= 64;\n        if (crypto_verify_32(sm, 0, t, 0)) {\n            for(i = 0; i < n; i++)m[i] = 0;\n            return -1;\n        }\n        for(i = 0; i < n; i++)m[i] = sm[i + 64];\n        return n;\n    }\n    var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;\n    nacl.lowlevel = {\n        crypto_core_hsalsa20: crypto_core_hsalsa20,\n        crypto_stream_xor: crypto_stream_xor,\n        crypto_stream: crypto_stream,\n        crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,\n        crypto_stream_salsa20: crypto_stream_salsa20,\n        crypto_onetimeauth: crypto_onetimeauth,\n        crypto_onetimeauth_verify: crypto_onetimeauth_verify,\n        crypto_verify_16: crypto_verify_16,\n        crypto_verify_32: crypto_verify_32,\n        crypto_secretbox: crypto_secretbox,\n        crypto_secretbox_open: crypto_secretbox_open,\n        crypto_scalarmult: crypto_scalarmult,\n        crypto_scalarmult_base: crypto_scalarmult_base,\n        crypto_box_beforenm: crypto_box_beforenm,\n        crypto_box_afternm: crypto_box_afternm,\n        crypto_box: crypto_box,\n        crypto_box_open: crypto_box_open,\n        crypto_box_keypair: crypto_box_keypair,\n        crypto_hash: crypto_hash,\n        crypto_sign: crypto_sign,\n        crypto_sign_keypair: crypto_sign_keypair,\n        crypto_sign_open: crypto_sign_open,\n        crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,\n        crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,\n        crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,\n        crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,\n        crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,\n        crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,\n        crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,\n        crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,\n        crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,\n        crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,\n        crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,\n        crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,\n        crypto_sign_BYTES: crypto_sign_BYTES,\n        crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,\n        crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,\n        crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,\n        crypto_hash_BYTES: crypto_hash_BYTES,\n        gf: gf,\n        D: D,\n        L: L,\n        pack25519: pack25519,\n        unpack25519: unpack25519,\n        M: M,\n        A: A,\n        S: S,\n        Z: Z,\n        pow2523: pow2523,\n        add: add,\n        set25519: set25519,\n        modL: modL,\n        scalarmult: scalarmult,\n        scalarbase: scalarbase\n    };\n    function checkLengths(k, n) {\n        if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');\n        if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');\n    }\n    function checkBoxLengths(pk, sk) {\n        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');\n        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');\n    }\n    function checkArrayTypes() {\n        for(var i = 0; i < arguments.length; i++){\n            if (!(arguments[i] instanceof Uint8Array)) throw new TypeError('unexpected type, use Uint8Array');\n        }\n    }\n    function cleanup(arr) {\n        for(var i = 0; i < arr.length; i++)arr[i] = 0;\n    }\n    nacl.randomBytes = function(n) {\n        var b = new Uint8Array(n);\n        randombytes(b, n);\n        return b;\n    };\n    nacl.secretbox = function(msg, nonce, key) {\n        checkArrayTypes(msg, nonce, key);\n        checkLengths(key, nonce);\n        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);\n        var c = new Uint8Array(m.length);\n        for(var i = 0; i < msg.length; i++)m[i + crypto_secretbox_ZEROBYTES] = msg[i];\n        crypto_secretbox(c, m, m.length, nonce, key);\n        return c.subarray(crypto_secretbox_BOXZEROBYTES);\n    };\n    nacl.secretbox.open = function(box, nonce, key) {\n        checkArrayTypes(box, nonce, key);\n        checkLengths(key, nonce);\n        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);\n        var m = new Uint8Array(c.length);\n        for(var i = 0; i < box.length; i++)c[i + crypto_secretbox_BOXZEROBYTES] = box[i];\n        if (c.length < 32) return null;\n        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;\n        return m.subarray(crypto_secretbox_ZEROBYTES);\n    };\n    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;\n    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;\n    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;\n    nacl.scalarMult = function(n, p) {\n        checkArrayTypes(n, p);\n        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n        if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');\n        var q = new Uint8Array(crypto_scalarmult_BYTES);\n        crypto_scalarmult(q, n, p);\n        return q;\n    };\n    nacl.scalarMult.base = function(n) {\n        checkArrayTypes(n);\n        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n        var q = new Uint8Array(crypto_scalarmult_BYTES);\n        crypto_scalarmult_base(q, n);\n        return q;\n    };\n    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;\n    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;\n    nacl.box = function(msg, nonce, publicKey, secretKey) {\n        var k = nacl.box.before(publicKey, secretKey);\n        return nacl.secretbox(msg, nonce, k);\n    };\n    nacl.box.before = function(publicKey, secretKey) {\n        checkArrayTypes(publicKey, secretKey);\n        checkBoxLengths(publicKey, secretKey);\n        var k = new Uint8Array(crypto_box_BEFORENMBYTES);\n        crypto_box_beforenm(k, publicKey, secretKey);\n        return k;\n    };\n    nacl.box.after = nacl.secretbox;\n    nacl.box.open = function(msg, nonce, publicKey, secretKey) {\n        var k = nacl.box.before(publicKey, secretKey);\n        return nacl.secretbox.open(msg, nonce, k);\n    };\n    nacl.box.open.after = nacl.secretbox.open;\n    nacl.box.keyPair = function() {\n        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);\n        crypto_box_keypair(pk, sk);\n        return {\n            publicKey: pk,\n            secretKey: sk\n        };\n    };\n    nacl.box.keyPair.fromSecretKey = function(secretKey) {\n        checkArrayTypes(secretKey);\n        if (secretKey.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');\n        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n        crypto_scalarmult_base(pk, secretKey);\n        return {\n            publicKey: pk,\n            secretKey: new Uint8Array(secretKey)\n        };\n    };\n    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;\n    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;\n    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;\n    nacl.box.nonceLength = crypto_box_NONCEBYTES;\n    nacl.box.overheadLength = nacl.secretbox.overheadLength;\n    nacl.sign = function(msg, secretKey) {\n        checkArrayTypes(msg, secretKey);\n        if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error('bad secret key size');\n        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);\n        crypto_sign(signedMsg, msg, msg.length, secretKey);\n        return signedMsg;\n    };\n    nacl.sign.open = function(signedMsg, publicKey) {\n        checkArrayTypes(signedMsg, publicKey);\n        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error('bad public key size');\n        var tmp = new Uint8Array(signedMsg.length);\n        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);\n        if (mlen < 0) return null;\n        var m = new Uint8Array(mlen);\n        for(var i = 0; i < m.length; i++)m[i] = tmp[i];\n        return m;\n    };\n    nacl.sign.detached = function(msg, secretKey) {\n        var signedMsg = nacl.sign(msg, secretKey);\n        var sig = new Uint8Array(crypto_sign_BYTES);\n        for(var i = 0; i < sig.length; i++)sig[i] = signedMsg[i];\n        return sig;\n    };\n    nacl.sign.detached.verify = function(msg, sig, publicKey) {\n        checkArrayTypes(msg, sig, publicKey);\n        if (sig.length !== crypto_sign_BYTES) throw new Error('bad signature size');\n        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error('bad public key size');\n        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);\n        var m = new Uint8Array(crypto_sign_BYTES + msg.length);\n        var i;\n        for(i = 0; i < crypto_sign_BYTES; i++)sm[i] = sig[i];\n        for(i = 0; i < msg.length; i++)sm[i + crypto_sign_BYTES] = msg[i];\n        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;\n    };\n    nacl.sign.keyPair = function() {\n        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n        crypto_sign_keypair(pk, sk);\n        return {\n            publicKey: pk,\n            secretKey: sk\n        };\n    };\n    nacl.sign.keyPair.fromSecretKey = function(secretKey) {\n        checkArrayTypes(secretKey);\n        if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error('bad secret key size');\n        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n        for(var i = 0; i < pk.length; i++)pk[i] = secretKey[32 + i];\n        return {\n            publicKey: pk,\n            secretKey: new Uint8Array(secretKey)\n        };\n    };\n    nacl.sign.keyPair.fromSeed = function(seed) {\n        checkArrayTypes(seed);\n        if (seed.length !== crypto_sign_SEEDBYTES) throw new Error('bad seed size');\n        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n        for(var i = 0; i < 32; i++)sk[i] = seed[i];\n        crypto_sign_keypair(pk, sk, true);\n        return {\n            publicKey: pk,\n            secretKey: sk\n        };\n    };\n    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;\n    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;\n    nacl.sign.seedLength = crypto_sign_SEEDBYTES;\n    nacl.sign.signatureLength = crypto_sign_BYTES;\n    nacl.hash = function(msg) {\n        checkArrayTypes(msg);\n        var h = new Uint8Array(crypto_hash_BYTES);\n        crypto_hash(h, msg, msg.length);\n        return h;\n    };\n    nacl.hash.hashLength = crypto_hash_BYTES;\n    nacl.verify = function(x, y) {\n        checkArrayTypes(x, y);\n        if (x.length === 0 || y.length === 0) return false;\n        if (x.length !== y.length) return false;\n        return vn(x, 0, y, 0, x.length) === 0 ? true : false;\n    };\n    nacl.setPRNG = function(fn) {\n        randombytes = fn;\n    };\n    (function() {\n        var crypto1 = typeof globalThis !== 'undefined' ? globalThis.crypto || globalThis.msCrypto : null;\n        if (crypto1 && crypto1.getRandomValues) {\n            var QUOTA = 65536;\n            nacl.setPRNG(function(x, n) {\n                var i, v = new Uint8Array(n);\n                for(i = 0; i < n; i += QUOTA){\n                    crypto1.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));\n                }\n                for(i = 0; i < n; i++)x[i] = v[i];\n                cleanup(v);\n            });\n        } else if (typeof require !== 'undefined') {\n            crypto1 = require('crypto');\n            if (crypto1 && crypto1.randomBytes) {\n                nacl.setPRNG(function(x, n) {\n                    var i, v = crypto1.randomBytes(n);\n                    for(i = 0; i < n; i++)x[i] = v[i];\n                    cleanup(v);\n                });\n            }\n        }\n    })();\n})(typeof module !== 'undefined' && module.exports ? module.exports : globalThis.nacl = globalThis.nacl || {});\nconst nacl = typeof module !== 'undefined' && module.exports ? module.exports : globalThis.nacl;\nconst denoHelper = {\n    fromSeed: nacl.sign.keyPair.fromSeed,\n    sign: nacl.sign.detached,\n    verify: nacl.sign.detached.verify,\n    randomBytes: nacl.randomBytes\n};\nlet helper;\nfunction setEd25519Helper(lib) {\n    helper = lib;\n}\nfunction getEd25519Helper() {\n    return helper;\n}\nconst crc16tab = new Uint16Array([\n    0x0000,\n    0x1021,\n    0x2042,\n    0x3063,\n    0x4084,\n    0x50a5,\n    0x60c6,\n    0x70e7,\n    0x8108,\n    0x9129,\n    0xa14a,\n    0xb16b,\n    0xc18c,\n    0xd1ad,\n    0xe1ce,\n    0xf1ef,\n    0x1231,\n    0x0210,\n    0x3273,\n    0x2252,\n    0x52b5,\n    0x4294,\n    0x72f7,\n    0x62d6,\n    0x9339,\n    0x8318,\n    0xb37b,\n    0xa35a,\n    0xd3bd,\n    0xc39c,\n    0xf3ff,\n    0xe3de,\n    0x2462,\n    0x3443,\n    0x0420,\n    0x1401,\n    0x64e6,\n    0x74c7,\n    0x44a4,\n    0x5485,\n    0xa56a,\n    0xb54b,\n    0x8528,\n    0x9509,\n    0xe5ee,\n    0xf5cf,\n    0xc5ac,\n    0xd58d,\n    0x3653,\n    0x2672,\n    0x1611,\n    0x0630,\n    0x76d7,\n    0x66f6,\n    0x5695,\n    0x46b4,\n    0xb75b,\n    0xa77a,\n    0x9719,\n    0x8738,\n    0xf7df,\n    0xe7fe,\n    0xd79d,\n    0xc7bc,\n    0x48c4,\n    0x58e5,\n    0x6886,\n    0x78a7,\n    0x0840,\n    0x1861,\n    0x2802,\n    0x3823,\n    0xc9cc,\n    0xd9ed,\n    0xe98e,\n    0xf9af,\n    0x8948,\n    0x9969,\n    0xa90a,\n    0xb92b,\n    0x5af5,\n    0x4ad4,\n    0x7ab7,\n    0x6a96,\n    0x1a71,\n    0x0a50,\n    0x3a33,\n    0x2a12,\n    0xdbfd,\n    0xcbdc,\n    0xfbbf,\n    0xeb9e,\n    0x9b79,\n    0x8b58,\n    0xbb3b,\n    0xab1a,\n    0x6ca6,\n    0x7c87,\n    0x4ce4,\n    0x5cc5,\n    0x2c22,\n    0x3c03,\n    0x0c60,\n    0x1c41,\n    0xedae,\n    0xfd8f,\n    0xcdec,\n    0xddcd,\n    0xad2a,\n    0xbd0b,\n    0x8d68,\n    0x9d49,\n    0x7e97,\n    0x6eb6,\n    0x5ed5,\n    0x4ef4,\n    0x3e13,\n    0x2e32,\n    0x1e51,\n    0x0e70,\n    0xff9f,\n    0xefbe,\n    0xdfdd,\n    0xcffc,\n    0xbf1b,\n    0xaf3a,\n    0x9f59,\n    0x8f78,\n    0x9188,\n    0x81a9,\n    0xb1ca,\n    0xa1eb,\n    0xd10c,\n    0xc12d,\n    0xf14e,\n    0xe16f,\n    0x1080,\n    0x00a1,\n    0x30c2,\n    0x20e3,\n    0x5004,\n    0x4025,\n    0x7046,\n    0x6067,\n    0x83b9,\n    0x9398,\n    0xa3fb,\n    0xb3da,\n    0xc33d,\n    0xd31c,\n    0xe37f,\n    0xf35e,\n    0x02b1,\n    0x1290,\n    0x22f3,\n    0x32d2,\n    0x4235,\n    0x5214,\n    0x6277,\n    0x7256,\n    0xb5ea,\n    0xa5cb,\n    0x95a8,\n    0x8589,\n    0xf56e,\n    0xe54f,\n    0xd52c,\n    0xc50d,\n    0x34e2,\n    0x24c3,\n    0x14a0,\n    0x0481,\n    0x7466,\n    0x6447,\n    0x5424,\n    0x4405,\n    0xa7db,\n    0xb7fa,\n    0x8799,\n    0x97b8,\n    0xe75f,\n    0xf77e,\n    0xc71d,\n    0xd73c,\n    0x26d3,\n    0x36f2,\n    0x0691,\n    0x16b0,\n    0x6657,\n    0x7676,\n    0x4615,\n    0x5634,\n    0xd94c,\n    0xc96d,\n    0xf90e,\n    0xe92f,\n    0x99c8,\n    0x89e9,\n    0xb98a,\n    0xa9ab,\n    0x5844,\n    0x4865,\n    0x7806,\n    0x6827,\n    0x18c0,\n    0x08e1,\n    0x3882,\n    0x28a3,\n    0xcb7d,\n    0xdb5c,\n    0xeb3f,\n    0xfb1e,\n    0x8bf9,\n    0x9bd8,\n    0xabbb,\n    0xbb9a,\n    0x4a75,\n    0x5a54,\n    0x6a37,\n    0x7a16,\n    0x0af1,\n    0x1ad0,\n    0x2ab3,\n    0x3a92,\n    0xfd2e,\n    0xed0f,\n    0xdd6c,\n    0xcd4d,\n    0xbdaa,\n    0xad8b,\n    0x9de8,\n    0x8dc9,\n    0x7c26,\n    0x6c07,\n    0x5c64,\n    0x4c45,\n    0x3ca2,\n    0x2c83,\n    0x1ce0,\n    0x0cc1,\n    0xef1f,\n    0xff3e,\n    0xcf5d,\n    0xdf7c,\n    0xaf9b,\n    0xbfba,\n    0x8fd9,\n    0x9ff8,\n    0x6e17,\n    0x7e36,\n    0x4e55,\n    0x5e74,\n    0x2e93,\n    0x3eb2,\n    0x0ed1,\n    0x1ef0\n]);\nclass crc16 {\n    static checksum(data) {\n        let crc = 0;\n        for(let i = 0; i < data.byteLength; i++){\n            let b = data[i];\n            crc = crc << 8 & 0xffff ^ crc16tab[(crc >> 8 ^ b) & 0x00FF];\n        }\n        return crc;\n    }\n    static validate(data, expected) {\n        let ba = crc16.checksum(data);\n        return ba == expected;\n    }\n}\nconst b32Alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\nclass base32 {\n    static encode(src) {\n        let bits = 0;\n        let value = 0;\n        let a = new Uint8Array(src);\n        let buf = new Uint8Array(src.byteLength * 2);\n        let j = 0;\n        for(let i = 0; i < a.byteLength; i++){\n            value = value << 8 | a[i];\n            bits += 8;\n            while(bits >= 5){\n                let index = value >>> bits - 5 & 31;\n                buf[j++] = b32Alphabet.charAt(index).charCodeAt(0);\n                bits -= 5;\n            }\n        }\n        if (bits > 0) {\n            let index = value << 5 - bits & 31;\n            buf[j++] = b32Alphabet.charAt(index).charCodeAt(0);\n        }\n        return buf.slice(0, j);\n    }\n    static decode(src) {\n        let bits = 0;\n        let __byte = 0;\n        let j = 0;\n        let a = new Uint8Array(src);\n        let out = new Uint8Array(a.byteLength * 5 / 8 | 0);\n        for(let i = 0; i < a.byteLength; i++){\n            let v = String.fromCharCode(a[i]);\n            let vv = b32Alphabet.indexOf(v);\n            if (vv === -1) {\n                throw new Error(\"Illegal Base32 character: \" + a[i]);\n            }\n            __byte = __byte << 5 | vv;\n            bits += 5;\n            if (bits >= 8) {\n                out[j++] = __byte >>> bits - 8 & 255;\n                bits -= 8;\n            }\n        }\n        return out.slice(0, j);\n    }\n}\nclass NKeysError extends Error {\n    name;\n    code;\n    chainedError;\n    constructor(code, chainedError){\n        super(code);\n        this.name = \"NKeysError\";\n        this.code = code;\n        this.chainedError = chainedError;\n    }\n}\nfunction createOperator() {\n    return createPair(Prefix.Operator);\n}\nfunction createAccount() {\n    return createPair(Prefix.Account);\n}\nfunction createUser() {\n    return createPair(Prefix.User);\n}\nvar NKeysErrorCode;\n(function(NKeysErrorCode) {\n    NKeysErrorCode[\"InvalidPrefixByte\"] = \"nkeys: invalid prefix byte\";\n    NKeysErrorCode[\"InvalidKey\"] = \"nkeys: invalid key\";\n    NKeysErrorCode[\"InvalidPublicKey\"] = \"nkeys: invalid public key\";\n    NKeysErrorCode[\"InvalidSeedLen\"] = \"nkeys: invalid seed length\";\n    NKeysErrorCode[\"InvalidSeed\"] = \"nkeys: invalid seed\";\n    NKeysErrorCode[\"InvalidEncoding\"] = \"nkeys: invalid encoded key\";\n    NKeysErrorCode[\"InvalidSignature\"] = \"nkeys: signature verification failed\";\n    NKeysErrorCode[\"CannotSign\"] = \"nkeys: cannot sign, no private key available\";\n    NKeysErrorCode[\"PublicKeyOnly\"] = \"nkeys: no seed or private key available\";\n    NKeysErrorCode[\"InvalidChecksum\"] = \"nkeys: invalid checksum\";\n    NKeysErrorCode[\"SerializationError\"] = \"nkeys: serialization error\";\n    NKeysErrorCode[\"ApiError\"] = \"nkeys: api error\";\n    NKeysErrorCode[\"ClearedPair\"] = \"nkeys: pair is cleared\";\n})(NKeysErrorCode || (NKeysErrorCode = {}));\nvar Prefix;\n(function(Prefix) {\n    Prefix[Prefix[\"Seed\"] = 144] = \"Seed\";\n    Prefix[Prefix[\"Private\"] = 120] = \"Private\";\n    Prefix[Prefix[\"Operator\"] = 112] = \"Operator\";\n    Prefix[Prefix[\"Server\"] = 104] = \"Server\";\n    Prefix[Prefix[\"Cluster\"] = 16] = \"Cluster\";\n    Prefix[Prefix[\"Account\"] = 0] = \"Account\";\n    Prefix[Prefix[\"User\"] = 160] = \"User\";\n})(Prefix || (Prefix = {}));\nclass Prefixes {\n    static isValidPublicPrefix(prefix) {\n        return prefix == Prefix.Server || prefix == Prefix.Operator || prefix == Prefix.Cluster || prefix == Prefix.Account || prefix == Prefix.User;\n    }\n    static startsWithValidPrefix(s) {\n        let c = s[0];\n        return c == \"S\" || c == \"P\" || c == \"O\" || c == \"N\" || c == \"C\" || c == \"A\" || c == \"U\";\n    }\n    static isValidPrefix(prefix) {\n        let v = this.parsePrefix(prefix);\n        return v != -1;\n    }\n    static parsePrefix(v) {\n        switch(v){\n            case Prefix.Seed:\n                return Prefix.Seed;\n            case Prefix.Private:\n                return Prefix.Private;\n            case Prefix.Operator:\n                return Prefix.Operator;\n            case Prefix.Server:\n                return Prefix.Server;\n            case Prefix.Cluster:\n                return Prefix.Cluster;\n            case Prefix.Account:\n                return Prefix.Account;\n            case Prefix.User:\n                return Prefix.User;\n            default:\n                return -1;\n        }\n    }\n}\nclass Codec {\n    static encode(prefix, src) {\n        if (!src || !(src instanceof Uint8Array)) {\n            throw new NKeysError(NKeysErrorCode.SerializationError);\n        }\n        if (!Prefixes.isValidPrefix(prefix)) {\n            throw new NKeysError(NKeysErrorCode.InvalidPrefixByte);\n        }\n        return Codec._encode(false, prefix, src);\n    }\n    static encodeSeed(role, src) {\n        if (!src) {\n            throw new NKeysError(NKeysErrorCode.ApiError);\n        }\n        if (!Prefixes.isValidPublicPrefix(role)) {\n            throw new NKeysError(NKeysErrorCode.InvalidPrefixByte);\n        }\n        if (src.byteLength !== 32) {\n            throw new NKeysError(NKeysErrorCode.InvalidSeedLen);\n        }\n        return Codec._encode(true, role, src);\n    }\n    static decode(expected, src) {\n        if (!Prefixes.isValidPrefix(expected)) {\n            throw new NKeysError(NKeysErrorCode.InvalidPrefixByte);\n        }\n        const raw = Codec._decode(src);\n        if (raw[0] !== expected) {\n            throw new NKeysError(NKeysErrorCode.InvalidPrefixByte);\n        }\n        return raw.slice(1);\n    }\n    static decodeSeed(src) {\n        const raw = Codec._decode(src);\n        const prefix = Codec._decodePrefix(raw);\n        if (prefix[0] != Prefix.Seed) {\n            throw new NKeysError(NKeysErrorCode.InvalidSeed);\n        }\n        if (!Prefixes.isValidPublicPrefix(prefix[1])) {\n            throw new NKeysError(NKeysErrorCode.InvalidPrefixByte);\n        }\n        return {\n            buf: raw.slice(2),\n            prefix: prefix[1]\n        };\n    }\n    static _encode(seed, role, payload) {\n        const payloadOffset = seed ? 2 : 1;\n        const payloadLen = payload.byteLength;\n        const cap = payloadOffset + payloadLen + 2;\n        const checkOffset = payloadOffset + payloadLen;\n        const raw = new Uint8Array(cap);\n        if (seed) {\n            const encodedPrefix = Codec._encodePrefix(Prefix.Seed, role);\n            raw.set(encodedPrefix);\n        } else {\n            raw[0] = role;\n        }\n        raw.set(payload, payloadOffset);\n        const checksum = crc16.checksum(raw.slice(0, checkOffset));\n        const dv = new DataView(raw.buffer);\n        dv.setUint16(checkOffset, checksum, true);\n        return base32.encode(raw);\n    }\n    static _decode(src) {\n        if (src.byteLength < 4) {\n            throw new NKeysError(NKeysErrorCode.InvalidEncoding);\n        }\n        let raw;\n        try {\n            raw = base32.decode(src);\n        } catch (ex) {\n            throw new NKeysError(NKeysErrorCode.InvalidEncoding, ex);\n        }\n        const checkOffset = raw.byteLength - 2;\n        const dv = new DataView(raw.buffer);\n        const checksum = dv.getUint16(checkOffset, true);\n        const payload = raw.slice(0, checkOffset);\n        if (!crc16.validate(payload, checksum)) {\n            throw new NKeysError(NKeysErrorCode.InvalidChecksum);\n        }\n        return payload;\n    }\n    static _encodePrefix(kind, role) {\n        const b1 = kind | role >> 5;\n        const b2 = (role & 31) << 3;\n        return new Uint8Array([\n            b1,\n            b2\n        ]);\n    }\n    static _decodePrefix(raw) {\n        const b1 = raw[0] & 248;\n        const b2 = (raw[0] & 7) << 5 | (raw[1] & 248) >> 3;\n        return new Uint8Array([\n            b1,\n            b2\n        ]);\n    }\n}\nclass KP {\n    seed;\n    constructor(seed){\n        this.seed = seed;\n    }\n    getRawSeed() {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        let sd = Codec.decodeSeed(this.seed);\n        return sd.buf;\n    }\n    getSeed() {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        return this.seed;\n    }\n    getPublicKey() {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        const sd = Codec.decodeSeed(this.seed);\n        const kp = getEd25519Helper().fromSeed(this.getRawSeed());\n        const buf = Codec.encode(sd.prefix, kp.publicKey);\n        return new TextDecoder().decode(buf);\n    }\n    getPrivateKey() {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        const kp = getEd25519Helper().fromSeed(this.getRawSeed());\n        return Codec.encode(Prefix.Private, kp.secretKey);\n    }\n    sign(input) {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        const kp = getEd25519Helper().fromSeed(this.getRawSeed());\n        return getEd25519Helper().sign(input, kp.secretKey);\n    }\n    verify(input, sig) {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        const kp = getEd25519Helper().fromSeed(this.getRawSeed());\n        return getEd25519Helper().verify(input, sig, kp.publicKey);\n    }\n    clear() {\n        if (!this.seed) {\n            return;\n        }\n        this.seed.fill(0);\n        this.seed = undefined;\n    }\n}\nfunction createPair(prefix) {\n    const rawSeed = getEd25519Helper().randomBytes(32);\n    let str = Codec.encodeSeed(prefix, new Uint8Array(rawSeed));\n    return new KP(str);\n}\nclass PublicKey {\n    publicKey;\n    constructor(publicKey){\n        this.publicKey = publicKey;\n    }\n    getPublicKey() {\n        if (!this.publicKey) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        return new TextDecoder().decode(this.publicKey);\n    }\n    getPrivateKey() {\n        if (!this.publicKey) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        throw new NKeysError(NKeysErrorCode.PublicKeyOnly);\n    }\n    getSeed() {\n        if (!this.publicKey) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        throw new NKeysError(NKeysErrorCode.PublicKeyOnly);\n    }\n    sign(_) {\n        if (!this.publicKey) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        throw new NKeysError(NKeysErrorCode.CannotSign);\n    }\n    verify(input, sig) {\n        if (!this.publicKey) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        let buf = Codec._decode(this.publicKey);\n        return getEd25519Helper().verify(input, sig, buf.slice(1));\n    }\n    clear() {\n        if (!this.publicKey) {\n            return;\n        }\n        this.publicKey.fill(0);\n        this.publicKey = undefined;\n    }\n}\nfunction fromPublic(src) {\n    const ba = new TextEncoder().encode(src);\n    const raw = Codec._decode(ba);\n    const prefix = Prefixes.parsePrefix(raw[0]);\n    if (Prefixes.isValidPublicPrefix(prefix)) {\n        return new PublicKey(ba);\n    }\n    throw new NKeysError(NKeysErrorCode.InvalidPublicKey);\n}\nfunction fromSeed(src) {\n    Codec.decodeSeed(src);\n    return new KP(src);\n}\nfunction encode2(bytes) {\n    return btoa(String.fromCharCode(...bytes));\n}\nfunction decode2(b64str) {\n    const bin = atob(b64str);\n    const bytes = new Uint8Array(bin.length);\n    for(let i = 0; i < bin.length; i++){\n        bytes[i] = bin.charCodeAt(i);\n    }\n    return bytes;\n}\nsetEd25519Helper(denoHelper);\nconst mod = {\n    createAccount,\n    createOperator,\n    createPair,\n    createUser,\n    fromPublic,\n    fromSeed,\n    NKeysError,\n    NKeysErrorCode,\n    Prefix,\n    decode: decode2,\n    encode: encode2\n};\nfunction multiAuthenticator(authenticators) {\n    return (nonce)=>{\n        let auth = {};\n        authenticators.forEach((a)=>{\n            const args = a(nonce) || {};\n            auth = Object.assign(auth, args);\n        });\n        return auth;\n    };\n}\nfunction noAuthFn() {\n    return ()=>{\n        return;\n    };\n}\nfunction usernamePasswordAuthenticator(user, pass) {\n    return ()=>{\n        const u = typeof user === \"function\" ? user() : user;\n        const p = typeof pass === \"function\" ? pass() : pass;\n        return {\n            user: u,\n            pass: p\n        };\n    };\n}\nfunction tokenAuthenticator(token) {\n    return ()=>{\n        const auth_token = typeof token === \"function\" ? token() : token;\n        return {\n            auth_token\n        };\n    };\n}\nfunction nkeyAuthenticator(seed) {\n    return (nonce)=>{\n        const s = typeof seed === \"function\" ? seed() : seed;\n        const kp = s ? mod.fromSeed(s) : undefined;\n        const nkey = kp ? kp.getPublicKey() : \"\";\n        const challenge = TE.encode(nonce || \"\");\n        const sigBytes = kp !== undefined && nonce ? kp.sign(challenge) : undefined;\n        const sig = sigBytes ? mod.encode(sigBytes) : \"\";\n        return {\n            nkey,\n            sig\n        };\n    };\n}\nfunction jwtAuthenticator(ajwt, seed) {\n    return (nonce)=>{\n        const jwt = typeof ajwt === \"function\" ? ajwt() : ajwt;\n        const fn = nkeyAuthenticator(seed);\n        const { nkey, sig } = fn(nonce);\n        return {\n            jwt,\n            nkey,\n            sig\n        };\n    };\n}\nfunction credsAuthenticator(creds) {\n    const fn = typeof creds !== \"function\" ? ()=>creds : creds;\n    const parse = ()=>{\n        const CREDS = /\\s*(?:(?:[-]{3,}[^\\n]*[-]{3,}\\n)(.+)(?:\\n\\s*[-]{3,}[^\\n]*[-]{3,}\\n))/ig;\n        const s = TD.decode(fn());\n        let m = CREDS.exec(s);\n        if (!m) {\n            throw NatsError.errorForCode(ErrorCode.BadCreds);\n        }\n        const jwt = m[1].trim();\n        m = CREDS.exec(s);\n        if (!m) {\n            throw NatsError.errorForCode(ErrorCode.BadCreds);\n        }\n        if (!m) {\n            throw NatsError.errorForCode(ErrorCode.BadCreds);\n        }\n        const seed = TE.encode(m[1].trim());\n        return {\n            jwt,\n            seed\n        };\n    };\n    const jwtFn = ()=>{\n        const { jwt } = parse();\n        return jwt;\n    };\n    const nkeyFn = ()=>{\n        const { seed } = parse();\n        return seed;\n    };\n    return jwtAuthenticator(jwtFn, nkeyFn);\n}\nconst DEFAULT_PING_INTERVAL = 2 * 60 * 1000;\nconst DEFAULT_MAX_PING_OUT = 2;\nconst DEFAULT_RECONNECT_TIME_WAIT = 2 * 1000;\nfunction defaultOptions() {\n    return {\n        maxPingOut: 2,\n        maxReconnectAttempts: 10,\n        noRandomize: false,\n        pedantic: false,\n        pingInterval: DEFAULT_PING_INTERVAL,\n        reconnect: true,\n        reconnectJitter: 100,\n        reconnectJitterTLS: 1000,\n        reconnectTimeWait: DEFAULT_RECONNECT_TIME_WAIT,\n        tls: undefined,\n        verbose: false,\n        waitOnFirstConnect: false,\n        ignoreAuthErrorAbort: false\n    };\n}\nfunction buildAuthenticator(opts) {\n    const buf = [];\n    if (typeof opts.authenticator === \"function\") {\n        buf.push(opts.authenticator);\n    }\n    if (Array.isArray(opts.authenticator)) {\n        buf.push(...opts.authenticator);\n    }\n    if (opts.token) {\n        buf.push(tokenAuthenticator(opts.token));\n    }\n    if (opts.user) {\n        buf.push(usernamePasswordAuthenticator(opts.user, opts.pass));\n    }\n    return buf.length === 0 ? noAuthFn() : multiAuthenticator(buf);\n}\nfunction parseOptions(opts) {\n    const dhp = `${DEFAULT_HOST}:${defaultPort()}`;\n    opts = opts || {\n        servers: [\n            dhp\n        ]\n    };\n    opts.servers = opts.servers || [];\n    if (typeof opts.servers === \"string\") {\n        opts.servers = [\n            opts.servers\n        ];\n    }\n    if (opts.servers.length > 0 && opts.port) {\n        throw new NatsError(\"port and servers options are mutually exclusive\", ErrorCode.InvalidOption);\n    }\n    if (opts.servers.length === 0 && opts.port) {\n        opts.servers = [\n            `${DEFAULT_HOST}:${opts.port}`\n        ];\n    }\n    if (opts.servers && opts.servers.length === 0) {\n        opts.servers = [\n            dhp\n        ];\n    }\n    const options = extend(defaultOptions(), opts);\n    options.authenticator = buildAuthenticator(options);\n    [\n        \"reconnectDelayHandler\",\n        \"authenticator\"\n    ].forEach((n)=>{\n        if (options[n] && typeof options[n] !== \"function\") {\n            throw new NatsError(`${n} option should be a function`, ErrorCode.NotFunction);\n        }\n    });\n    if (!options.reconnectDelayHandler) {\n        options.reconnectDelayHandler = ()=>{\n            let extra = options.tls ? options.reconnectJitterTLS : options.reconnectJitter;\n            if (extra) {\n                extra++;\n                extra = Math.floor(Math.random() * extra);\n            }\n            return options.reconnectTimeWait + extra;\n        };\n    }\n    if (options.inboxPrefix) {\n        try {\n            createInbox(options.inboxPrefix);\n        } catch (err) {\n            throw new NatsError(err.message, ErrorCode.ApiError);\n        }\n    }\n    if (options.resolve === undefined) {\n        options.resolve = typeof getResolveFn() === \"function\";\n    }\n    if (options.resolve) {\n        if (typeof getResolveFn() !== \"function\") {\n            throw new NatsError(`'resolve' is not supported on this client`, ErrorCode.InvalidOption);\n        }\n    }\n    return options;\n}\nfunction checkOptions(info, options) {\n    const { proto, tls_required: tlsRequired, tls_available: tlsAvailable } = info;\n    if ((proto === undefined || proto < 1) && options.noEcho) {\n        throw new NatsError(\"noEcho\", ErrorCode.ServerOptionNotAvailable);\n    }\n    const tls = tlsRequired || tlsAvailable || false;\n    if (options.tls && !tls) {\n        throw new NatsError(\"tls\", ErrorCode.ServerOptionNotAvailable);\n    }\n}\nconst FLUSH_THRESHOLD = 1024 * 32;\nconst INFO = /^INFO\\s+([^\\r\\n]+)\\r\\n/i;\nconst PONG_CMD = encode(\"PONG\\r\\n\");\nconst PING_CMD = encode(\"PING\\r\\n\");\nclass Connect {\n    echo;\n    no_responders;\n    protocol;\n    verbose;\n    pedantic;\n    jwt;\n    nkey;\n    sig;\n    user;\n    pass;\n    auth_token;\n    tls_required;\n    name;\n    lang;\n    version;\n    headers;\n    constructor(transport, opts, nonce){\n        this.protocol = 1;\n        this.version = transport.version;\n        this.lang = transport.lang;\n        this.echo = opts.noEcho ? false : undefined;\n        this.verbose = opts.verbose;\n        this.pedantic = opts.pedantic;\n        this.tls_required = opts.tls ? true : undefined;\n        this.name = opts.name;\n        const creds = (opts && typeof opts.authenticator === \"function\" ? opts.authenticator(nonce) : {}) || {};\n        extend(this, creds);\n    }\n}\nclass SubscriptionImpl extends QueuedIteratorImpl {\n    sid;\n    queue;\n    draining;\n    max;\n    subject;\n    drained;\n    protocol;\n    timer;\n    info;\n    cleanupFn;\n    closed;\n    requestSubject;\n    constructor(protocol, subject, opts = {}){\n        super();\n        extend(this, opts);\n        this.protocol = protocol;\n        this.subject = subject;\n        this.draining = false;\n        this.noIterator = typeof opts.callback === \"function\";\n        this.closed = deferred();\n        const asyncTraces = !(protocol.options?.noAsyncTraces || false);\n        if (opts.timeout) {\n            this.timer = timeout(opts.timeout, asyncTraces);\n            this.timer.then(()=>{\n                this.timer = undefined;\n            }).catch((err)=>{\n                this.stop(err);\n                if (this.noIterator) {\n                    this.callback(err, {});\n                }\n            });\n        }\n        if (!this.noIterator) {\n            this.iterClosed.then(()=>{\n                this.closed.resolve();\n                this.unsubscribe();\n            });\n        }\n    }\n    setPrePostHandlers(opts) {\n        if (this.noIterator) {\n            const uc = this.callback;\n            const ingestion = opts.ingestionFilterFn ? opts.ingestionFilterFn : ()=>{\n                return {\n                    ingest: true,\n                    protocol: false\n                };\n            };\n            const filter = opts.protocolFilterFn ? opts.protocolFilterFn : ()=>{\n                return true;\n            };\n            const dispatched = opts.dispatchedFn ? opts.dispatchedFn : ()=>{};\n            this.callback = (err, msg)=>{\n                const { ingest } = ingestion(msg);\n                if (!ingest) {\n                    return;\n                }\n                if (filter(msg)) {\n                    uc(err, msg);\n                    dispatched(msg);\n                }\n            };\n        } else {\n            this.protocolFilterFn = opts.protocolFilterFn;\n            this.dispatchedFn = opts.dispatchedFn;\n        }\n    }\n    callback(err, msg) {\n        this.cancelTimeout();\n        err ? this.stop(err) : this.push(msg);\n    }\n    close() {\n        if (!this.isClosed()) {\n            this.cancelTimeout();\n            const fn = ()=>{\n                this.stop();\n                if (this.cleanupFn) {\n                    try {\n                        this.cleanupFn(this, this.info);\n                    } catch (_err) {}\n                }\n                this.closed.resolve();\n            };\n            if (this.noIterator) {\n                fn();\n            } else {\n                this.push(fn);\n            }\n        }\n    }\n    unsubscribe(max) {\n        this.protocol.unsubscribe(this, max);\n    }\n    cancelTimeout() {\n        if (this.timer) {\n            this.timer.cancel();\n            this.timer = undefined;\n        }\n    }\n    drain() {\n        if (this.protocol.isClosed()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.ConnectionClosed));\n        }\n        if (this.isClosed()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.SubClosed));\n        }\n        if (!this.drained) {\n            this.draining = true;\n            this.protocol.unsub(this);\n            this.drained = this.protocol.flush(deferred()).then(()=>{\n                this.protocol.subscriptions.cancel(this);\n            }).catch(()=>{\n                this.protocol.subscriptions.cancel(this);\n            });\n        }\n        return this.drained;\n    }\n    isDraining() {\n        return this.draining;\n    }\n    isClosed() {\n        return this.done;\n    }\n    getSubject() {\n        return this.subject;\n    }\n    getMax() {\n        return this.max;\n    }\n    getID() {\n        return this.sid;\n    }\n}\nclass Subscriptions {\n    mux;\n    subs;\n    sidCounter;\n    constructor(){\n        this.sidCounter = 0;\n        this.mux = null;\n        this.subs = new Map();\n    }\n    size() {\n        return this.subs.size;\n    }\n    add(s) {\n        this.sidCounter++;\n        s.sid = this.sidCounter;\n        this.subs.set(s.sid, s);\n        return s;\n    }\n    setMux(s) {\n        this.mux = s;\n        return s;\n    }\n    getMux() {\n        return this.mux;\n    }\n    get(sid) {\n        return this.subs.get(sid);\n    }\n    resub(s) {\n        this.sidCounter++;\n        this.subs.delete(s.sid);\n        s.sid = this.sidCounter;\n        this.subs.set(s.sid, s);\n        return s;\n    }\n    all() {\n        return Array.from(this.subs.values());\n    }\n    cancel(s) {\n        if (s) {\n            s.close();\n            this.subs.delete(s.sid);\n        }\n    }\n    handleError(err) {\n        if (err && err.permissionContext) {\n            const ctx = err.permissionContext;\n            const subs = this.all();\n            let sub;\n            if (ctx.operation === \"subscription\") {\n                sub = subs.find((s)=>{\n                    return s.subject === ctx.subject && s.queue === ctx.queue;\n                });\n            }\n            if (ctx.operation === \"publish\") {\n                sub = subs.find((s)=>{\n                    return s.requestSubject === ctx.subject;\n                });\n            }\n            if (sub) {\n                sub.callback(err, {});\n                sub.close();\n                this.subs.delete(sub.sid);\n                return sub !== this.mux;\n            }\n        }\n        return false;\n    }\n    close() {\n        this.subs.forEach((sub)=>{\n            sub.close();\n        });\n    }\n}\nclass ProtocolHandler {\n    connected;\n    connectedOnce;\n    infoReceived;\n    info;\n    muxSubscriptions;\n    options;\n    outbound;\n    pongs;\n    subscriptions;\n    transport;\n    noMorePublishing;\n    connectError;\n    publisher;\n    _closed;\n    closed;\n    listeners;\n    heartbeats;\n    parser;\n    outMsgs;\n    inMsgs;\n    outBytes;\n    inBytes;\n    pendingLimit;\n    lastError;\n    abortReconnect;\n    whyClosed;\n    servers;\n    server;\n    features;\n    connectPromise;\n    constructor(options, publisher){\n        this._closed = false;\n        this.connected = false;\n        this.connectedOnce = false;\n        this.infoReceived = false;\n        this.noMorePublishing = false;\n        this.abortReconnect = false;\n        this.listeners = [];\n        this.pendingLimit = FLUSH_THRESHOLD;\n        this.outMsgs = 0;\n        this.inMsgs = 0;\n        this.outBytes = 0;\n        this.inBytes = 0;\n        this.options = options;\n        this.publisher = publisher;\n        this.subscriptions = new Subscriptions();\n        this.muxSubscriptions = new MuxSubscription();\n        this.outbound = new DataBuffer();\n        this.pongs = [];\n        this.whyClosed = \"\";\n        this.pendingLimit = options.pendingLimit || this.pendingLimit;\n        this.features = new Features({\n            major: 0,\n            minor: 0,\n            micro: 0\n        });\n        this.connectPromise = null;\n        const servers = typeof options.servers === \"string\" ? [\n            options.servers\n        ] : options.servers;\n        this.servers = new Servers(servers, {\n            randomize: !options.noRandomize\n        });\n        this.closed = deferred();\n        this.parser = new Parser(this);\n        this.heartbeats = new Heartbeat(this, this.options.pingInterval || DEFAULT_PING_INTERVAL, this.options.maxPingOut || DEFAULT_MAX_PING_OUT);\n    }\n    resetOutbound() {\n        this.outbound.reset();\n        const pongs = this.pongs;\n        this.pongs = [];\n        const err = NatsError.errorForCode(ErrorCode.Disconnect);\n        err.stack = \"\";\n        pongs.forEach((p)=>{\n            p.reject(err);\n        });\n        this.parser = new Parser(this);\n        this.infoReceived = false;\n    }\n    dispatchStatus(status) {\n        this.listeners.forEach((q)=>{\n            q.push(status);\n        });\n    }\n    status() {\n        const iter = new QueuedIteratorImpl();\n        this.listeners.push(iter);\n        return iter;\n    }\n    prepare() {\n        if (this.transport) {\n            this.transport.discard();\n        }\n        this.info = undefined;\n        this.resetOutbound();\n        const pong = deferred();\n        pong.catch(()=>{});\n        this.pongs.unshift(pong);\n        this.connectError = (err)=>{\n            pong.reject(err);\n        };\n        this.transport = newTransport();\n        this.transport.closed().then(async (_err)=>{\n            this.connected = false;\n            if (!this.isClosed()) {\n                await this.disconnected(this.transport.closeError || this.lastError);\n                return;\n            }\n        });\n        return pong;\n    }\n    disconnect() {\n        this.dispatchStatus({\n            type: DebugEvents.StaleConnection,\n            data: \"\"\n        });\n        this.transport.disconnect();\n    }\n    reconnect() {\n        if (this.connected) {\n            this.dispatchStatus({\n                type: DebugEvents.ClientInitiatedReconnect,\n                data: \"\"\n            });\n            this.transport.disconnect();\n        }\n        return Promise.resolve();\n    }\n    async disconnected(err) {\n        this.dispatchStatus({\n            type: Events.Disconnect,\n            data: this.servers.getCurrentServer().toString()\n        });\n        if (this.options.reconnect) {\n            await this.dialLoop().then(()=>{\n                this.dispatchStatus({\n                    type: Events.Reconnect,\n                    data: this.servers.getCurrentServer().toString()\n                });\n                if (this.lastError?.code === ErrorCode.AuthenticationExpired) {\n                    this.lastError = undefined;\n                }\n            }).catch((err)=>{\n                this._close(err);\n            });\n        } else {\n            await this._close(err);\n        }\n    }\n    async dial(srv) {\n        const pong = this.prepare();\n        let timer;\n        try {\n            timer = timeout(this.options.timeout || 20000);\n            const cp = this.transport.connect(srv, this.options);\n            await Promise.race([\n                cp,\n                timer\n            ]);\n            (async ()=>{\n                try {\n                    for await (const b of this.transport){\n                        this.parser.parse(b);\n                    }\n                } catch (err) {\n                    console.log(\"reader closed\", err);\n                }\n            })().then();\n        } catch (err) {\n            pong.reject(err);\n        }\n        try {\n            await Promise.race([\n                timer,\n                pong\n            ]);\n            if (timer) {\n                timer.cancel();\n            }\n            this.connected = true;\n            this.connectError = undefined;\n            this.sendSubscriptions();\n            this.connectedOnce = true;\n            this.server.didConnect = true;\n            this.server.reconnects = 0;\n            this.flushPending();\n            this.heartbeats.start();\n        } catch (err) {\n            if (timer) {\n                timer.cancel();\n            }\n            await this.transport.close(err);\n            throw err;\n        }\n    }\n    async _doDial(srv) {\n        const { resolve } = this.options;\n        const alts = await srv.resolve({\n            fn: getResolveFn(),\n            debug: this.options.debug,\n            randomize: !this.options.noRandomize,\n            resolve\n        });\n        let lastErr = null;\n        for (const a of alts){\n            try {\n                lastErr = null;\n                this.dispatchStatus({\n                    type: DebugEvents.Reconnecting,\n                    data: a.toString()\n                });\n                await this.dial(a);\n                return;\n            } catch (err) {\n                lastErr = err;\n            }\n        }\n        throw lastErr;\n    }\n    dialLoop() {\n        if (this.connectPromise === null) {\n            this.connectPromise = this.dodialLoop();\n            this.connectPromise.then(()=>{}).catch(()=>{}).finally(()=>{\n                this.connectPromise = null;\n            });\n        }\n        return this.connectPromise;\n    }\n    async dodialLoop() {\n        let lastError;\n        while(true){\n            if (this._closed) {\n                this.servers.clear();\n            }\n            const wait = this.options.reconnectDelayHandler ? this.options.reconnectDelayHandler() : DEFAULT_RECONNECT_TIME_WAIT;\n            let maxWait = wait;\n            const srv = this.selectServer();\n            if (!srv || this.abortReconnect) {\n                if (lastError) {\n                    throw lastError;\n                } else if (this.lastError) {\n                    throw this.lastError;\n                } else {\n                    throw NatsError.errorForCode(ErrorCode.ConnectionRefused);\n                }\n            }\n            const now = Date.now();\n            if (srv.lastConnect === 0 || srv.lastConnect + wait <= now) {\n                srv.lastConnect = Date.now();\n                try {\n                    await this._doDial(srv);\n                    break;\n                } catch (err) {\n                    lastError = err;\n                    if (!this.connectedOnce) {\n                        if (this.options.waitOnFirstConnect) {\n                            continue;\n                        }\n                        this.servers.removeCurrentServer();\n                    }\n                    srv.reconnects++;\n                    const mra = this.options.maxReconnectAttempts || 0;\n                    if (mra !== -1 && srv.reconnects >= mra) {\n                        this.servers.removeCurrentServer();\n                    }\n                }\n            } else {\n                maxWait = Math.min(maxWait, srv.lastConnect + wait - now);\n                await delay(maxWait);\n            }\n        }\n    }\n    static async connect(options, publisher) {\n        const h = new ProtocolHandler(options, publisher);\n        await h.dialLoop();\n        return h;\n    }\n    static toError(s) {\n        const t = s ? s.toLowerCase() : \"\";\n        if (t.indexOf(\"permissions violation\") !== -1) {\n            const err = new NatsError(s, ErrorCode.PermissionsViolation);\n            const m = s.match(/(Publish|Subscription) to \"(\\S+)\"/);\n            if (m) {\n                err.permissionContext = {\n                    operation: m[1].toLowerCase(),\n                    subject: m[2],\n                    queue: undefined\n                };\n                const qm = s.match(/using queue \"(\\S+)\"/);\n                if (qm) {\n                    err.permissionContext.queue = qm[1];\n                }\n            }\n            return err;\n        } else if (t.indexOf(\"authorization violation\") !== -1) {\n            return new NatsError(s, ErrorCode.AuthorizationViolation);\n        } else if (t.indexOf(\"user authentication expired\") !== -1) {\n            return new NatsError(s, ErrorCode.AuthenticationExpired);\n        } else if (t.indexOf(\"account authentication expired\") != -1) {\n            return new NatsError(s, ErrorCode.AccountExpired);\n        } else if (t.indexOf(\"authentication timeout\") !== -1) {\n            return new NatsError(s, ErrorCode.AuthenticationTimeout);\n        } else {\n            return new NatsError(s, ErrorCode.ProtocolError);\n        }\n    }\n    processMsg(msg, data) {\n        this.inMsgs++;\n        this.inBytes += data.length;\n        if (!this.subscriptions.sidCounter) {\n            return;\n        }\n        const sub = this.subscriptions.get(msg.sid);\n        if (!sub) {\n            return;\n        }\n        sub.received += 1;\n        if (sub.callback) {\n            sub.callback(null, new MsgImpl(msg, data, this));\n        }\n        if (sub.max !== undefined && sub.received >= sub.max) {\n            sub.unsubscribe();\n        }\n    }\n    processError(m) {\n        const s = decode(m);\n        const err = ProtocolHandler.toError(s);\n        const status = {\n            type: Events.Error,\n            data: err.code\n        };\n        if (err.isPermissionError()) {\n            let isMuxPermissionError = false;\n            if (err.permissionContext) {\n                status.permissionContext = err.permissionContext;\n                const mux = this.subscriptions.getMux();\n                isMuxPermissionError = mux?.subject === err.permissionContext.subject;\n            }\n            this.subscriptions.handleError(err);\n            this.muxSubscriptions.handleError(isMuxPermissionError, err);\n            if (isMuxPermissionError) {\n                this.subscriptions.setMux(null);\n            }\n        }\n        this.dispatchStatus(status);\n        this.handleError(err);\n    }\n    handleError(err) {\n        if (err.isAuthError()) {\n            this.handleAuthError(err);\n        } else if (err.isProtocolError()) {\n            this.lastError = err;\n        } else if (err.isAuthTimeout()) {\n            this.lastError = err;\n        }\n        if (!err.isPermissionError()) {\n            this.lastError = err;\n        }\n    }\n    handleAuthError(err) {\n        if (this.lastError && err.code === this.lastError.code && this.options.ignoreAuthErrorAbort === false) {\n            this.abortReconnect = true;\n        }\n        if (this.connectError) {\n            this.connectError(err);\n        } else {\n            this.disconnect();\n        }\n    }\n    processPing() {\n        this.transport.send(PONG_CMD);\n    }\n    processPong() {\n        const cb = this.pongs.shift();\n        if (cb) {\n            cb.resolve();\n        }\n    }\n    processInfo(m) {\n        const info = JSON.parse(decode(m));\n        this.info = info;\n        const updates = this.options && this.options.ignoreClusterUpdates ? undefined : this.servers.update(info, this.transport.isEncrypted());\n        if (!this.infoReceived) {\n            this.features.update(parseSemVer(info.version));\n            this.infoReceived = true;\n            if (this.transport.isEncrypted()) {\n                this.servers.updateTLSName();\n            }\n            const { version, lang } = this.transport;\n            try {\n                const c = new Connect({\n                    version,\n                    lang\n                }, this.options, info.nonce);\n                if (info.headers) {\n                    c.headers = true;\n                    c.no_responders = true;\n                }\n                const cs = JSON.stringify(c);\n                this.transport.send(encode(`CONNECT ${cs}${CR_LF}`));\n                this.transport.send(PING_CMD);\n            } catch (err) {\n                this._close(err);\n            }\n        }\n        if (updates) {\n            this.dispatchStatus({\n                type: Events.Update,\n                data: updates\n            });\n        }\n        const ldm = info.ldm !== undefined ? info.ldm : false;\n        if (ldm) {\n            this.dispatchStatus({\n                type: Events.LDM,\n                data: this.servers.getCurrentServer().toString()\n            });\n        }\n    }\n    push(e) {\n        switch(e.kind){\n            case Kind.MSG:\n                {\n                    const { msg, data } = e;\n                    this.processMsg(msg, data);\n                    break;\n                }\n            case Kind.OK:\n                break;\n            case Kind.ERR:\n                this.processError(e.data);\n                break;\n            case Kind.PING:\n                this.processPing();\n                break;\n            case Kind.PONG:\n                this.processPong();\n                break;\n            case Kind.INFO:\n                this.processInfo(e.data);\n                break;\n        }\n    }\n    sendCommand(cmd, ...payloads) {\n        const len = this.outbound.length();\n        let buf;\n        if (typeof cmd === \"string\") {\n            buf = encode(cmd);\n        } else {\n            buf = cmd;\n        }\n        this.outbound.fill(buf, ...payloads);\n        if (len === 0) {\n            queueMicrotask(()=>{\n                this.flushPending();\n            });\n        } else if (this.outbound.size() >= this.pendingLimit) {\n            this.flushPending();\n        }\n    }\n    publish(subject, payload = Empty, options) {\n        let data;\n        if (payload instanceof Uint8Array) {\n            data = payload;\n        } else if (typeof payload === \"string\") {\n            data = TE.encode(payload);\n        } else {\n            throw NatsError.errorForCode(ErrorCode.BadPayload);\n        }\n        let len = data.length;\n        options = options || {};\n        options.reply = options.reply || \"\";\n        let headers = Empty;\n        let hlen = 0;\n        if (options.headers) {\n            if (this.info && !this.info.headers) {\n                throw new NatsError(\"headers\", ErrorCode.ServerOptionNotAvailable);\n            }\n            const hdrs = options.headers;\n            headers = hdrs.encode();\n            hlen = headers.length;\n            len = data.length + hlen;\n        }\n        if (this.info && len > this.info.max_payload) {\n            throw NatsError.errorForCode(ErrorCode.MaxPayloadExceeded);\n        }\n        this.outBytes += len;\n        this.outMsgs++;\n        let proto;\n        if (options.headers) {\n            if (options.reply) {\n                proto = `HPUB ${subject} ${options.reply} ${hlen} ${len}\\r\\n`;\n            } else {\n                proto = `HPUB ${subject} ${hlen} ${len}\\r\\n`;\n            }\n            this.sendCommand(proto, headers, data, CRLF);\n        } else {\n            if (options.reply) {\n                proto = `PUB ${subject} ${options.reply} ${len}\\r\\n`;\n            } else {\n                proto = `PUB ${subject} ${len}\\r\\n`;\n            }\n            this.sendCommand(proto, data, CRLF);\n        }\n    }\n    request(r) {\n        this.initMux();\n        this.muxSubscriptions.add(r);\n        return r;\n    }\n    subscribe(s) {\n        this.subscriptions.add(s);\n        this._subunsub(s);\n        return s;\n    }\n    _sub(s) {\n        if (s.queue) {\n            this.sendCommand(`SUB ${s.subject} ${s.queue} ${s.sid}\\r\\n`);\n        } else {\n            this.sendCommand(`SUB ${s.subject} ${s.sid}\\r\\n`);\n        }\n    }\n    _subunsub(s) {\n        this._sub(s);\n        if (s.max) {\n            this.unsubscribe(s, s.max);\n        }\n        return s;\n    }\n    unsubscribe(s, max) {\n        this.unsub(s, max);\n        if (s.max === undefined || s.received >= s.max) {\n            this.subscriptions.cancel(s);\n        }\n    }\n    unsub(s, max) {\n        if (!s || this.isClosed()) {\n            return;\n        }\n        if (max) {\n            this.sendCommand(`UNSUB ${s.sid} ${max}\\r\\n`);\n        } else {\n            this.sendCommand(`UNSUB ${s.sid}\\r\\n`);\n        }\n        s.max = max;\n    }\n    resub(s, subject) {\n        if (!s || this.isClosed()) {\n            return;\n        }\n        this.unsub(s);\n        s.subject = subject;\n        this.subscriptions.resub(s);\n        this._sub(s);\n    }\n    flush(p) {\n        if (!p) {\n            p = deferred();\n        }\n        this.pongs.push(p);\n        this.outbound.fill(PING_CMD);\n        this.flushPending();\n        return p;\n    }\n    sendSubscriptions() {\n        const cmds = [];\n        this.subscriptions.all().forEach((s)=>{\n            const sub = s;\n            if (sub.queue) {\n                cmds.push(`SUB ${sub.subject} ${sub.queue} ${sub.sid}${CR_LF}`);\n            } else {\n                cmds.push(`SUB ${sub.subject} ${sub.sid}${CR_LF}`);\n            }\n        });\n        if (cmds.length) {\n            this.transport.send(encode(cmds.join(\"\")));\n        }\n    }\n    async _close(err) {\n        if (this._closed) {\n            return;\n        }\n        this.whyClosed = new Error(\"close trace\").stack || \"\";\n        this.heartbeats.cancel();\n        if (this.connectError) {\n            this.connectError(err);\n            this.connectError = undefined;\n        }\n        this.muxSubscriptions.close();\n        this.subscriptions.close();\n        this.listeners.forEach((l)=>{\n            l.stop();\n        });\n        this._closed = true;\n        await this.transport.close(err);\n        await this.closed.resolve(err);\n    }\n    close() {\n        return this._close();\n    }\n    isClosed() {\n        return this._closed;\n    }\n    drain() {\n        const subs = this.subscriptions.all();\n        const promises = [];\n        subs.forEach((sub)=>{\n            promises.push(sub.drain());\n        });\n        return Promise.all(promises).then(async ()=>{\n            this.noMorePublishing = true;\n            await this.flush();\n            return this.close();\n        }).catch(()=>{});\n    }\n    flushPending() {\n        if (!this.infoReceived || !this.connected) {\n            return;\n        }\n        if (this.outbound.size()) {\n            const d = this.outbound.drain();\n            this.transport.send(d);\n        }\n    }\n    initMux() {\n        const mux = this.subscriptions.getMux();\n        if (!mux) {\n            const inbox = this.muxSubscriptions.init(this.options.inboxPrefix);\n            const sub = new SubscriptionImpl(this, `${inbox}*`);\n            sub.callback = this.muxSubscriptions.dispatcher();\n            this.subscriptions.setMux(sub);\n            this.subscribe(sub);\n        }\n    }\n    selectServer() {\n        const server = this.servers.selectServer();\n        if (server === undefined) {\n            return undefined;\n        }\n        this.server = server;\n        return this.server;\n    }\n    getServer() {\n        return this.server;\n    }\n}\nconst ServiceApiPrefix = \"$SRV\";\nclass ServiceMsgImpl {\n    msg;\n    constructor(msg){\n        this.msg = msg;\n    }\n    get data() {\n        return this.msg.data;\n    }\n    get sid() {\n        return this.msg.sid;\n    }\n    get subject() {\n        return this.msg.subject;\n    }\n    get reply() {\n        return this.msg.reply || \"\";\n    }\n    get headers() {\n        return this.msg.headers;\n    }\n    respond(data, opts) {\n        return this.msg.respond(data, opts);\n    }\n    respondError(code, description, data, opts) {\n        opts = opts || {};\n        opts.headers = opts.headers || headers();\n        opts.headers?.set(ServiceErrorCodeHeader, `${code}`);\n        opts.headers?.set(ServiceErrorHeader, description);\n        return this.msg.respond(data, opts);\n    }\n    json(reviver) {\n        return this.msg.json(reviver);\n    }\n    string() {\n        return this.msg.string();\n    }\n}\nclass ServiceGroupImpl {\n    subject;\n    queue;\n    srv;\n    constructor(parent, name = \"\", queue = \"\"){\n        if (name !== \"\") {\n            validInternalToken(\"service group\", name);\n        }\n        let root = \"\";\n        if (parent instanceof ServiceImpl) {\n            this.srv = parent;\n            root = \"\";\n        } else if (parent instanceof ServiceGroupImpl) {\n            const sg = parent;\n            this.srv = sg.srv;\n            if (queue === \"\" && sg.queue !== \"\") {\n                queue = sg.queue;\n            }\n            root = sg.subject;\n        } else {\n            throw new Error(\"unknown ServiceGroup type\");\n        }\n        this.subject = this.calcSubject(root, name);\n        this.queue = queue;\n    }\n    calcSubject(root, name = \"\") {\n        if (name === \"\") {\n            return root;\n        }\n        return root !== \"\" ? `${root}.${name}` : name;\n    }\n    addEndpoint(name = \"\", opts) {\n        opts = opts || {\n            subject: name\n        };\n        const args = typeof opts === \"function\" ? {\n            handler: opts,\n            subject: name\n        } : opts;\n        validateName(\"endpoint\", name);\n        let { subject, handler, metadata, queue } = args;\n        subject = subject || name;\n        queue = queue || this.queue;\n        validSubjectName(\"endpoint subject\", subject);\n        subject = this.calcSubject(this.subject, subject);\n        const ne = {\n            name,\n            subject,\n            queue,\n            handler,\n            metadata\n        };\n        return this.srv._addEndpoint(ne);\n    }\n    addGroup(name = \"\", queue = \"\") {\n        return new ServiceGroupImpl(this, name, queue);\n    }\n}\nfunction validSubjectName(context, subj) {\n    if (subj === \"\") {\n        throw new Error(`${context} cannot be empty`);\n    }\n    if (subj.indexOf(\" \") !== -1) {\n        throw new Error(`${context} cannot contain spaces: '${subj}'`);\n    }\n    const tokens = subj.split(\".\");\n    tokens.forEach((v, idx)=>{\n        if (v === \">\" && idx !== tokens.length - 1) {\n            throw new Error(`${context} cannot have internal '>': '${subj}'`);\n        }\n    });\n}\nfunction validInternalToken(context, subj) {\n    if (subj.indexOf(\" \") !== -1) {\n        throw new Error(`${context} cannot contain spaces: '${subj}'`);\n    }\n    const tokens = subj.split(\".\");\n    tokens.forEach((v)=>{\n        if (v === \">\") {\n            throw new Error(`${context} name cannot contain internal '>': '${subj}'`);\n        }\n    });\n}\nclass ServiceImpl {\n    nc;\n    _id;\n    config;\n    handlers;\n    internal;\n    _stopped;\n    _done;\n    started;\n    static controlSubject(verb, name = \"\", id = \"\", prefix) {\n        const pre = prefix ?? ServiceApiPrefix;\n        if (name === \"\" && id === \"\") {\n            return `${pre}.${verb}`;\n        }\n        validateName(\"control subject name\", name);\n        if (id !== \"\") {\n            validateName(\"control subject id\", id);\n            return `${pre}.${verb}.${name}.${id}`;\n        }\n        return `${pre}.${verb}.${name}`;\n    }\n    constructor(nc, config = {\n        name: \"\",\n        version: \"\"\n    }){\n        this.nc = nc;\n        this.config = Object.assign({}, config);\n        if (!this.config.queue) {\n            this.config.queue = \"q\";\n        }\n        validateName(\"name\", this.config.name);\n        validateName(\"queue\", this.config.queue);\n        parseSemVer(this.config.version);\n        this._id = nuid.next();\n        this.internal = [];\n        this._done = deferred();\n        this._stopped = false;\n        this.handlers = [];\n        this.started = new Date().toISOString();\n        this.reset();\n        this.nc.closed().then(()=>{\n            this.close().catch();\n        }).catch((err)=>{\n            this.close(err).catch();\n        });\n    }\n    get subjects() {\n        return this.handlers.filter((s)=>{\n            return s.internal === false;\n        }).map((s)=>{\n            return s.subject;\n        });\n    }\n    get id() {\n        return this._id;\n    }\n    get name() {\n        return this.config.name;\n    }\n    get description() {\n        return this.config.description ?? \"\";\n    }\n    get version() {\n        return this.config.version;\n    }\n    get metadata() {\n        return this.config.metadata;\n    }\n    errorToHeader(err) {\n        const h = headers();\n        if (err instanceof ServiceError) {\n            const se = err;\n            h.set(ServiceErrorHeader, se.message);\n            h.set(ServiceErrorCodeHeader, `${se.code}`);\n        } else {\n            h.set(ServiceErrorHeader, err.message);\n            h.set(ServiceErrorCodeHeader, \"500\");\n        }\n        return h;\n    }\n    setupHandler(h, internal = false) {\n        const queue = internal ? \"\" : h.queue ? h.queue : this.config.queue;\n        const { name, subject, handler } = h;\n        const sv = h;\n        sv.internal = internal;\n        if (internal) {\n            this.internal.push(sv);\n        }\n        sv.stats = new NamedEndpointStatsImpl(name, subject, queue);\n        sv.queue = queue;\n        const callback = handler ? (err, msg)=>{\n            if (err) {\n                this.close(err);\n                return;\n            }\n            const start = Date.now();\n            try {\n                handler(err, new ServiceMsgImpl(msg));\n            } catch (err) {\n                sv.stats.countError(err);\n                msg?.respond(Empty, {\n                    headers: this.errorToHeader(err)\n                });\n            } finally{\n                sv.stats.countLatency(start);\n            }\n        } : undefined;\n        sv.sub = this.nc.subscribe(subject, {\n            callback,\n            queue\n        });\n        sv.sub.closed.then(()=>{\n            if (!this._stopped) {\n                this.close(new Error(`required subscription ${h.subject} stopped`)).catch();\n            }\n        }).catch((err)=>{\n            if (!this._stopped) {\n                const ne = new Error(`required subscription ${h.subject} errored: ${err.message}`);\n                ne.stack = err.stack;\n                this.close(ne).catch();\n            }\n        });\n        return sv;\n    }\n    info() {\n        return {\n            type: ServiceResponseType.INFO,\n            name: this.name,\n            id: this.id,\n            version: this.version,\n            description: this.description,\n            metadata: this.metadata,\n            endpoints: this.endpoints()\n        };\n    }\n    endpoints() {\n        return this.handlers.map((v)=>{\n            const { subject, metadata, name, queue } = v;\n            return {\n                subject,\n                metadata,\n                name,\n                queue_group: queue\n            };\n        });\n    }\n    async stats() {\n        const endpoints = [];\n        for (const h of this.handlers){\n            if (typeof this.config.statsHandler === \"function\") {\n                try {\n                    h.stats.data = await this.config.statsHandler(h);\n                } catch (err) {\n                    h.stats.countError(err);\n                }\n            }\n            endpoints.push(h.stats.stats(h.qi));\n        }\n        return {\n            type: ServiceResponseType.STATS,\n            name: this.name,\n            id: this.id,\n            version: this.version,\n            started: this.started,\n            metadata: this.metadata,\n            endpoints\n        };\n    }\n    addInternalHandler(verb, handler) {\n        const v = `${verb}`.toUpperCase();\n        this._doAddInternalHandler(`${v}-all`, verb, handler);\n        this._doAddInternalHandler(`${v}-kind`, verb, handler, this.name);\n        this._doAddInternalHandler(`${v}`, verb, handler, this.name, this.id);\n    }\n    _doAddInternalHandler(name, verb, handler, kind = \"\", id = \"\") {\n        const endpoint = {};\n        endpoint.name = name;\n        endpoint.subject = ServiceImpl.controlSubject(verb, kind, id);\n        endpoint.handler = handler;\n        this.setupHandler(endpoint, true);\n    }\n    start() {\n        const jc = JSONCodec();\n        const statsHandler = (err, msg)=>{\n            if (err) {\n                this.close(err);\n                return Promise.reject(err);\n            }\n            return this.stats().then((s)=>{\n                msg?.respond(jc.encode(s));\n                return Promise.resolve();\n            });\n        };\n        const infoHandler = (err, msg)=>{\n            if (err) {\n                this.close(err);\n                return Promise.reject(err);\n            }\n            msg?.respond(jc.encode(this.info()));\n            return Promise.resolve();\n        };\n        const ping = jc.encode(this.ping());\n        const pingHandler = (err, msg)=>{\n            if (err) {\n                this.close(err).then().catch();\n                return Promise.reject(err);\n            }\n            msg.respond(ping);\n            return Promise.resolve();\n        };\n        this.addInternalHandler(ServiceVerb.PING, pingHandler);\n        this.addInternalHandler(ServiceVerb.STATS, statsHandler);\n        this.addInternalHandler(ServiceVerb.INFO, infoHandler);\n        this.handlers.forEach((h)=>{\n            const { subject } = h;\n            if (typeof subject !== \"string\") {\n                return;\n            }\n            if (h.handler === null) {\n                return;\n            }\n            this.setupHandler(h);\n        });\n        return Promise.resolve(this);\n    }\n    close(err) {\n        if (this._stopped) {\n            return this._done;\n        }\n        this._stopped = true;\n        let buf = [];\n        if (!this.nc.isClosed()) {\n            buf = this.handlers.concat(this.internal).map((h)=>{\n                return h.sub.drain();\n            });\n        }\n        Promise.allSettled(buf).then(()=>{\n            this._done.resolve(err ? err : null);\n        });\n        return this._done;\n    }\n    get stopped() {\n        return this._done;\n    }\n    get isStopped() {\n        return this._stopped;\n    }\n    stop(err) {\n        return this.close(err);\n    }\n    ping() {\n        return {\n            type: ServiceResponseType.PING,\n            name: this.name,\n            id: this.id,\n            version: this.version,\n            metadata: this.metadata\n        };\n    }\n    reset() {\n        this.started = new Date().toISOString();\n        if (this.handlers) {\n            for (const h of this.handlers){\n                h.stats.reset(h.qi);\n            }\n        }\n    }\n    addGroup(name, queue) {\n        return new ServiceGroupImpl(this, name, queue);\n    }\n    addEndpoint(name, handler) {\n        const sg = new ServiceGroupImpl(this);\n        return sg.addEndpoint(name, handler);\n    }\n    _addEndpoint(e) {\n        const qi = new QueuedIteratorImpl();\n        qi.noIterator = typeof e.handler === \"function\";\n        if (!qi.noIterator) {\n            e.handler = (err, msg)=>{\n                err ? this.stop(err).catch() : qi.push(new ServiceMsgImpl(msg));\n            };\n            qi.iterClosed.then(()=>{\n                this.close().catch();\n            });\n        }\n        const ss = this.setupHandler(e, false);\n        ss.qi = qi;\n        this.handlers.push(ss);\n        return qi;\n    }\n}\nclass NamedEndpointStatsImpl {\n    name;\n    subject;\n    average_processing_time;\n    num_requests;\n    processing_time;\n    num_errors;\n    last_error;\n    data;\n    metadata;\n    queue;\n    constructor(name, subject, queue = \"\"){\n        this.name = name;\n        this.subject = subject;\n        this.average_processing_time = 0;\n        this.num_errors = 0;\n        this.num_requests = 0;\n        this.processing_time = 0;\n        this.queue = queue;\n    }\n    reset(qi) {\n        this.num_requests = 0;\n        this.processing_time = 0;\n        this.average_processing_time = 0;\n        this.num_errors = 0;\n        this.last_error = undefined;\n        this.data = undefined;\n        const qii = qi;\n        if (qii) {\n            qii.time = 0;\n            qii.processed = 0;\n        }\n    }\n    countLatency(start) {\n        this.num_requests++;\n        this.processing_time += nanos(Date.now() - start);\n        this.average_processing_time = Math.round(this.processing_time / this.num_requests);\n    }\n    countError(err) {\n        this.num_errors++;\n        this.last_error = err.message;\n    }\n    _stats() {\n        const { name, subject, average_processing_time, num_errors, num_requests, processing_time, last_error, data, queue } = this;\n        return {\n            name,\n            subject,\n            average_processing_time,\n            num_errors,\n            num_requests,\n            processing_time,\n            last_error,\n            data,\n            queue_group: queue\n        };\n    }\n    stats(qi) {\n        const qii = qi;\n        if (qii?.noIterator === false) {\n            this.processing_time = qii.time;\n            this.num_requests = qii.processed;\n            this.average_processing_time = this.processing_time > 0 && this.num_requests > 0 ? this.processing_time / this.num_requests : 0;\n        }\n        return this._stats();\n    }\n}\nclass ServiceClientImpl {\n    nc;\n    prefix;\n    opts;\n    constructor(nc, opts = {\n        strategy: RequestStrategy.JitterTimer,\n        maxWait: 2000\n    }, prefix){\n        this.nc = nc;\n        this.prefix = prefix;\n        this.opts = opts;\n    }\n    ping(name = \"\", id = \"\") {\n        return this.q(ServiceVerb.PING, name, id);\n    }\n    stats(name = \"\", id = \"\") {\n        return this.q(ServiceVerb.STATS, name, id);\n    }\n    info(name = \"\", id = \"\") {\n        return this.q(ServiceVerb.INFO, name, id);\n    }\n    async q(v, name = \"\", id = \"\") {\n        const iter = new QueuedIteratorImpl();\n        const jc = JSONCodec();\n        const subj = ServiceImpl.controlSubject(v, name, id, this.prefix);\n        const responses = await this.nc.requestMany(subj, Empty, this.opts);\n        (async ()=>{\n            for await (const m of responses){\n                try {\n                    const s = jc.decode(m.data);\n                    iter.push(s);\n                } catch (err) {\n                    iter.push(()=>{\n                        iter.stop(err);\n                    });\n                }\n            }\n            iter.push(()=>{\n                iter.stop();\n            });\n        })().catch((err)=>{\n            iter.stop(err);\n        });\n        return iter;\n    }\n}\nclass Metric {\n    name;\n    duration;\n    date;\n    payload;\n    msgs;\n    lang;\n    version;\n    bytes;\n    asyncRequests;\n    min;\n    max;\n    constructor(name, duration){\n        this.name = name;\n        this.duration = duration;\n        this.date = Date.now();\n        this.payload = 0;\n        this.msgs = 0;\n        this.bytes = 0;\n    }\n    toString() {\n        const sec = this.duration / 1000;\n        const mps = Math.round(this.msgs / sec);\n        const label = this.asyncRequests ? \"asyncRequests\" : \"\";\n        let minmax = \"\";\n        if (this.max) {\n            minmax = `${this.min}/${this.max}`;\n        }\n        return `${this.name}${label ? \" [asyncRequests]\" : \"\"} ${humanizeNumber(mps)} msgs/sec - [${sec.toFixed(2)} secs] ~ ${throughput(this.bytes, sec)} ${minmax}`;\n    }\n    toCsv() {\n        return `\"${this.name}\",${new Date(this.date).toISOString()},${this.lang},${this.version},${this.msgs},${this.payload},${this.bytes},${this.duration},${this.asyncRequests ? this.asyncRequests : false}\\n`;\n    }\n    static header() {\n        return `Test,Date,Lang,Version,Count,MsgPayload,Bytes,Millis,Async\\n`;\n    }\n}\nclass Bench {\n    nc;\n    callbacks;\n    msgs;\n    size;\n    subject;\n    asyncRequests;\n    pub;\n    sub;\n    req;\n    rep;\n    perf;\n    payload;\n    constructor(nc, opts = {\n        msgs: 100000,\n        size: 128,\n        subject: \"\",\n        asyncRequests: false,\n        pub: false,\n        sub: false,\n        req: false,\n        rep: false\n    }){\n        this.nc = nc;\n        this.callbacks = opts.callbacks || false;\n        this.msgs = opts.msgs || 0;\n        this.size = opts.size || 0;\n        this.subject = opts.subject || nuid.next();\n        this.asyncRequests = opts.asyncRequests || false;\n        this.pub = opts.pub || false;\n        this.sub = opts.sub || false;\n        this.req = opts.req || false;\n        this.rep = opts.rep || false;\n        this.perf = new Perf();\n        this.payload = this.size ? new Uint8Array(this.size) : Empty;\n        if (!this.pub && !this.sub && !this.req && !this.rep) {\n            throw new Error(\"no bench option selected\");\n        }\n    }\n    async run() {\n        this.nc.closed().then((err)=>{\n            if (err) {\n                throw new NatsError(`bench closed with an error: ${err.message}`, ErrorCode.Unknown, err);\n            }\n        });\n        if (this.callbacks) {\n            await this.runCallbacks();\n        } else {\n            await this.runAsync();\n        }\n        return this.processMetrics();\n    }\n    processMetrics() {\n        const nc = this.nc;\n        const { lang, version } = nc.protocol.transport;\n        if (this.pub && this.sub) {\n            this.perf.measure(\"pubsub\", \"pubStart\", \"subStop\");\n        }\n        if (this.req && this.rep) {\n            this.perf.measure(\"reqrep\", \"reqStart\", \"reqStop\");\n        }\n        const measures = this.perf.getEntries();\n        const pubsub = measures.find((m)=>m.name === \"pubsub\");\n        const reqrep = measures.find((m)=>m.name === \"reqrep\");\n        const req = measures.find((m)=>m.name === \"req\");\n        const rep = measures.find((m)=>m.name === \"rep\");\n        const pub = measures.find((m)=>m.name === \"pub\");\n        const sub = measures.find((m)=>m.name === \"sub\");\n        const stats = this.nc.stats();\n        const metrics = [];\n        if (pubsub) {\n            const { name, duration } = pubsub;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs * 2;\n            m.bytes = stats.inBytes + stats.outBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        if (reqrep) {\n            const { name, duration } = reqrep;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs * 2;\n            m.bytes = stats.inBytes + stats.outBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        if (pub) {\n            const { name, duration } = pub;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs;\n            m.bytes = stats.outBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        if (sub) {\n            const { name, duration } = sub;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs;\n            m.bytes = stats.inBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        if (rep) {\n            const { name, duration } = rep;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs;\n            m.bytes = stats.inBytes + stats.outBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        if (req) {\n            const { name, duration } = req;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs;\n            m.bytes = stats.inBytes + stats.outBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        return metrics;\n    }\n    async runCallbacks() {\n        const jobs = [];\n        if (this.sub) {\n            const d = deferred();\n            jobs.push(d);\n            let i = 0;\n            this.nc.subscribe(this.subject, {\n                max: this.msgs,\n                callback: ()=>{\n                    i++;\n                    if (i === 1) {\n                        this.perf.mark(\"subStart\");\n                    }\n                    if (i === this.msgs) {\n                        this.perf.mark(\"subStop\");\n                        this.perf.measure(\"sub\", \"subStart\", \"subStop\");\n                        d.resolve();\n                    }\n                }\n            });\n        }\n        if (this.rep) {\n            const d = deferred();\n            jobs.push(d);\n            let i = 0;\n            this.nc.subscribe(this.subject, {\n                max: this.msgs,\n                callback: (_, m)=>{\n                    m.respond(this.payload);\n                    i++;\n                    if (i === 1) {\n                        this.perf.mark(\"repStart\");\n                    }\n                    if (i === this.msgs) {\n                        this.perf.mark(\"repStop\");\n                        this.perf.measure(\"rep\", \"repStart\", \"repStop\");\n                        d.resolve();\n                    }\n                }\n            });\n        }\n        if (this.pub) {\n            const job = (async ()=>{\n                this.perf.mark(\"pubStart\");\n                for(let i = 0; i < this.msgs; i++){\n                    this.nc.publish(this.subject, this.payload);\n                }\n                await this.nc.flush();\n                this.perf.mark(\"pubStop\");\n                this.perf.measure(\"pub\", \"pubStart\", \"pubStop\");\n            })();\n            jobs.push(job);\n        }\n        if (this.req) {\n            const job = (async ()=>{\n                if (this.asyncRequests) {\n                    this.perf.mark(\"reqStart\");\n                    const a = [];\n                    for(let i = 0; i < this.msgs; i++){\n                        a.push(this.nc.request(this.subject, this.payload, {\n                            timeout: 20000\n                        }));\n                    }\n                    await Promise.all(a);\n                    this.perf.mark(\"reqStop\");\n                    this.perf.measure(\"req\", \"reqStart\", \"reqStop\");\n                } else {\n                    this.perf.mark(\"reqStart\");\n                    for(let i = 0; i < this.msgs; i++){\n                        await this.nc.request(this.subject);\n                    }\n                    this.perf.mark(\"reqStop\");\n                    this.perf.measure(\"req\", \"reqStart\", \"reqStop\");\n                }\n            })();\n            jobs.push(job);\n        }\n        await Promise.all(jobs);\n    }\n    async runAsync() {\n        const jobs = [];\n        if (this.rep) {\n            let first = false;\n            const sub = this.nc.subscribe(this.subject, {\n                max: this.msgs\n            });\n            const job = (async ()=>{\n                for await (const m of sub){\n                    if (!first) {\n                        this.perf.mark(\"repStart\");\n                        first = true;\n                    }\n                    m.respond(this.payload);\n                }\n                await this.nc.flush();\n                this.perf.mark(\"repStop\");\n                this.perf.measure(\"rep\", \"repStart\", \"repStop\");\n            })();\n            jobs.push(job);\n        }\n        if (this.sub) {\n            let first = false;\n            const sub = this.nc.subscribe(this.subject, {\n                max: this.msgs\n            });\n            const job = (async ()=>{\n                for await (const _m of sub){\n                    if (!first) {\n                        this.perf.mark(\"subStart\");\n                        first = true;\n                    }\n                }\n                this.perf.mark(\"subStop\");\n                this.perf.measure(\"sub\", \"subStart\", \"subStop\");\n            })();\n            jobs.push(job);\n        }\n        if (this.pub) {\n            const job = (async ()=>{\n                this.perf.mark(\"pubStart\");\n                for(let i = 0; i < this.msgs; i++){\n                    this.nc.publish(this.subject, this.payload);\n                }\n                await this.nc.flush();\n                this.perf.mark(\"pubStop\");\n                this.perf.measure(\"pub\", \"pubStart\", \"pubStop\");\n            })();\n            jobs.push(job);\n        }\n        if (this.req) {\n            const job = (async ()=>{\n                if (this.asyncRequests) {\n                    this.perf.mark(\"reqStart\");\n                    const a = [];\n                    for(let i = 0; i < this.msgs; i++){\n                        a.push(this.nc.request(this.subject, this.payload, {\n                            timeout: 20000\n                        }));\n                    }\n                    await Promise.all(a);\n                    this.perf.mark(\"reqStop\");\n                    this.perf.measure(\"req\", \"reqStart\", \"reqStop\");\n                } else {\n                    this.perf.mark(\"reqStart\");\n                    for(let i = 0; i < this.msgs; i++){\n                        await this.nc.request(this.subject);\n                    }\n                    this.perf.mark(\"reqStop\");\n                    this.perf.measure(\"req\", \"reqStart\", \"reqStop\");\n                }\n            })();\n            jobs.push(job);\n        }\n        await Promise.all(jobs);\n    }\n}\nfunction throughput(bytes, seconds) {\n    return `${humanizeBytes(bytes / seconds)}/sec`;\n}\nfunction humanizeBytes(bytes, si = false) {\n    const base = si ? 1000 : 1024;\n    const pre = si ? [\n        \"k\",\n        \"M\",\n        \"G\",\n        \"T\",\n        \"P\",\n        \"E\"\n    ] : [\n        \"K\",\n        \"M\",\n        \"G\",\n        \"T\",\n        \"P\",\n        \"E\"\n    ];\n    const post = si ? \"iB\" : \"B\";\n    if (bytes < base) {\n        return `${bytes.toFixed(2)} ${post}`;\n    }\n    const exp = parseInt(Math.log(bytes) / Math.log(base) + \"\");\n    const index = parseInt(exp - 1 + \"\");\n    return `${(bytes / Math.pow(base, exp)).toFixed(2)} ${pre[index]}${post}`;\n}\nfunction humanizeNumber(n) {\n    return n.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n}\n\nfunction NoopKvCodecs() {\n    return {\n        key: {\n            encode (k) {\n                return k;\n            },\n            decode (k) {\n                return k;\n            }\n        },\n        value: {\n            encode (v) {\n                return v;\n            },\n            decode (v) {\n                return v;\n            }\n        }\n    };\n}\nfunction defaultBucketOpts() {\n    return {\n        replicas: 1,\n        history: 1,\n        timeout: 2000,\n        max_bytes: -1,\n        maxValueSize: -1,\n        codec: NoopKvCodecs(),\n        storage: StorageType.File\n    };\n}\nconst kvOperationHdr = \"KV-Operation\";\nconst kvSubjectPrefix = \"$KV\";\nconst validKeyRe = /^[-/=.\\w]+$/;\nconst validSearchKey = /^[-/=.>*\\w]+$/;\nconst validBucketRe = /^[-\\w]+$/;\nfunction validateKey(k) {\n    if (k.startsWith(\".\") || k.endsWith(\".\") || !validKeyRe.test(k)) {\n        throw new Error(`invalid key: ${k}`);\n    }\n}\nfunction validateSearchKey(k) {\n    if (k.startsWith(\".\") || k.endsWith(\".\") || !validSearchKey.test(k)) {\n        throw new Error(`invalid key: ${k}`);\n    }\n}\nfunction hasWildcards(k) {\n    if (k.startsWith(\".\") || k.endsWith(\".\")) {\n        throw new Error(`invalid key: ${k}`);\n    }\n    const chunks = k.split(\".\");\n    let hasWildcards = false;\n    for(let i = 0; i < chunks.length; i++){\n        switch(chunks[i]){\n            case \"*\":\n                hasWildcards = true;\n                break;\n            case \">\":\n                if (i !== chunks.length - 1) {\n                    throw new Error(`invalid key: ${k}`);\n                }\n                hasWildcards = true;\n                break;\n            default:\n        }\n    }\n    return hasWildcards;\n}\nfunction validateBucket(name) {\n    if (!validBucketRe.test(name)) {\n        throw new Error(`invalid bucket name: ${name}`);\n    }\n}\nvar PubHeaders;\n(function(PubHeaders) {\n    PubHeaders[\"MsgIdHdr\"] = \"Nats-Msg-Id\";\n    PubHeaders[\"ExpectedStreamHdr\"] = \"Nats-Expected-Stream\";\n    PubHeaders[\"ExpectedLastSeqHdr\"] = \"Nats-Expected-Last-Sequence\";\n    PubHeaders[\"ExpectedLastMsgIdHdr\"] = \"Nats-Expected-Last-Msg-Id\";\n    PubHeaders[\"ExpectedLastSubjectSequenceHdr\"] = \"Nats-Expected-Last-Subject-Sequence\";\n})(PubHeaders || (PubHeaders = {}));\nclass Bucket {\n    js;\n    jsm;\n    stream;\n    bucket;\n    direct;\n    codec;\n    prefix;\n    editPrefix;\n    useJsPrefix;\n    _prefixLen;\n    constructor(bucket, js, jsm){\n        validateBucket(bucket);\n        this.js = js;\n        this.jsm = jsm;\n        this.bucket = bucket;\n        this.prefix = kvSubjectPrefix;\n        this.editPrefix = \"\";\n        this.useJsPrefix = false;\n        this._prefixLen = 0;\n    }\n    static async create(js, name, opts = {}) {\n        validateBucket(name);\n        const jsm = await js.jetstreamManager();\n        const bucket = new Bucket(name, js, jsm);\n        await bucket.init(opts);\n        return bucket;\n    }\n    static async bind(js, name, opts = {}) {\n        const jsm = await js.jetstreamManager();\n        const info = {\n            config: {\n                allow_direct: opts.allow_direct\n            }\n        };\n        validateBucket(name);\n        const bucket = new Bucket(name, js, jsm);\n        info.config.name = opts.streamName ?? bucket.bucketName();\n        Object.assign(bucket, info);\n        bucket.stream = info.config.name;\n        bucket.codec = opts.codec || NoopKvCodecs();\n        bucket.direct = info.config.allow_direct ?? false;\n        bucket.initializePrefixes(info);\n        return bucket;\n    }\n    async init(opts = {}) {\n        const bo = Object.assign(defaultBucketOpts(), opts);\n        this.codec = bo.codec;\n        const sc = {};\n        this.stream = sc.name = opts.streamName ?? this.bucketName();\n        sc.retention = RetentionPolicy.Limits;\n        sc.max_msgs_per_subject = bo.history;\n        if (bo.maxBucketSize) {\n            bo.max_bytes = bo.maxBucketSize;\n        }\n        if (bo.max_bytes) {\n            sc.max_bytes = bo.max_bytes;\n        }\n        sc.max_msg_size = bo.maxValueSize;\n        sc.storage = bo.storage;\n        const location = opts.placementCluster ?? \"\";\n        if (location) {\n            opts.placement = {};\n            opts.placement.cluster = location;\n            opts.placement.tags = [];\n        }\n        if (opts.placement) {\n            sc.placement = opts.placement;\n        }\n        if (opts.republish) {\n            sc.republish = opts.republish;\n        }\n        if (opts.description) {\n            sc.description = opts.description;\n        }\n        if (opts.mirror) {\n            const mirror = Object.assign({}, opts.mirror);\n            if (!mirror.name.startsWith(kvPrefix)) {\n                mirror.name = `${kvPrefix}${mirror.name}`;\n            }\n            sc.mirror = mirror;\n            sc.mirror_direct = true;\n        } else if (opts.sources) {\n            const sources = opts.sources.map((s)=>{\n                const c = Object.assign({}, s);\n                const srcBucketName = c.name.startsWith(kvPrefix) ? c.name.substring(kvPrefix.length) : c.name;\n                if (!c.name.startsWith(kvPrefix)) {\n                    c.name = `${kvPrefix}${c.name}`;\n                }\n                if (!s.external && srcBucketName !== this.bucket) {\n                    c.subject_transforms = [\n                        {\n                            src: `$KV.${srcBucketName}.>`,\n                            dest: `$KV.${this.bucket}.>`\n                        }\n                    ];\n                }\n                return c;\n            });\n            sc.sources = sources;\n            sc.subjects = [\n                this.subjectForBucket()\n            ];\n        } else {\n            sc.subjects = [\n                this.subjectForBucket()\n            ];\n        }\n        if (opts.metadata) {\n            sc.metadata = opts.metadata;\n        }\n        if (typeof opts.compression === \"boolean\") {\n            sc.compression = opts.compression ? StoreCompression.S2 : StoreCompression.None;\n        }\n        const nci = this.js.nc;\n        const have = nci.getServerVersion();\n        const discardNew = have ? compare(have, parseSemVer(\"2.7.2\")) >= 0 : false;\n        sc.discard = discardNew ? DiscardPolicy.New : DiscardPolicy.Old;\n        const { ok: direct, min } = nci.features.get(Feature.JS_ALLOW_DIRECT);\n        if (!direct && opts.allow_direct === true) {\n            const v = have ? `${have.major}.${have.minor}.${have.micro}` : \"unknown\";\n            return Promise.reject(new Error(`allow_direct is not available on server version ${v} - requires ${min}`));\n        }\n        opts.allow_direct = typeof opts.allow_direct === \"boolean\" ? opts.allow_direct : direct;\n        sc.allow_direct = opts.allow_direct;\n        this.direct = sc.allow_direct;\n        sc.num_replicas = bo.replicas;\n        if (bo.ttl) {\n            sc.max_age = nanos(bo.ttl);\n        }\n        sc.allow_rollup_hdrs = true;\n        let info;\n        try {\n            info = await this.jsm.streams.info(sc.name);\n            if (!info.config.allow_direct && this.direct === true) {\n                this.direct = false;\n            }\n        } catch (err) {\n            if (err.message === \"stream not found\") {\n                info = await this.jsm.streams.add(sc);\n            } else {\n                throw err;\n            }\n        }\n        this.initializePrefixes(info);\n    }\n    initializePrefixes(info) {\n        this._prefixLen = 0;\n        this.prefix = `$KV.${this.bucket}`;\n        this.useJsPrefix = this.js.apiPrefix !== \"$JS.API\";\n        const { mirror } = info.config;\n        if (mirror) {\n            let n = mirror.name;\n            if (n.startsWith(kvPrefix)) {\n                n = n.substring(kvPrefix.length);\n            }\n            if (mirror.external && mirror.external.api !== \"\") {\n                const mb = mirror.name.substring(kvPrefix.length);\n                this.useJsPrefix = false;\n                this.prefix = `$KV.${mb}`;\n                this.editPrefix = `${mirror.external.api}.$KV.${n}`;\n            } else {\n                this.editPrefix = this.prefix;\n            }\n        }\n    }\n    bucketName() {\n        return this.stream ?? `${kvPrefix}${this.bucket}`;\n    }\n    subjectForBucket() {\n        return `${this.prefix}.${this.bucket}.>`;\n    }\n    subjectForKey(k, edit = false) {\n        const builder = [];\n        if (edit) {\n            if (this.useJsPrefix) {\n                builder.push(this.js.apiPrefix);\n            }\n            if (this.editPrefix !== \"\") {\n                builder.push(this.editPrefix);\n            } else {\n                builder.push(this.prefix);\n            }\n        } else {\n            if (this.prefix) {\n                builder.push(this.prefix);\n            }\n        }\n        builder.push(k);\n        return builder.join(\".\");\n    }\n    fullKeyName(k) {\n        if (this.prefix !== \"\") {\n            return `${this.prefix}.${k}`;\n        }\n        return `${kvSubjectPrefix}.${this.bucket}.${k}`;\n    }\n    get prefixLen() {\n        if (this._prefixLen === 0) {\n            this._prefixLen = this.prefix.length + 1;\n        }\n        return this._prefixLen;\n    }\n    encodeKey(key) {\n        const chunks = [];\n        for (const t of key.split(\".\")){\n            switch(t){\n                case \">\":\n                case \"*\":\n                    chunks.push(t);\n                    break;\n                default:\n                    chunks.push(this.codec.key.encode(t));\n                    break;\n            }\n        }\n        return chunks.join(\".\");\n    }\n    decodeKey(ekey) {\n        const chunks = [];\n        for (const t of ekey.split(\".\")){\n            switch(t){\n                case \">\":\n                case \"*\":\n                    chunks.push(t);\n                    break;\n                default:\n                    chunks.push(this.codec.key.decode(t));\n                    break;\n            }\n        }\n        return chunks.join(\".\");\n    }\n    validateKey = validateKey;\n    validateSearchKey = validateSearchKey;\n    hasWildcards = hasWildcards;\n    close() {\n        return Promise.resolve();\n    }\n    dataLen(data, h) {\n        const slen = h ? h.get(JsHeaders.MessageSizeHdr) || \"\" : \"\";\n        if (slen !== \"\") {\n            return parseInt(slen, 10);\n        }\n        return data.length;\n    }\n    smToEntry(sm) {\n        return new KvStoredEntryImpl(this.bucket, this.prefixLen, sm);\n    }\n    jmToEntry(jm) {\n        const key = this.decodeKey(jm.subject.substring(this.prefixLen));\n        return new KvJsMsgEntryImpl(this.bucket, key, jm);\n    }\n    async create(k, data) {\n        let firstErr;\n        try {\n            const n = await this.put(k, data, {\n                previousSeq: 0\n            });\n            return Promise.resolve(n);\n        } catch (err) {\n            firstErr = err;\n            if (err?.api_error?.err_code !== 10071) {\n                return Promise.reject(err);\n            }\n        }\n        let rev = 0;\n        try {\n            const e = await this.get(k);\n            if (e?.operation === \"DEL\" || e?.operation === \"PURGE\") {\n                rev = e !== null ? e.revision : 0;\n                return this.update(k, data, rev);\n            } else {\n                return Promise.reject(firstErr);\n            }\n        } catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    update(k, data, version) {\n        if (version <= 0) {\n            throw new Error(\"version must be greater than 0\");\n        }\n        return this.put(k, data, {\n            previousSeq: version\n        });\n    }\n    async put(k, data, opts = {}) {\n        const ek = this.encodeKey(k);\n        this.validateKey(ek);\n        const o = {};\n        if (opts.previousSeq !== undefined) {\n            const h = headers();\n            o.headers = h;\n            h.set(PubHeaders.ExpectedLastSubjectSequenceHdr, `${opts.previousSeq}`);\n        }\n        try {\n            const pa = await this.js.publish(this.subjectForKey(ek, true), data, o);\n            return pa.seq;\n        } catch (err) {\n            const ne = err;\n            if (ne.isJetStreamError()) {\n                ne.message = ne.api_error?.description;\n                ne.code = `${ne.api_error?.code}`;\n                return Promise.reject(ne);\n            }\n            return Promise.reject(err);\n        }\n    }\n    async get(k, opts) {\n        const ek = this.encodeKey(k);\n        this.validateKey(ek);\n        let arg = {\n            last_by_subj: this.subjectForKey(ek)\n        };\n        if (opts && opts.revision > 0) {\n            arg = {\n                seq: opts.revision\n            };\n        }\n        let sm;\n        try {\n            if (this.direct) {\n                const direct = this.jsm.direct;\n                sm = await direct.getMessage(this.bucketName(), arg);\n            } else {\n                sm = await this.jsm.streams.getMessage(this.bucketName(), arg);\n            }\n            const ke = this.smToEntry(sm);\n            if (ke.key !== ek) {\n                return null;\n            }\n            return ke;\n        } catch (err) {\n            if (err.code === ErrorCode.JetStream404NoMessages) {\n                return null;\n            }\n            throw err;\n        }\n    }\n    purge(k, opts) {\n        return this._deleteOrPurge(k, \"PURGE\", opts);\n    }\n    delete(k, opts) {\n        return this._deleteOrPurge(k, \"DEL\", opts);\n    }\n    async purgeDeletes(olderMillis = 30 * 60 * 1000) {\n        const done = deferred();\n        const buf = [];\n        const i = await this.watch({\n            key: \">\",\n            initializedFn: ()=>{\n                done.resolve();\n            }\n        });\n        (async ()=>{\n            for await (const e of i){\n                if (e.operation === \"DEL\" || e.operation === \"PURGE\") {\n                    buf.push(e);\n                }\n            }\n        })().then();\n        await done;\n        i.stop();\n        const min = Date.now() - olderMillis;\n        const proms = buf.map((e)=>{\n            const subj = this.subjectForKey(e.key);\n            if (e.created.getTime() >= min) {\n                return this.jsm.streams.purge(this.stream, {\n                    filter: subj,\n                    keep: 1\n                });\n            } else {\n                return this.jsm.streams.purge(this.stream, {\n                    filter: subj,\n                    keep: 0\n                });\n            }\n        });\n        const purged = await Promise.all(proms);\n        purged.unshift({\n            success: true,\n            purged: 0\n        });\n        return purged.reduce((pv, cv)=>{\n            pv.purged += cv.purged;\n            return pv;\n        });\n    }\n    async _deleteOrPurge(k, op, opts) {\n        if (!this.hasWildcards(k)) {\n            return this._doDeleteOrPurge(k, op, opts);\n        }\n        const iter = await this.keys(k);\n        const buf = [];\n        for await (const k of iter){\n            buf.push(this._doDeleteOrPurge(k, op));\n            if (buf.length === 100) {\n                await Promise.all(buf);\n                buf.length = 0;\n            }\n        }\n        if (buf.length > 0) {\n            await Promise.all(buf);\n        }\n    }\n    async _doDeleteOrPurge(k, op, opts) {\n        const ek = this.encodeKey(k);\n        this.validateKey(ek);\n        const h = headers();\n        h.set(kvOperationHdr, op);\n        if (op === \"PURGE\") {\n            h.set(JsHeaders.RollupHdr, JsHeaders.RollupValueSubject);\n        }\n        if (opts?.previousSeq) {\n            h.set(PubHeaders.ExpectedLastSubjectSequenceHdr, `${opts.previousSeq}`);\n        }\n        await this.js.publish(this.subjectForKey(ek, true), Empty, {\n            headers: h\n        });\n    }\n    _buildCC(k, content, opts = {}) {\n        const a = !Array.isArray(k) ? [\n            k\n        ] : k;\n        let filter_subjects = a.map((k)=>{\n            const ek = this.encodeKey(k);\n            this.validateSearchKey(k);\n            return this.fullKeyName(ek);\n        });\n        let deliver_policy = DeliverPolicy.LastPerSubject;\n        if (content === KvWatchInclude.AllHistory) {\n            deliver_policy = DeliverPolicy.All;\n        }\n        if (content === KvWatchInclude.UpdatesOnly) {\n            deliver_policy = DeliverPolicy.New;\n        }\n        let filter_subject = undefined;\n        if (filter_subjects.length === 1) {\n            filter_subject = filter_subjects[0];\n            filter_subjects = undefined;\n        }\n        return Object.assign({\n            deliver_policy,\n            \"ack_policy\": AckPolicy.None,\n            filter_subjects,\n            filter_subject,\n            \"flow_control\": true,\n            \"idle_heartbeat\": nanos(5 * 1000)\n        }, opts);\n    }\n    remove(k) {\n        return this.purge(k);\n    }\n    async history(opts = {}) {\n        const k = opts.key ?? \">\";\n        const qi = new QueuedIteratorImpl();\n        const co = {};\n        co.headers_only = opts.headers_only || false;\n        let fn;\n        fn = ()=>{\n            qi.stop();\n        };\n        let count = 0;\n        const cc = this._buildCC(k, KvWatchInclude.AllHistory, co);\n        const subj = cc.filter_subject;\n        const copts = consumerOpts(cc);\n        copts.bindStream(this.stream);\n        copts.orderedConsumer();\n        copts.callback((err, jm)=>{\n            if (err) {\n                qi.stop(err);\n                return;\n            }\n            if (jm) {\n                const e = this.jmToEntry(jm);\n                qi.push(e);\n                qi.received++;\n                if (fn && count > 0 && qi.received >= count || jm.info.pending === 0) {\n                    qi.push(fn);\n                    fn = undefined;\n                }\n            }\n        });\n        const sub = await this.js.subscribe(subj, copts);\n        if (fn) {\n            const { info: { last } } = sub;\n            const expect = last.num_pending + last.delivered.consumer_seq;\n            if (expect === 0 || qi.received >= expect) {\n                try {\n                    fn();\n                } catch (err) {\n                    qi.stop(err);\n                } finally{\n                    fn = undefined;\n                }\n            } else {\n                count = expect;\n            }\n        }\n        qi._data = sub;\n        qi.iterClosed.then(()=>{\n            sub.unsubscribe();\n        });\n        sub.closed.then(()=>{\n            qi.stop();\n        }).catch((err)=>{\n            qi.stop(err);\n        });\n        return qi;\n    }\n    canSetWatcherName() {\n        const jsi = this.js;\n        const nci = jsi.nc;\n        const { ok } = nci.features.get(Feature.JS_NEW_CONSUMER_CREATE_API);\n        return ok;\n    }\n    async watch(opts = {}) {\n        const k = opts.key ?? \">\";\n        const qi = new QueuedIteratorImpl();\n        const co = {};\n        co.headers_only = opts.headers_only || false;\n        let content = KvWatchInclude.LastValue;\n        if (opts.include === KvWatchInclude.AllHistory) {\n            content = KvWatchInclude.AllHistory;\n        } else if (opts.include === KvWatchInclude.UpdatesOnly) {\n            content = KvWatchInclude.UpdatesOnly;\n        }\n        const ignoreDeletes = opts.ignoreDeletes === true;\n        let fn = opts.initializedFn;\n        let count = 0;\n        const cc = this._buildCC(k, content, co);\n        const subj = cc.filter_subject;\n        const copts = consumerOpts(cc);\n        if (this.canSetWatcherName()) {\n            copts.consumerName(nuid.next());\n        }\n        copts.bindStream(this.stream);\n        if (opts.resumeFromRevision && opts.resumeFromRevision > 0) {\n            copts.startSequence(opts.resumeFromRevision);\n        }\n        copts.orderedConsumer();\n        copts.callback((err, jm)=>{\n            if (err) {\n                qi.stop(err);\n                return;\n            }\n            if (jm) {\n                const e = this.jmToEntry(jm);\n                if (ignoreDeletes && e.operation === \"DEL\") {\n                    return;\n                }\n                qi.push(e);\n                qi.received++;\n                if (fn && (count > 0 && qi.received >= count || jm.info.pending === 0)) {\n                    qi.push(fn);\n                    fn = undefined;\n                }\n            }\n        });\n        const sub = await this.js.subscribe(subj, copts);\n        if (fn) {\n            const { info: { last } } = sub;\n            const expect = last.num_pending + last.delivered.consumer_seq;\n            if (expect === 0 || qi.received >= expect) {\n                try {\n                    fn();\n                } catch (err) {\n                    qi.stop(err);\n                } finally{\n                    fn = undefined;\n                }\n            } else {\n                count = expect;\n            }\n        }\n        qi._data = sub;\n        qi.iterClosed.then(()=>{\n            sub.unsubscribe();\n        });\n        sub.closed.then(()=>{\n            qi.stop();\n        }).catch((err)=>{\n            qi.stop(err);\n        });\n        return qi;\n    }\n    async keys(k = \">\") {\n        const keys = new QueuedIteratorImpl();\n        const cc = this._buildCC(k, KvWatchInclude.LastValue, {\n            headers_only: true\n        });\n        const subj = Array.isArray(k) ? \">\" : cc.filter_subject;\n        const copts = consumerOpts(cc);\n        copts.bindStream(this.stream);\n        copts.orderedConsumer();\n        const sub = await this.js.subscribe(subj, copts);\n        (async ()=>{\n            for await (const jm of sub){\n                const op = jm.headers?.get(kvOperationHdr);\n                if (op !== \"DEL\" && op !== \"PURGE\") {\n                    const key = this.decodeKey(jm.subject.substring(this.prefixLen));\n                    keys.push(key);\n                }\n                if (jm.info.pending === 0) {\n                    sub.unsubscribe();\n                }\n            }\n        })().then(()=>{\n            keys.stop();\n        }).catch((err)=>{\n            keys.stop(err);\n        });\n        const si = sub;\n        if (si.info.last.num_pending === 0) {\n            sub.unsubscribe();\n        }\n        return keys;\n    }\n    purgeBucket(opts) {\n        return this.jsm.streams.purge(this.bucketName(), opts);\n    }\n    destroy() {\n        return this.jsm.streams.delete(this.bucketName());\n    }\n    async status() {\n        const nc = this.js.nc;\n        const cluster = nc.info?.cluster ?? \"\";\n        const bn = this.bucketName();\n        const si = await this.jsm.streams.info(bn);\n        return new KvStatusImpl(si, cluster);\n    }\n}\nclass KvStatusImpl {\n    si;\n    cluster;\n    constructor(si, cluster = \"\"){\n        this.si = si;\n        this.cluster = cluster;\n    }\n    get bucket() {\n        return this.si.config.name.startsWith(kvPrefix) ? this.si.config.name.substring(kvPrefix.length) : this.si.config.name;\n    }\n    get values() {\n        return this.si.state.messages;\n    }\n    get history() {\n        return this.si.config.max_msgs_per_subject;\n    }\n    get ttl() {\n        return millis(this.si.config.max_age);\n    }\n    get bucket_location() {\n        return this.cluster;\n    }\n    get backingStore() {\n        return this.si.config.storage;\n    }\n    get storage() {\n        return this.si.config.storage;\n    }\n    get replicas() {\n        return this.si.config.num_replicas;\n    }\n    get description() {\n        return this.si.config.description ?? \"\";\n    }\n    get maxBucketSize() {\n        return this.si.config.max_bytes;\n    }\n    get maxValueSize() {\n        return this.si.config.max_msg_size;\n    }\n    get max_bytes() {\n        return this.si.config.max_bytes;\n    }\n    get placement() {\n        return this.si.config.placement || {\n            cluster: \"\",\n            tags: []\n        };\n    }\n    get placementCluster() {\n        return this.si.config.placement?.cluster ?? \"\";\n    }\n    get republish() {\n        return this.si.config.republish ?? {\n            src: \"\",\n            dest: \"\"\n        };\n    }\n    get streamInfo() {\n        return this.si;\n    }\n    get size() {\n        return this.si.state.bytes;\n    }\n    get metadata() {\n        return this.si.config.metadata ?? {};\n    }\n    get compression() {\n        if (this.si.config.compression) {\n            return this.si.config.compression !== StoreCompression.None;\n        }\n        return false;\n    }\n}\nconst osPrefix = \"OBJ_\";\nconst digestType = \"SHA-256=\";\nfunction objectStoreStreamName(bucket) {\n    validateBucket(bucket);\n    return `${osPrefix}${bucket}`;\n}\nfunction objectStoreBucketName(stream) {\n    if (stream.startsWith(osPrefix)) {\n        return stream.substring(4);\n    }\n    return stream;\n}\nclass ObjectStoreStatusImpl {\n    si;\n    backingStore;\n    constructor(si){\n        this.si = si;\n        this.backingStore = \"JetStream\";\n    }\n    get bucket() {\n        return objectStoreBucketName(this.si.config.name);\n    }\n    get description() {\n        return this.si.config.description ?? \"\";\n    }\n    get ttl() {\n        return this.si.config.max_age;\n    }\n    get storage() {\n        return this.si.config.storage;\n    }\n    get replicas() {\n        return this.si.config.num_replicas;\n    }\n    get sealed() {\n        return this.si.config.sealed;\n    }\n    get size() {\n        return this.si.state.bytes;\n    }\n    get streamInfo() {\n        return this.si;\n    }\n    get metadata() {\n        return this.si.config.metadata;\n    }\n    get compression() {\n        if (this.si.config.compression) {\n            return this.si.config.compression !== StoreCompression.None;\n        }\n        return false;\n    }\n}\nfunction convertStreamSourceDomain(s) {\n    if (s === undefined) {\n        return undefined;\n    }\n    const { domain } = s;\n    if (domain === undefined) {\n        return s;\n    }\n    const copy = Object.assign({}, s);\n    delete copy.domain;\n    if (domain === \"\") {\n        return copy;\n    }\n    if (copy.external) {\n        throw new Error(\"domain and external are both set\");\n    }\n    copy.external = {\n        api: `$JS.${domain}.API`\n    };\n    return copy;\n}\nvar PullConsumerType;\n(function(PullConsumerType) {\n    PullConsumerType[PullConsumerType[\"Unset\"] = -1] = \"Unset\";\n    PullConsumerType[PullConsumerType[\"Consume\"] = 0] = \"Consume\";\n    PullConsumerType[PullConsumerType[\"Fetch\"] = 1] = \"Fetch\";\n})(PullConsumerType || (PullConsumerType = {}));\nvar ConsumerEvents;\n(function(ConsumerEvents) {\n    ConsumerEvents[\"HeartbeatsMissed\"] = \"heartbeats_missed\";\n    ConsumerEvents[\"ConsumerNotFound\"] = \"consumer_not_found\";\n    ConsumerEvents[\"StreamNotFound\"] = \"stream_not_found\";\n    ConsumerEvents[\"ConsumerDeleted\"] = \"consumer_deleted\";\n    ConsumerEvents[\"OrderedConsumerRecreated\"] = \"ordered_consumer_recreated\";\n})(ConsumerEvents || (ConsumerEvents = {}));\nvar ConsumerDebugEvents;\n(function(ConsumerDebugEvents) {\n    ConsumerDebugEvents[\"DebugEvent\"] = \"debug\";\n    ConsumerDebugEvents[\"Discard\"] = \"discard\";\n    ConsumerDebugEvents[\"Reset\"] = \"reset\";\n    ConsumerDebugEvents[\"Next\"] = \"next\";\n})(ConsumerDebugEvents || (ConsumerDebugEvents = {}));\nconst ACK = Uint8Array.of(43, 65, 67, 75);\nconst NAK = Uint8Array.of(45, 78, 65, 75);\nconst WPI = Uint8Array.of(43, 87, 80, 73);\nconst NXT = Uint8Array.of(43, 78, 88, 84);\nconst TERM = Uint8Array.of(43, 84, 69, 82, 77);\nconst SPACE = Uint8Array.of(32);\nfunction toJsMsg(m, ackTimeout = 5000) {\n    return new JsMsgImpl(m, ackTimeout);\n}\nclass PullConsumerMessagesImpl extends QueuedIteratorImpl {\n    consumer;\n    opts;\n    sub;\n    monitor;\n    pending;\n    inbox;\n    refilling;\n    pong;\n    callback;\n    timeout;\n    cleanupHandler;\n    listeners;\n    statusIterator;\n    forOrderedConsumer;\n    resetHandler;\n    abortOnMissingResource;\n    bind;\n    constructor(c, opts, refilling = false){\n        super();\n        this.consumer = c;\n        const copts = opts;\n        this.opts = this.parseOptions(opts, refilling);\n        this.callback = copts.callback || null;\n        this.noIterator = typeof this.callback === \"function\";\n        this.monitor = null;\n        this.pong = null;\n        this.pending = {\n            msgs: 0,\n            bytes: 0,\n            requests: 0\n        };\n        this.refilling = refilling;\n        this.timeout = null;\n        this.inbox = createInbox(c.api.nc.options.inboxPrefix);\n        this.listeners = [];\n        this.forOrderedConsumer = false;\n        this.abortOnMissingResource = copts.abort_on_missing_resource === true;\n        this.bind = copts.bind === true;\n        this.start();\n    }\n    start() {\n        const { max_messages, max_bytes, idle_heartbeat, threshold_bytes, threshold_messages } = this.opts;\n        this.closed().then((err)=>{\n            if (this.cleanupHandler) {\n                try {\n                    this.cleanupHandler(err);\n                } catch (_err) {}\n            }\n        });\n        const { sub } = this;\n        if (sub) {\n            sub.unsubscribe();\n        }\n        this.sub = this.consumer.api.nc.subscribe(this.inbox, {\n            callback: (err, msg)=>{\n                if (err) {\n                    this.stop(err);\n                    return;\n                }\n                this.monitor?.work();\n                const isProtocol = msg.subject === this.inbox;\n                if (isProtocol) {\n                    if (isHeartbeatMsg(msg)) {\n                        return;\n                    }\n                    const code = msg.headers?.code;\n                    const description = msg.headers?.description?.toLowerCase() || \"unknown\";\n                    const { msgsLeft, bytesLeft } = this.parseDiscard(msg.headers);\n                    if (msgsLeft > 0 || bytesLeft > 0) {\n                        this.pending.msgs -= msgsLeft;\n                        this.pending.bytes -= bytesLeft;\n                        this.pending.requests--;\n                        this.notify(ConsumerDebugEvents.Discard, {\n                            msgsLeft,\n                            bytesLeft\n                        });\n                    } else {\n                        if (code === 400) {\n                            this.stop(new NatsError(description, `${code}`));\n                            return;\n                        } else if (code === 409 && description === \"consumer deleted\") {\n                            this.notify(ConsumerEvents.ConsumerDeleted, `${code} ${description}`);\n                            if (!this.refilling || this.abortOnMissingResource) {\n                                const error = new NatsError(description, `${code}`);\n                                this.stop(error);\n                                return;\n                            }\n                        } else {\n                            this.notify(ConsumerDebugEvents.DebugEvent, `${code} ${description}`);\n                        }\n                    }\n                } else {\n                    this._push(toJsMsg(msg, this.consumer.api.timeout));\n                    this.received++;\n                    if (this.pending.msgs) {\n                        this.pending.msgs--;\n                    }\n                    if (this.pending.bytes) {\n                        this.pending.bytes -= msg.size();\n                    }\n                }\n                if (this.pending.msgs === 0 && this.pending.bytes === 0) {\n                    this.pending.requests = 0;\n                }\n                if (this.refilling) {\n                    if (max_messages && this.pending.msgs <= threshold_messages || max_bytes && this.pending.bytes <= threshold_bytes) {\n                        const batch = this.pullOptions();\n                        this.pull(batch);\n                    }\n                } else if (this.pending.requests === 0) {\n                    this._push(()=>{\n                        this.stop();\n                    });\n                }\n            }\n        });\n        this.sub.closed.then(()=>{\n            if (this.sub.draining) {\n                this._push(()=>{\n                    this.stop();\n                });\n            }\n        });\n        if (idle_heartbeat) {\n            this.monitor = new IdleHeartbeatMonitor(idle_heartbeat, (data)=>{\n                this.notify(ConsumerEvents.HeartbeatsMissed, data);\n                this.resetPending().then(()=>{}).catch(()=>{});\n                return false;\n            }, {\n                maxOut: 2\n            });\n        }\n        (async ()=>{\n            const status = this.consumer.api.nc.status();\n            this.statusIterator = status;\n            for await (const s of status){\n                switch(s.type){\n                    case Events.Disconnect:\n                        this.monitor?.cancel();\n                        break;\n                    case Events.Reconnect:\n                        this.resetPending().then((ok)=>{\n                            if (ok) {\n                                this.monitor?.restart();\n                            }\n                        }).catch(()=>{});\n                        break;\n                    default:\n                }\n            }\n        })();\n        this.pull(this.pullOptions());\n    }\n    _push(r) {\n        if (!this.callback) {\n            super.push(r);\n        } else {\n            const fn = typeof r === \"function\" ? r : null;\n            try {\n                if (!fn) {\n                    this.callback(r);\n                } else {\n                    fn();\n                }\n            } catch (err) {\n                this.stop(err);\n            }\n        }\n    }\n    notify(type, data) {\n        if (this.listeners.length > 0) {\n            (()=>{\n                this.listeners.forEach((l)=>{\n                    if (!l.done) {\n                        l.push({\n                            type,\n                            data\n                        });\n                    }\n                });\n            })();\n        }\n    }\n    resetPending() {\n        return this.bind ? this.resetPendingNoInfo() : this.resetPendingWithInfo();\n    }\n    resetPendingNoInfo() {\n        this.pending.msgs = 0;\n        this.pending.bytes = 0;\n        this.pending.requests = 0;\n        this.pull(this.pullOptions());\n        return Promise.resolve(true);\n    }\n    async resetPendingWithInfo() {\n        let notFound = 0;\n        let streamNotFound = 0;\n        const bo = backoff();\n        let attempt = 0;\n        while(true){\n            if (this.done) {\n                return false;\n            }\n            if (this.consumer.api.nc.isClosed()) {\n                console.error(\"aborting resetPending - connection is closed\");\n                return false;\n            }\n            try {\n                await this.consumer.info();\n                notFound = 0;\n                this.pending.msgs = 0;\n                this.pending.bytes = 0;\n                this.pending.requests = 0;\n                this.pull(this.pullOptions());\n                return true;\n            } catch (err) {\n                if (err.message === \"stream not found\") {\n                    streamNotFound++;\n                    this.notify(ConsumerEvents.StreamNotFound, streamNotFound);\n                    if (!this.refilling || this.abortOnMissingResource) {\n                        this.stop(err);\n                        return false;\n                    }\n                } else if (err.message === \"consumer not found\") {\n                    notFound++;\n                    this.notify(ConsumerEvents.ConsumerNotFound, notFound);\n                    if (this.resetHandler) {\n                        try {\n                            this.resetHandler();\n                        } catch (_) {}\n                    }\n                    if (!this.refilling || this.abortOnMissingResource) {\n                        this.stop(err);\n                        return false;\n                    }\n                    if (this.forOrderedConsumer) {\n                        return false;\n                    }\n                } else {\n                    notFound = 0;\n                    streamNotFound = 0;\n                }\n                const to = bo.backoff(attempt);\n                const de = delay(to);\n                await Promise.race([\n                    de,\n                    this.consumer.api.nc.closed()\n                ]);\n                de.cancel();\n                attempt++;\n            }\n        }\n    }\n    pull(opts) {\n        this.pending.bytes += opts.max_bytes ?? 0;\n        this.pending.msgs += opts.batch ?? 0;\n        this.pending.requests++;\n        const nc = this.consumer.api.nc;\n        this._push(()=>{\n            nc.publish(`${this.consumer.api.prefix}.CONSUMER.MSG.NEXT.${this.consumer.stream}.${this.consumer.name}`, this.consumer.api.jc.encode(opts), {\n                reply: this.inbox\n            });\n            this.notify(ConsumerDebugEvents.Next, opts);\n        });\n    }\n    pullOptions() {\n        const batch = this.opts.max_messages - this.pending.msgs;\n        const max_bytes = this.opts.max_bytes - this.pending.bytes;\n        const idle_heartbeat = nanos(this.opts.idle_heartbeat);\n        const expires = nanos(this.opts.expires);\n        return {\n            batch,\n            max_bytes,\n            idle_heartbeat,\n            expires\n        };\n    }\n    parseDiscard(headers) {\n        const discard = {\n            msgsLeft: 0,\n            bytesLeft: 0\n        };\n        const msgsLeft = headers?.get(JsHeaders.PendingMessagesHdr);\n        if (msgsLeft) {\n            discard.msgsLeft = parseInt(msgsLeft);\n        }\n        const bytesLeft = headers?.get(JsHeaders.PendingBytesHdr);\n        if (bytesLeft) {\n            discard.bytesLeft = parseInt(bytesLeft);\n        }\n        return discard;\n    }\n    trackTimeout(t) {\n        this.timeout = t;\n    }\n    close() {\n        this.stop();\n        return this.iterClosed;\n    }\n    closed() {\n        return this.iterClosed;\n    }\n    clearTimers() {\n        this.monitor?.cancel();\n        this.monitor = null;\n        this.timeout?.cancel();\n        this.timeout = null;\n    }\n    setCleanupHandler(fn) {\n        this.cleanupHandler = fn;\n    }\n    stop(err) {\n        if (this.done) {\n            return;\n        }\n        this.sub?.unsubscribe();\n        this.clearTimers();\n        this.statusIterator?.stop();\n        this._push(()=>{\n            super.stop(err);\n            this.listeners.forEach((n)=>{\n                n.stop();\n            });\n        });\n    }\n    parseOptions(opts, refilling = false) {\n        const args = opts || {};\n        args.max_messages = args.max_messages || 0;\n        args.max_bytes = args.max_bytes || 0;\n        if (args.max_messages !== 0 && args.max_bytes !== 0) {\n            throw new Error(`only specify one of max_messages or max_bytes`);\n        }\n        if (args.max_messages === 0) {\n            args.max_messages = 100;\n        }\n        args.expires = args.expires || 30_000;\n        if (args.expires < 1000) {\n            throw new Error(\"expires should be at least 1000ms\");\n        }\n        args.idle_heartbeat = args.idle_heartbeat || args.expires / 2;\n        args.idle_heartbeat = args.idle_heartbeat > 30_000 ? 30_000 : args.idle_heartbeat;\n        if (refilling) {\n            const minMsgs = Math.round(args.max_messages * .75) || 1;\n            args.threshold_messages = args.threshold_messages || minMsgs;\n            const minBytes = Math.round(args.max_bytes * .75) || 1;\n            args.threshold_bytes = args.threshold_bytes || minBytes;\n        }\n        return args;\n    }\n    status() {\n        const iter = new QueuedIteratorImpl();\n        this.listeners.push(iter);\n        return Promise.resolve(iter);\n    }\n}\nclass OrderedConsumerMessages extends QueuedIteratorImpl {\n    src;\n    listeners;\n    constructor(){\n        super();\n        this.listeners = [];\n    }\n    setSource(src) {\n        if (this.src) {\n            this.src.resetHandler = undefined;\n            this.src.setCleanupHandler();\n            this.src.stop();\n        }\n        this.src = src;\n        this.src.setCleanupHandler((err)=>{\n            this.stop(err || undefined);\n        });\n        (async ()=>{\n            const status = await this.src.status();\n            for await (const s of status){\n                this.notify(s.type, s.data);\n            }\n        })().catch(()=>{});\n    }\n    notify(type, data) {\n        if (this.listeners.length > 0) {\n            (()=>{\n                this.listeners.forEach((l)=>{\n                    if (!l.done) {\n                        l.push({\n                            type,\n                            data\n                        });\n                    }\n                });\n            })();\n        }\n    }\n    stop(err) {\n        if (this.done) {\n            return;\n        }\n        this.src?.stop(err);\n        super.stop(err);\n        this.listeners.forEach((n)=>{\n            n.stop();\n        });\n    }\n    close() {\n        this.stop();\n        return this.iterClosed;\n    }\n    closed() {\n        return this.iterClosed;\n    }\n    status() {\n        const iter = new QueuedIteratorImpl();\n        this.listeners.push(iter);\n        return Promise.resolve(iter);\n    }\n}\nclass PullConsumerImpl {\n    api;\n    _info;\n    stream;\n    name;\n    constructor(api, info){\n        this.api = api;\n        this._info = info;\n        this.stream = info.stream_name;\n        this.name = info.name;\n    }\n    consume(opts = {\n        max_messages: 100,\n        expires: 30_000\n    }) {\n        return Promise.resolve(new PullConsumerMessagesImpl(this, opts, true));\n    }\n    fetch(opts = {\n        max_messages: 100,\n        expires: 30_000\n    }) {\n        const m = new PullConsumerMessagesImpl(this, opts, false);\n        const to = Math.round(m.opts.expires * 1.05);\n        const timer = timeout(to);\n        m.closed().catch(()=>{}).finally(()=>{\n            timer.cancel();\n        });\n        timer.catch(()=>{\n            m.close().catch();\n        });\n        m.trackTimeout(timer);\n        return Promise.resolve(m);\n    }\n    next(opts = {\n        expires: 30_000\n    }) {\n        const d = deferred();\n        const fopts = opts;\n        fopts.max_messages = 1;\n        const iter = new PullConsumerMessagesImpl(this, fopts, false);\n        const to = Math.round(iter.opts.expires * 1.05);\n        if (to >= 60_000) {\n            (async ()=>{\n                for await (const s of (await iter.status())){\n                    if (s.type === ConsumerEvents.HeartbeatsMissed && s.data >= 2) {\n                        d.reject(new Error(\"consumer missed heartbeats\"));\n                        break;\n                    }\n                }\n            })().catch();\n        }\n        (async ()=>{\n            for await (const m of iter){\n                d.resolve(m);\n                break;\n            }\n        })().catch(()=>{});\n        const timer = timeout(to);\n        iter.closed().then((err)=>{\n            err ? d.reject(err) : d.resolve(null);\n        }).catch((err)=>{\n            d.reject(err);\n        }).finally(()=>{\n            timer.cancel();\n        });\n        timer.catch((_err)=>{\n            d.resolve(null);\n            iter.close().catch();\n        });\n        iter.trackTimeout(timer);\n        return d;\n    }\n    delete() {\n        const { stream_name, name } = this._info;\n        return this.api.delete(stream_name, name);\n    }\n    info(cached = false) {\n        if (cached) {\n            return Promise.resolve(this._info);\n        }\n        const { stream_name, name } = this._info;\n        return this.api.info(stream_name, name).then((ci)=>{\n            this._info = ci;\n            return this._info;\n        });\n    }\n}\nclass OrderedPullConsumerImpl {\n    api;\n    consumerOpts;\n    consumer;\n    opts;\n    cursor;\n    stream;\n    namePrefix;\n    serial;\n    currentConsumer;\n    userCallback;\n    iter;\n    type;\n    startSeq;\n    constructor(api, stream, opts = {}){\n        this.api = api;\n        this.stream = stream;\n        this.cursor = {\n            stream_seq: 1,\n            deliver_seq: 0\n        };\n        this.namePrefix = nuid.next();\n        if (typeof opts.name_prefix === \"string\") {\n            minValidation(\"name_prefix\", opts.name_prefix);\n            this.namePrefix = opts.name_prefix + this.namePrefix;\n        }\n        this.serial = 0;\n        this.currentConsumer = null;\n        this.userCallback = null;\n        this.iter = null;\n        this.type = PullConsumerType.Unset;\n        this.consumerOpts = opts;\n        this.startSeq = this.consumerOpts.opt_start_seq || 0;\n        this.cursor.stream_seq = this.startSeq > 0 ? this.startSeq - 1 : 0;\n    }\n    getConsumerOpts(seq) {\n        this.serial++;\n        const name = `${this.namePrefix}_${this.serial}`;\n        seq = seq === 0 ? 1 : seq;\n        const config = {\n            name,\n            deliver_policy: DeliverPolicy.StartSequence,\n            opt_start_seq: seq,\n            ack_policy: AckPolicy.None,\n            inactive_threshold: nanos(5 * 60 * 1000),\n            num_replicas: 1\n        };\n        if (this.consumerOpts.headers_only === true) {\n            config.headers_only = true;\n        }\n        if (Array.isArray(this.consumerOpts.filterSubjects)) {\n            config.filter_subjects = this.consumerOpts.filterSubjects;\n        }\n        if (typeof this.consumerOpts.filterSubjects === \"string\") {\n            config.filter_subject = this.consumerOpts.filterSubjects;\n        }\n        if (this.consumerOpts.replay_policy) {\n            config.replay_policy = this.consumerOpts.replay_policy;\n        }\n        if (seq === this.startSeq + 1) {\n            config.deliver_policy = this.consumerOpts.deliver_policy || DeliverPolicy.StartSequence;\n            if (this.consumerOpts.deliver_policy === DeliverPolicy.LastPerSubject || this.consumerOpts.deliver_policy === DeliverPolicy.New || this.consumerOpts.deliver_policy === DeliverPolicy.Last) {\n                delete config.opt_start_seq;\n                config.deliver_policy = this.consumerOpts.deliver_policy;\n            }\n            if (config.deliver_policy === DeliverPolicy.LastPerSubject) {\n                if (typeof config.filter_subjects === \"undefined\" && typeof config.filter_subject === \"undefined\") {\n                    config.filter_subject = \">\";\n                }\n            }\n            if (this.consumerOpts.opt_start_time) {\n                delete config.opt_start_seq;\n                config.deliver_policy = DeliverPolicy.StartTime;\n                config.opt_start_time = this.consumerOpts.opt_start_time;\n            }\n            if (this.consumerOpts.inactive_threshold) {\n                config.inactive_threshold = nanos(this.consumerOpts.inactive_threshold);\n            }\n        }\n        return config;\n    }\n    async resetConsumer(seq = 0) {\n        this.consumer?.delete().catch(()=>{});\n        seq = seq === 0 ? 1 : seq;\n        this.cursor.deliver_seq = 0;\n        const config = this.getConsumerOpts(seq);\n        config.max_deliver = 1;\n        config.mem_storage = true;\n        const bo = backoff();\n        let ci;\n        for(let i = 0;; i++){\n            try {\n                ci = await this.api.add(this.stream, config);\n                this.iter?.notify(ConsumerEvents.OrderedConsumerRecreated, ci.name);\n                break;\n            } catch (err) {\n                if (err.message === \"stream not found\") {\n                    this.iter?.notify(ConsumerEvents.StreamNotFound, i);\n                    if (this.type === PullConsumerType.Fetch || this.opts.abort_on_missing_resource === true) {\n                        this.iter?.stop(err);\n                        return Promise.reject(err);\n                    }\n                }\n                if (seq === 0 && i >= 30) {\n                    throw err;\n                } else {\n                    await delay(bo.backoff(i + 1));\n                }\n            }\n        }\n        return ci;\n    }\n    internalHandler(serial) {\n        return (m)=>{\n            if (this.serial !== serial) {\n                return;\n            }\n            const dseq = m.info.deliverySequence;\n            if (dseq !== this.cursor.deliver_seq + 1) {\n                this.notifyOrderedResetAndReset();\n                return;\n            }\n            this.cursor.deliver_seq = dseq;\n            this.cursor.stream_seq = m.info.streamSequence;\n            if (this.userCallback) {\n                this.userCallback(m);\n            } else {\n                this.iter?.push(m);\n            }\n        };\n    }\n    async reset(opts = {\n        max_messages: 100,\n        expires: 30_000\n    }, info) {\n        info = info || {};\n        const fromFetch = info.fromFetch || false;\n        const orderedReset = info.orderedReset || false;\n        if (this.type === PullConsumerType.Fetch && orderedReset) {\n            this.iter?.src.stop();\n            await this.iter?.closed();\n            this.currentConsumer = null;\n            return;\n        }\n        if (this.currentConsumer === null || orderedReset) {\n            this.currentConsumer = await this.resetConsumer(this.cursor.stream_seq + 1);\n        }\n        if (this.iter === null || fromFetch) {\n            this.iter = new OrderedConsumerMessages();\n        }\n        this.consumer = new PullConsumerImpl(this.api, this.currentConsumer);\n        const copts = opts;\n        copts.callback = this.internalHandler(this.serial);\n        let msgs = null;\n        if (this.type === PullConsumerType.Fetch && fromFetch) {\n            msgs = await this.consumer.fetch(opts);\n        } else if (this.type === PullConsumerType.Consume) {\n            msgs = await this.consumer.consume(opts);\n        }\n        const msgsImpl = msgs;\n        msgsImpl.forOrderedConsumer = true;\n        msgsImpl.resetHandler = ()=>{\n            this.notifyOrderedResetAndReset();\n        };\n        this.iter.setSource(msgsImpl);\n    }\n    notifyOrderedResetAndReset() {\n        this.iter?.notify(ConsumerDebugEvents.Reset, \"\");\n        this.reset(this.opts, {\n            orderedReset: true\n        });\n    }\n    async consume(opts = {\n        max_messages: 100,\n        expires: 30_000\n    }) {\n        const copts = opts;\n        if (copts.bind) {\n            return Promise.reject(new Error(\"bind is not supported\"));\n        }\n        if (this.type === PullConsumerType.Fetch) {\n            return Promise.reject(new Error(\"ordered consumer initialized as fetch\"));\n        }\n        if (this.type === PullConsumerType.Consume) {\n            return Promise.reject(new Error(\"ordered consumer doesn't support concurrent consume\"));\n        }\n        const { callback } = opts;\n        if (callback) {\n            this.userCallback = callback;\n        }\n        this.type = PullConsumerType.Consume;\n        this.opts = opts;\n        await this.reset(opts);\n        return this.iter;\n    }\n    async fetch(opts = {\n        max_messages: 100,\n        expires: 30_000\n    }) {\n        const copts = opts;\n        if (copts.bind) {\n            return Promise.reject(new Error(\"bind is not supported\"));\n        }\n        if (this.type === PullConsumerType.Consume) {\n            return Promise.reject(new Error(\"ordered consumer already initialized as consume\"));\n        }\n        if (this.iter?.done === false) {\n            return Promise.reject(new Error(\"ordered consumer doesn't support concurrent fetch\"));\n        }\n        const { callback } = opts;\n        if (callback) {\n            this.userCallback = callback;\n        }\n        this.type = PullConsumerType.Fetch;\n        this.opts = opts;\n        await this.reset(opts, {\n            fromFetch: true\n        });\n        return this.iter;\n    }\n    async next(opts = {\n        expires: 30_000\n    }) {\n        const copts = opts;\n        if (copts.bind) {\n            return Promise.reject(new Error(\"bind is not supported\"));\n        }\n        copts.max_messages = 1;\n        const d = deferred();\n        copts.callback = (m)=>{\n            this.userCallback = null;\n            d.resolve(m);\n        };\n        const iter = await this.fetch(copts);\n        iter.iterClosed.then((err)=>{\n            if (err) {\n                d.reject(err);\n            }\n            d.resolve(null);\n        }).catch((err)=>{\n            d.reject(err);\n        });\n        return d;\n    }\n    delete() {\n        if (!this.currentConsumer) {\n            return Promise.resolve(false);\n        }\n        return this.api.delete(this.stream, this.currentConsumer.name).then((tf)=>{\n            return Promise.resolve(tf);\n        }).catch((err)=>{\n            return Promise.reject(err);\n        }).finally(()=>{\n            this.currentConsumer = null;\n        });\n    }\n    async info(cached) {\n        if (this.currentConsumer == null) {\n            this.currentConsumer = await this.resetConsumer(this.serial);\n            return Promise.resolve(this.currentConsumer);\n        }\n        if (cached && this.currentConsumer) {\n            return Promise.resolve(this.currentConsumer);\n        }\n        return this.api.info(this.stream, this.currentConsumer.name);\n    }\n}\nclass ConsumersImpl {\n    api;\n    notified;\n    constructor(api){\n        this.api = api;\n        this.notified = false;\n    }\n    checkVersion() {\n        const fv = this.api.nc.features.get(Feature.JS_SIMPLIFICATION);\n        if (!fv.ok) {\n            return Promise.reject(new Error(`consumers framework is only supported on servers ${fv.min} or better`));\n        }\n        return Promise.resolve();\n    }\n    async get(stream, name = {}) {\n        if (typeof name === \"object\") {\n            return this.ordered(stream, name);\n        }\n        await this.checkVersion();\n        return this.api.info(stream, name).then((ci)=>{\n            if (ci.config.deliver_subject !== undefined) {\n                return Promise.reject(new Error(\"push consumer not supported\"));\n            }\n            return new PullConsumerImpl(this.api, ci);\n        }).catch((err)=>{\n            return Promise.reject(err);\n        });\n    }\n    async ordered(stream, opts) {\n        await this.checkVersion();\n        const impl = this.api;\n        const sapi = new StreamAPIImpl(impl.nc, impl.opts);\n        return sapi.info(stream).then((_si)=>{\n            return Promise.resolve(new OrderedPullConsumerImpl(this.api, stream, opts));\n        }).catch((err)=>{\n            return Promise.reject(err);\n        });\n    }\n}\nclass StreamImpl {\n    api;\n    _info;\n    constructor(api, info){\n        this.api = api;\n        this._info = info;\n    }\n    get name() {\n        return this._info.config.name;\n    }\n    alternates() {\n        return this.info().then((si)=>{\n            return si.alternates ? si.alternates : [];\n        });\n    }\n    async best() {\n        await this.info();\n        if (this._info.alternates) {\n            const asi = await this.api.info(this._info.alternates[0].name);\n            return new StreamImpl(this.api, asi);\n        } else {\n            return this;\n        }\n    }\n    info(cached = false, opts) {\n        if (cached) {\n            return Promise.resolve(this._info);\n        }\n        return this.api.info(this.name, opts).then((si)=>{\n            this._info = si;\n            return this._info;\n        });\n    }\n    getConsumer(name) {\n        return new ConsumersImpl(new ConsumerAPIImpl(this.api.nc, this.api.opts)).get(this.name, name);\n    }\n    getMessage(query) {\n        return this.api.getMessage(this.name, query);\n    }\n    deleteMessage(seq, erase) {\n        return this.api.deleteMessage(this.name, seq, erase);\n    }\n}\nclass StreamAPIImpl extends BaseApiClient {\n    constructor(nc, opts){\n        super(nc, opts);\n    }\n    checkStreamConfigVersions(cfg) {\n        const nci = this.nc;\n        if (cfg.metadata) {\n            const { min, ok } = nci.features.get(Feature.JS_STREAM_CONSUMER_METADATA);\n            if (!ok) {\n                throw new Error(`stream 'metadata' requires server ${min}`);\n            }\n        }\n        if (cfg.first_seq) {\n            const { min, ok } = nci.features.get(Feature.JS_STREAM_FIRST_SEQ);\n            if (!ok) {\n                throw new Error(`stream 'first_seq' requires server ${min}`);\n            }\n        }\n        if (cfg.subject_transform) {\n            const { min, ok } = nci.features.get(Feature.JS_STREAM_SUBJECT_TRANSFORM);\n            if (!ok) {\n                throw new Error(`stream 'subject_transform' requires server ${min}`);\n            }\n        }\n        if (cfg.compression) {\n            const { min, ok } = nci.features.get(Feature.JS_STREAM_COMPRESSION);\n            if (!ok) {\n                throw new Error(`stream 'compression' requires server ${min}`);\n            }\n        }\n        if (cfg.consumer_limits) {\n            const { min, ok } = nci.features.get(Feature.JS_DEFAULT_CONSUMER_LIMITS);\n            if (!ok) {\n                throw new Error(`stream 'consumer_limits' requires server ${min}`);\n            }\n        }\n        function validateStreamSource(context, src) {\n            const count = src?.subject_transforms?.length || 0;\n            if (count > 0) {\n                const { min, ok } = nci.features.get(Feature.JS_STREAM_SOURCE_SUBJECT_TRANSFORM);\n                if (!ok) {\n                    throw new Error(`${context} 'subject_transforms' requires server ${min}`);\n                }\n            }\n        }\n        if (cfg.sources) {\n            cfg.sources.forEach((src)=>{\n                validateStreamSource(\"stream sources\", src);\n            });\n        }\n        if (cfg.mirror) {\n            validateStreamSource(\"stream mirror\", cfg.mirror);\n        }\n    }\n    async add(cfg = {}) {\n        this.checkStreamConfigVersions(cfg);\n        validateStreamName(cfg.name);\n        cfg.mirror = convertStreamSourceDomain(cfg.mirror);\n        cfg.sources = cfg.sources?.map(convertStreamSourceDomain);\n        const r = await this._request(`${this.prefix}.STREAM.CREATE.${cfg.name}`, cfg);\n        const si = r;\n        this._fixInfo(si);\n        return si;\n    }\n    async delete(stream) {\n        validateStreamName(stream);\n        const r = await this._request(`${this.prefix}.STREAM.DELETE.${stream}`);\n        const cr = r;\n        return cr.success;\n    }\n    async update(name, cfg = {}) {\n        if (typeof name === \"object\") {\n            const sc = name;\n            name = sc.name;\n            cfg = sc;\n            console.trace(`\\u001B[33m >> streams.update(config: StreamConfig) api changed to streams.update(name: string, config: StreamUpdateConfig) - this shim will be removed - update your code.  \\u001B[0m`);\n        }\n        this.checkStreamConfigVersions(cfg);\n        validateStreamName(name);\n        const old = await this.info(name);\n        const update = Object.assign(old.config, cfg);\n        update.mirror = convertStreamSourceDomain(update.mirror);\n        update.sources = update.sources?.map(convertStreamSourceDomain);\n        const r = await this._request(`${this.prefix}.STREAM.UPDATE.${name}`, update);\n        const si = r;\n        this._fixInfo(si);\n        return si;\n    }\n    async info(name, data) {\n        validateStreamName(name);\n        const subj = `${this.prefix}.STREAM.INFO.${name}`;\n        const r = await this._request(subj, data);\n        let si = r;\n        let { total, limit } = si;\n        let have = si.state.subjects ? Object.getOwnPropertyNames(si.state.subjects).length : 1;\n        if (total && total > have) {\n            const infos = [\n                si\n            ];\n            const paged = data || {};\n            let i = 0;\n            while(total > have){\n                i++;\n                paged.offset = limit * i;\n                const r = await this._request(subj, paged);\n                total = r.total;\n                infos.push(r);\n                const count = Object.getOwnPropertyNames(r.state.subjects).length;\n                have += count;\n                if (count < limit) {\n                    break;\n                }\n            }\n            let subjects = {};\n            for(let i = 0; i < infos.length; i++){\n                si = infos[i];\n                if (si.state.subjects) {\n                    subjects = Object.assign(subjects, si.state.subjects);\n                }\n            }\n            si.offset = 0;\n            si.total = 0;\n            si.limit = 0;\n            si.state.subjects = subjects;\n        }\n        this._fixInfo(si);\n        return si;\n    }\n    list(subject = \"\") {\n        const payload = subject?.length ? {\n            subject\n        } : {};\n        const listerFilter = (v)=>{\n            const slr = v;\n            slr.streams.forEach((si)=>{\n                this._fixInfo(si);\n            });\n            return slr.streams;\n        };\n        const subj = `${this.prefix}.STREAM.LIST`;\n        return new ListerImpl(subj, listerFilter, this, payload);\n    }\n    _fixInfo(si) {\n        si.config.sealed = si.config.sealed || false;\n        si.config.deny_delete = si.config.deny_delete || false;\n        si.config.deny_purge = si.config.deny_purge || false;\n        si.config.allow_rollup_hdrs = si.config.allow_rollup_hdrs || false;\n    }\n    async purge(name, opts) {\n        if (opts) {\n            const { keep, seq } = opts;\n            if (typeof keep === \"number\" && typeof seq === \"number\") {\n                throw new Error(\"can specify one of keep or seq\");\n            }\n        }\n        validateStreamName(name);\n        const v = await this._request(`${this.prefix}.STREAM.PURGE.${name}`, opts);\n        return v;\n    }\n    async deleteMessage(stream, seq, erase = true) {\n        validateStreamName(stream);\n        const dr = {\n            seq\n        };\n        if (!erase) {\n            dr.no_erase = true;\n        }\n        const r = await this._request(`${this.prefix}.STREAM.MSG.DELETE.${stream}`, dr);\n        const cr = r;\n        return cr.success;\n    }\n    async getMessage(stream, query) {\n        validateStreamName(stream);\n        const r = await this._request(`${this.prefix}.STREAM.MSG.GET.${stream}`, query);\n        const sm = r;\n        return new StoredMsgImpl(sm);\n    }\n    find(subject) {\n        return this.findStream(subject);\n    }\n    listKvs() {\n        const filter = (v)=>{\n            const slr = v;\n            const kvStreams = slr.streams.filter((v)=>{\n                return v.config.name.startsWith(kvPrefix);\n            });\n            kvStreams.forEach((si)=>{\n                this._fixInfo(si);\n            });\n            let cluster = \"\";\n            if (kvStreams.length) {\n                cluster = this.nc.info?.cluster ?? \"\";\n            }\n            const status = kvStreams.map((si)=>{\n                return new KvStatusImpl(si, cluster);\n            });\n            return status;\n        };\n        const subj = `${this.prefix}.STREAM.LIST`;\n        return new ListerImpl(subj, filter, this);\n    }\n    listObjectStores() {\n        const filter = (v)=>{\n            const slr = v;\n            const objStreams = slr.streams.filter((v)=>{\n                return v.config.name.startsWith(osPrefix);\n            });\n            objStreams.forEach((si)=>{\n                this._fixInfo(si);\n            });\n            const status = objStreams.map((si)=>{\n                return new ObjectStoreStatusImpl(si);\n            });\n            return status;\n        };\n        const subj = `${this.prefix}.STREAM.LIST`;\n        return new ListerImpl(subj, filter, this);\n    }\n    names(subject = \"\") {\n        const payload = subject?.length ? {\n            subject\n        } : {};\n        const listerFilter = (v)=>{\n            const sr = v;\n            return sr.streams;\n        };\n        const subj = `${this.prefix}.STREAM.NAMES`;\n        return new ListerImpl(subj, listerFilter, this, payload);\n    }\n    async get(name) {\n        const si = await this.info(name);\n        return Promise.resolve(new StreamImpl(this, si));\n    }\n}\nclass DirectStreamAPIImpl extends BaseApiClient {\n    constructor(nc, opts){\n        super(nc, opts);\n    }\n    async getMessage(stream, query) {\n        validateStreamName(stream);\n        let qq = query;\n        const { last_by_subj } = qq;\n        if (last_by_subj) {\n            qq = null;\n        }\n        const payload = qq ? this.jc.encode(qq) : Empty;\n        const pre = this.opts.apiPrefix || \"$JS.API\";\n        const subj = last_by_subj ? `${pre}.DIRECT.GET.${stream}.${last_by_subj}` : `${pre}.DIRECT.GET.${stream}`;\n        const r = await this.nc.request(subj, payload);\n        const err = checkJsError(r);\n        if (err) {\n            return Promise.reject(err);\n        }\n        const dm = new DirectMsgImpl(r);\n        return Promise.resolve(dm);\n    }\n    async getBatch(stream, opts) {\n        validateStreamName(stream);\n        const pre = this.opts.apiPrefix || \"$JS.API\";\n        const subj = `${pre}.DIRECT.GET.${stream}`;\n        if (!Array.isArray(opts.multi_last) || opts.multi_last.length === 0) {\n            return Promise.reject(\"multi_last is required\");\n        }\n        const payload = JSON.stringify(opts, (key, value)=>{\n            if (key === \"up_to_time\" && value instanceof Date) {\n                return value.toISOString();\n            }\n            return value;\n        });\n        const iter = new QueuedIteratorImpl();\n        const raw = await this.nc.requestMany(subj, payload, {\n            strategy: RequestStrategy.SentinelMsg\n        });\n        (async ()=>{\n            let gotFirst = false;\n            let badServer = false;\n            let badRequest;\n            for await (const m of raw){\n                if (!gotFirst) {\n                    gotFirst = true;\n                    const code = m.headers?.code || 0;\n                    if (code !== 0 && code < 200 || code > 299) {\n                        badRequest = m.headers?.description.toLowerCase();\n                        break;\n                    }\n                    const v = m.headers?.get(\"Nats-Num-Pending\");\n                    if (v === \"\") {\n                        badServer = true;\n                        break;\n                    }\n                }\n                if (m.data.length === 0) {\n                    break;\n                }\n                iter.push(new DirectMsgImpl(m));\n            }\n            iter.push(()=>{\n                if (badServer) {\n                    throw new Error(\"batch direct get not supported by the server\");\n                }\n                if (badRequest) {\n                    throw new Error(`bad request: ${badRequest}`);\n                }\n                iter.stop();\n            });\n        })();\n        return Promise.resolve(iter);\n    }\n}\nclass DirectMsgImpl {\n    data;\n    header;\n    static jc;\n    constructor(m){\n        if (!m.headers) {\n            throw new Error(\"headers expected\");\n        }\n        this.data = m.data;\n        this.header = m.headers;\n    }\n    get subject() {\n        return this.header.last(DirectMsgHeaders.Subject);\n    }\n    get seq() {\n        const v = this.header.last(DirectMsgHeaders.Sequence);\n        return typeof v === \"string\" ? parseInt(v) : 0;\n    }\n    get time() {\n        return new Date(Date.parse(this.timestamp));\n    }\n    get timestamp() {\n        return this.header.last(DirectMsgHeaders.TimeStamp);\n    }\n    get stream() {\n        return this.header.last(DirectMsgHeaders.Stream);\n    }\n    json(reviver) {\n        return JSONCodec(reviver).decode(this.data);\n    }\n    string() {\n        return TD.decode(this.data);\n    }\n}\nclass JetStreamManagerImpl extends BaseApiClient {\n    streams;\n    consumers;\n    direct;\n    constructor(nc, opts){\n        super(nc, opts);\n        this.streams = new StreamAPIImpl(nc, opts);\n        this.consumers = new ConsumerAPIImpl(nc, opts);\n        this.direct = new DirectStreamAPIImpl(nc, opts);\n    }\n    async getAccountInfo() {\n        const r = await this._request(`${this.prefix}.INFO`);\n        return r;\n    }\n    jetstream() {\n        return this.nc.jetstream(this.getOptions());\n    }\n    advisories() {\n        const iter = new QueuedIteratorImpl();\n        this.nc.subscribe(`$JS.EVENT.ADVISORY.>`, {\n            callback: (err, msg)=>{\n                if (err) {\n                    throw err;\n                }\n                try {\n                    const d = this.parseJsResponse(msg);\n                    const chunks = d.type.split(\".\");\n                    const kind = chunks[chunks.length - 1];\n                    iter.push({\n                        kind: kind,\n                        data: d\n                    });\n                } catch (err) {\n                    iter.stop(err);\n                }\n            }\n        });\n        return iter;\n    }\n}\nclass StoredMsgImpl {\n    _header;\n    smr;\n    static jc;\n    constructor(smr){\n        this.smr = smr;\n    }\n    get subject() {\n        return this.smr.message.subject;\n    }\n    get seq() {\n        return this.smr.message.seq;\n    }\n    get timestamp() {\n        return this.smr.message.time;\n    }\n    get time() {\n        return new Date(Date.parse(this.timestamp));\n    }\n    get data() {\n        return this.smr.message.data ? this._parse(this.smr.message.data) : Empty;\n    }\n    get header() {\n        if (!this._header) {\n            if (this.smr.message.hdrs) {\n                const hd = this._parse(this.smr.message.hdrs);\n                this._header = MsgHdrsImpl.decode(hd);\n            } else {\n                this._header = headers();\n            }\n        }\n        return this._header;\n    }\n    _parse(s) {\n        const bs = atob(s);\n        const len = bs.length;\n        const bytes = new Uint8Array(len);\n        for(let i = 0; i < len; i++){\n            bytes[i] = bs.charCodeAt(i);\n        }\n        return bytes;\n    }\n    json(reviver) {\n        return JSONCodec(reviver).decode(this.data);\n    }\n    string() {\n        return TD.decode(this.data);\n    }\n}\nclass StreamsImpl {\n    api;\n    constructor(api){\n        this.api = api;\n    }\n    get(stream) {\n        return this.api.info(stream).then((si)=>{\n            return new StreamImpl(this.api, si);\n        });\n    }\n}\nclass ObjectInfoImpl {\n    info;\n    hdrs;\n    constructor(oi){\n        this.info = oi;\n    }\n    get name() {\n        return this.info.name;\n    }\n    get description() {\n        return this.info.description ?? \"\";\n    }\n    get headers() {\n        if (!this.hdrs) {\n            this.hdrs = MsgHdrsImpl.fromRecord(this.info.headers || {});\n        }\n        return this.hdrs;\n    }\n    get options() {\n        return this.info.options;\n    }\n    get bucket() {\n        return this.info.bucket;\n    }\n    get chunks() {\n        return this.info.chunks;\n    }\n    get deleted() {\n        return this.info.deleted ?? false;\n    }\n    get digest() {\n        return this.info.digest;\n    }\n    get mtime() {\n        return this.info.mtime;\n    }\n    get nuid() {\n        return this.info.nuid;\n    }\n    get size() {\n        return this.info.size;\n    }\n    get revision() {\n        return this.info.revision;\n    }\n    get metadata() {\n        return this.info.metadata || {};\n    }\n    isLink() {\n        return this.info.options?.link !== undefined && this.info.options?.link !== null;\n    }\n}\nfunction toServerObjectStoreMeta(meta) {\n    const v = {\n        name: meta.name,\n        description: meta.description ?? \"\",\n        options: meta.options,\n        metadata: meta.metadata\n    };\n    if (meta.headers) {\n        const mhi = meta.headers;\n        v.headers = mhi.toRecord();\n    }\n    return v;\n}\nfunction emptyReadableStream() {\n    return new ReadableStream({\n        pull (c) {\n            c.enqueue(new Uint8Array(0));\n            c.close();\n        }\n    });\n}\nclass ObjectStoreImpl {\n    jsm;\n    js;\n    stream;\n    name;\n    constructor(name, jsm, js){\n        this.name = name;\n        this.jsm = jsm;\n        this.js = js;\n    }\n    _checkNotEmpty(name) {\n        if (!name || name.length === 0) {\n            return {\n                name,\n                error: new Error(\"name cannot be empty\")\n            };\n        }\n        return {\n            name\n        };\n    }\n    async info(name) {\n        const info = await this.rawInfo(name);\n        return info ? new ObjectInfoImpl(info) : null;\n    }\n    async list() {\n        const buf = [];\n        const iter = await this.watch({\n            ignoreDeletes: true,\n            includeHistory: true\n        });\n        for await (const info of iter){\n            if (info === null) {\n                break;\n            }\n            buf.push(info);\n        }\n        return Promise.resolve(buf);\n    }\n    async rawInfo(name) {\n        const { name: obj, error } = this._checkNotEmpty(name);\n        if (error) {\n            return Promise.reject(error);\n        }\n        const meta = this._metaSubject(obj);\n        try {\n            const m = await this.jsm.streams.getMessage(this.stream, {\n                last_by_subj: meta\n            });\n            const jc = JSONCodec();\n            const soi = jc.decode(m.data);\n            soi.revision = m.seq;\n            return soi;\n        } catch (err) {\n            if (err.code === \"404\") {\n                return null;\n            }\n            return Promise.reject(err);\n        }\n    }\n    async _si(opts) {\n        try {\n            return await this.jsm.streams.info(this.stream, opts);\n        } catch (err) {\n            const nerr = err;\n            if (nerr.code === \"404\") {\n                return null;\n            }\n            return Promise.reject(err);\n        }\n    }\n    async seal() {\n        let info = await this._si();\n        if (info === null) {\n            return Promise.reject(new Error(\"object store not found\"));\n        }\n        info.config.sealed = true;\n        info = await this.jsm.streams.update(this.stream, info.config);\n        return Promise.resolve(new ObjectStoreStatusImpl(info));\n    }\n    async status(opts) {\n        const info = await this._si(opts);\n        if (info === null) {\n            return Promise.reject(new Error(\"object store not found\"));\n        }\n        return Promise.resolve(new ObjectStoreStatusImpl(info));\n    }\n    destroy() {\n        return this.jsm.streams.delete(this.stream);\n    }\n    async _put(meta, rs, opts) {\n        const jsopts = this.js.getOptions();\n        opts = opts || {\n            timeout: jsopts.timeout\n        };\n        opts.timeout = opts.timeout || jsopts.timeout;\n        opts.previousRevision = opts.previousRevision ?? undefined;\n        const { timeout, previousRevision } = opts;\n        const si = this.js.nc.info;\n        const maxPayload = si?.max_payload || 1024;\n        meta = meta || {};\n        meta.options = meta.options || {};\n        let maxChunk = meta.options?.max_chunk_size || 128 * 1024;\n        maxChunk = maxChunk > maxPayload ? maxPayload : maxChunk;\n        meta.options.max_chunk_size = maxChunk;\n        const old = await this.info(meta.name);\n        const { name: n, error } = this._checkNotEmpty(meta.name);\n        if (error) {\n            return Promise.reject(error);\n        }\n        const id = nuid.next();\n        const chunkSubj = this._chunkSubject(id);\n        const metaSubj = this._metaSubject(n);\n        const info = Object.assign({\n            bucket: this.name,\n            nuid: id,\n            size: 0,\n            chunks: 0\n        }, toServerObjectStoreMeta(meta));\n        const d = deferred();\n        const proms = [];\n        const db = new DataBuffer();\n        try {\n            const reader = rs ? rs.getReader() : null;\n            const sha = new SHA256();\n            while(true){\n                const { done, value } = reader ? await reader.read() : {\n                    done: true,\n                    value: undefined\n                };\n                if (done) {\n                    if (db.size() > 0) {\n                        const payload = db.drain();\n                        sha.update(payload);\n                        info.chunks++;\n                        info.size += payload.length;\n                        proms.push(this.js.publish(chunkSubj, payload, {\n                            timeout\n                        }));\n                    }\n                    await Promise.all(proms);\n                    proms.length = 0;\n                    info.mtime = new Date().toISOString();\n                    const digest = sha.digest(\"base64\");\n                    const pad = digest.length % 3;\n                    const padding = pad > 0 ? \"=\".repeat(pad) : \"\";\n                    info.digest = `${digestType}${digest}${padding}`;\n                    info.deleted = false;\n                    const h = headers();\n                    if (typeof previousRevision === \"number\") {\n                        h.set(PubHeaders.ExpectedLastSubjectSequenceHdr, `${previousRevision}`);\n                    }\n                    h.set(JsHeaders.RollupHdr, JsHeaders.RollupValueSubject);\n                    const pa = await this.js.publish(metaSubj, JSONCodec().encode(info), {\n                        headers: h,\n                        timeout\n                    });\n                    info.revision = pa.seq;\n                    if (old) {\n                        try {\n                            await this.jsm.streams.purge(this.stream, {\n                                filter: `$O.${this.name}.C.${old.nuid}`\n                            });\n                        } catch (_err) {}\n                    }\n                    d.resolve(new ObjectInfoImpl(info));\n                    break;\n                }\n                if (value) {\n                    db.fill(value);\n                    while(db.size() > maxChunk){\n                        info.chunks++;\n                        info.size += maxChunk;\n                        const payload = db.drain(meta.options.max_chunk_size);\n                        sha.update(payload);\n                        proms.push(this.js.publish(chunkSubj, payload, {\n                            timeout\n                        }));\n                    }\n                }\n            }\n        } catch (err) {\n            await this.jsm.streams.purge(this.stream, {\n                filter: chunkSubj\n            });\n            d.reject(err);\n        }\n        return d;\n    }\n    putBlob(meta, data, opts) {\n        function readableStreamFrom(data) {\n            return new ReadableStream({\n                pull (controller) {\n                    controller.enqueue(data);\n                    controller.close();\n                }\n            });\n        }\n        if (data === null) {\n            data = new Uint8Array(0);\n        }\n        return this.put(meta, readableStreamFrom(data), opts);\n    }\n    put(meta, rs, opts) {\n        if (meta?.options?.link) {\n            return Promise.reject(new Error(\"link cannot be set when putting the object in bucket\"));\n        }\n        return this._put(meta, rs, opts);\n    }\n    async getBlob(name) {\n        async function fromReadableStream(rs) {\n            const buf = new DataBuffer();\n            const reader = rs.getReader();\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) {\n                    return buf.drain();\n                }\n                if (value && value.length) {\n                    buf.fill(value);\n                }\n            }\n        }\n        const r = await this.get(name);\n        if (r === null) {\n            return Promise.resolve(null);\n        }\n        const vs = await Promise.all([\n            r.error,\n            fromReadableStream(r.data)\n        ]);\n        if (vs[0]) {\n            return Promise.reject(vs[0]);\n        } else {\n            return Promise.resolve(vs[1]);\n        }\n    }\n    async get(name) {\n        const info = await this.rawInfo(name);\n        if (info === null) {\n            return Promise.resolve(null);\n        }\n        if (info.deleted) {\n            return Promise.resolve(null);\n        }\n        if (info.options && info.options.link) {\n            const ln = info.options.link.name || \"\";\n            if (ln === \"\") {\n                throw new Error(\"link is a bucket\");\n            }\n            const os = info.options.link.bucket !== this.name ? await ObjectStoreImpl.create(this.js, info.options.link.bucket) : this;\n            return os.get(ln);\n        }\n        const d = deferred();\n        const r = {\n            info: new ObjectInfoImpl(info),\n            error: d\n        };\n        if (info.size === 0) {\n            r.data = emptyReadableStream();\n            d.resolve(null);\n            return Promise.resolve(r);\n        }\n        let controller;\n        const oc = consumerOpts();\n        oc.orderedConsumer();\n        const sha = new SHA256();\n        const subj = `$O.${this.name}.C.${info.nuid}`;\n        const sub = await this.js.subscribe(subj, oc);\n        (async ()=>{\n            for await (const jm of sub){\n                if (jm.data.length > 0) {\n                    sha.update(jm.data);\n                    controller.enqueue(jm.data);\n                }\n                if (jm.info.pending === 0) {\n                    const hash = sha.digest(\"base64\");\n                    const pad = hash.length % 3;\n                    const padding = pad > 0 ? \"=\".repeat(pad) : \"\";\n                    const digest = `${digestType}${hash}${padding}`;\n                    if (digest !== info.digest) {\n                        controller.error(new Error(`received a corrupt object, digests do not match received: ${info.digest} calculated ${digest}`));\n                    } else {\n                        controller.close();\n                    }\n                    sub.unsubscribe();\n                }\n            }\n        })().then(()=>{\n            d.resolve();\n        }).catch((err)=>{\n            controller.error(err);\n            d.reject(err);\n        });\n        r.data = new ReadableStream({\n            start (c) {\n                controller = c;\n            },\n            cancel () {\n                sub.unsubscribe();\n            }\n        });\n        return r;\n    }\n    linkStore(name, bucket) {\n        if (!(bucket instanceof ObjectStoreImpl)) {\n            return Promise.reject(\"bucket required\");\n        }\n        const osi = bucket;\n        const { name: n, error } = this._checkNotEmpty(name);\n        if (error) {\n            return Promise.reject(error);\n        }\n        const meta = {\n            name: n,\n            options: {\n                link: {\n                    bucket: osi.name\n                }\n            }\n        };\n        return this._put(meta, null);\n    }\n    async link(name, info) {\n        const { name: n, error } = this._checkNotEmpty(name);\n        if (error) {\n            return Promise.reject(error);\n        }\n        if (info.deleted) {\n            return Promise.reject(new Error(\"src object is deleted\"));\n        }\n        if (info.isLink()) {\n            return Promise.reject(new Error(\"src object is a link\"));\n        }\n        const dest = await this.rawInfo(name);\n        if (dest !== null && !dest.deleted) {\n            return Promise.reject(new Error(\"an object already exists with that name\"));\n        }\n        const link = {\n            bucket: info.bucket,\n            name: info.name\n        };\n        const mm = {\n            name: n,\n            bucket: info.bucket,\n            options: {\n                link: link\n            }\n        };\n        await this.js.publish(this._metaSubject(name), JSON.stringify(mm));\n        const i = await this.info(name);\n        return Promise.resolve(i);\n    }\n    async delete(name) {\n        const info = await this.rawInfo(name);\n        if (info === null) {\n            return Promise.resolve({\n                purged: 0,\n                success: false\n            });\n        }\n        info.deleted = true;\n        info.size = 0;\n        info.chunks = 0;\n        info.digest = \"\";\n        const jc = JSONCodec();\n        const h = headers();\n        h.set(JsHeaders.RollupHdr, JsHeaders.RollupValueSubject);\n        await this.js.publish(this._metaSubject(info.name), jc.encode(info), {\n            headers: h\n        });\n        return this.jsm.streams.purge(this.stream, {\n            filter: this._chunkSubject(info.nuid)\n        });\n    }\n    async update(name, meta = {}) {\n        const info = await this.rawInfo(name);\n        if (info === null) {\n            return Promise.reject(new Error(\"object not found\"));\n        }\n        if (info.deleted) {\n            return Promise.reject(new Error(\"cannot update meta for a deleted object\"));\n        }\n        meta.name = meta.name ?? info.name;\n        const { name: n, error } = this._checkNotEmpty(meta.name);\n        if (error) {\n            return Promise.reject(error);\n        }\n        if (name !== meta.name) {\n            const i = await this.info(meta.name);\n            if (i && !i.deleted) {\n                return Promise.reject(new Error(\"an object already exists with that name\"));\n            }\n        }\n        meta.name = n;\n        const ii = Object.assign({}, info, toServerObjectStoreMeta(meta));\n        const ack = await this.js.publish(this._metaSubject(ii.name), JSON.stringify(ii));\n        if (name !== meta.name) {\n            await this.jsm.streams.purge(this.stream, {\n                filter: this._metaSubject(name)\n            });\n        }\n        return Promise.resolve(ack);\n    }\n    async watch(opts = {}) {\n        opts.includeHistory = opts.includeHistory ?? false;\n        opts.ignoreDeletes = opts.ignoreDeletes ?? false;\n        let initialized = false;\n        const qi = new QueuedIteratorImpl();\n        const subj = this._metaSubjectAll();\n        try {\n            await this.jsm.streams.getMessage(this.stream, {\n                last_by_subj: subj\n            });\n        } catch (err) {\n            if (err.code === \"404\") {\n                qi.push(null);\n                initialized = true;\n            } else {\n                qi.stop(err);\n            }\n        }\n        const jc = JSONCodec();\n        const copts = consumerOpts();\n        copts.orderedConsumer();\n        if (opts.includeHistory) {\n            copts.deliverLastPerSubject();\n        } else {\n            initialized = true;\n            copts.deliverNew();\n        }\n        copts.callback((err, jm)=>{\n            if (err) {\n                qi.stop(err);\n                return;\n            }\n            if (jm !== null) {\n                const oi = jc.decode(jm.data);\n                if (oi.deleted && opts.ignoreDeletes === true) {} else {\n                    qi.push(oi);\n                }\n                if (jm.info?.pending === 0 && !initialized) {\n                    initialized = true;\n                    qi.push(null);\n                }\n            }\n        });\n        const sub = await this.js.subscribe(subj, copts);\n        qi._data = sub;\n        qi.iterClosed.then(()=>{\n            sub.unsubscribe();\n        });\n        sub.closed.then(()=>{\n            qi.stop();\n        }).catch((err)=>{\n            qi.stop(err);\n        });\n        return qi;\n    }\n    _chunkSubject(id) {\n        return `$O.${this.name}.C.${id}`;\n    }\n    _metaSubject(n) {\n        return `$O.${this.name}.M.${Base64UrlPaddedCodec.encode(n)}`;\n    }\n    _metaSubjectAll() {\n        return `$O.${this.name}.M.>`;\n    }\n    async init(opts = {}) {\n        try {\n            this.stream = objectStoreStreamName(this.name);\n        } catch (err) {\n            return Promise.reject(err);\n        }\n        const max_age = opts?.ttl || 0;\n        delete opts.ttl;\n        const sc = Object.assign({\n            max_age\n        }, opts);\n        sc.name = this.stream;\n        sc.num_replicas = opts.replicas ?? 1;\n        sc.allow_direct = true;\n        sc.allow_rollup_hdrs = true;\n        sc.discard = DiscardPolicy.New;\n        sc.subjects = [\n            `$O.${this.name}.C.>`,\n            `$O.${this.name}.M.>`\n        ];\n        if (opts.placement) {\n            sc.placement = opts.placement;\n        }\n        if (opts.metadata) {\n            sc.metadata = opts.metadata;\n        }\n        if (typeof opts.compression === \"boolean\") {\n            sc.compression = opts.compression ? StoreCompression.S2 : StoreCompression.None;\n        }\n        try {\n            await this.jsm.streams.info(sc.name);\n        } catch (err) {\n            if (err.message === \"stream not found\") {\n                await this.jsm.streams.add(sc);\n            }\n        }\n    }\n    static async create(js, name, opts = {}) {\n        const jsm = await js.jetstreamManager();\n        const os = new ObjectStoreImpl(name, jsm, js);\n        await os.init(opts);\n        return Promise.resolve(os);\n    }\n}\nclass ViewsImpl {\n    js;\n    constructor(js){\n        this.js = js;\n    }\n    kv(name, opts = {}) {\n        const jsi = this.js;\n        const { ok, min } = jsi.nc.features.get(Feature.JS_KV);\n        if (!ok) {\n            return Promise.reject(new Error(`kv is only supported on servers ${min} or better`));\n        }\n        if (opts.bindOnly) {\n            return Bucket.bind(this.js, name, opts);\n        }\n        return Bucket.create(this.js, name, opts);\n    }\n    os(name, opts = {}) {\n        if (typeof crypto?.subtle?.digest !== \"function\") {\n            return Promise.reject(new Error(\"objectstore: unable to calculate hashes - crypto.subtle.digest with sha256 support is required\"));\n        }\n        const jsi = this.js;\n        const { ok, min } = jsi.nc.features.get(Feature.JS_OBJECTSTORE);\n        if (!ok) {\n            return Promise.reject(new Error(`objectstore is only supported on servers ${min} or better`));\n        }\n        return ObjectStoreImpl.create(this.js, name, opts);\n    }\n}\nclass JetStreamClientImpl extends BaseApiClient {\n    consumers;\n    streams;\n    consumerAPI;\n    streamAPI;\n    constructor(nc, opts){\n        super(nc, opts);\n        this.consumerAPI = new ConsumerAPIImpl(nc, opts);\n        this.streamAPI = new StreamAPIImpl(nc, opts);\n        this.consumers = new ConsumersImpl(this.consumerAPI);\n        this.streams = new StreamsImpl(this.streamAPI);\n    }\n    jetstreamManager(checkAPI) {\n        if (checkAPI === undefined) {\n            checkAPI = this.opts.checkAPI;\n        }\n        const opts = Object.assign({}, this.opts, {\n            checkAPI\n        });\n        return this.nc.jetstreamManager(opts);\n    }\n    get apiPrefix() {\n        return this.prefix;\n    }\n    get views() {\n        return new ViewsImpl(this);\n    }\n    async publish(subj, data = Empty, opts) {\n        opts = opts || {};\n        opts.expect = opts.expect || {};\n        const mh = opts?.headers || headers();\n        if (opts) {\n            if (opts.msgID) {\n                mh.set(PubHeaders.MsgIdHdr, opts.msgID);\n            }\n            if (opts.expect.lastMsgID) {\n                mh.set(PubHeaders.ExpectedLastMsgIdHdr, opts.expect.lastMsgID);\n            }\n            if (opts.expect.streamName) {\n                mh.set(PubHeaders.ExpectedStreamHdr, opts.expect.streamName);\n            }\n            if (typeof opts.expect.lastSequence === \"number\") {\n                mh.set(PubHeaders.ExpectedLastSeqHdr, `${opts.expect.lastSequence}`);\n            }\n            if (typeof opts.expect.lastSubjectSequence === \"number\") {\n                mh.set(PubHeaders.ExpectedLastSubjectSequenceHdr, `${opts.expect.lastSubjectSequence}`);\n            }\n        }\n        const to = opts.timeout || this.timeout;\n        const ro = {};\n        if (to) {\n            ro.timeout = to;\n        }\n        if (opts) {\n            ro.headers = mh;\n        }\n        let { retries, retry_delay } = opts;\n        retries = retries || 1;\n        retry_delay = retry_delay || 250;\n        let r;\n        for(let i = 0; i < retries; i++){\n            try {\n                r = await this.nc.request(subj, data, ro);\n                break;\n            } catch (err) {\n                const ne = err;\n                if (ne.code === \"503\" && i + 1 < retries) {\n                    await delay(retry_delay);\n                } else {\n                    throw err;\n                }\n            }\n        }\n        const pa = this.parseJsResponse(r);\n        if (pa.stream === \"\") {\n            throw NatsError.errorForCode(ErrorCode.JetStreamInvalidAck);\n        }\n        pa.duplicate = pa.duplicate ? pa.duplicate : false;\n        return pa;\n    }\n    async pull(stream, durable, expires = 0) {\n        validateStreamName(stream);\n        validateDurableName(durable);\n        let timeout = this.timeout;\n        if (expires > timeout) {\n            timeout = expires;\n        }\n        expires = expires < 0 ? 0 : nanos(expires);\n        const pullOpts = {\n            batch: 1,\n            no_wait: expires === 0,\n            expires\n        };\n        const msg = await this.nc.request(`${this.prefix}.CONSUMER.MSG.NEXT.${stream}.${durable}`, this.jc.encode(pullOpts), {\n            noMux: true,\n            timeout\n        });\n        const err = checkJsError(msg);\n        if (err) {\n            throw err;\n        }\n        return toJsMsg(msg, this.timeout);\n    }\n    fetch(stream, durable, opts = {}) {\n        validateStreamName(stream);\n        validateDurableName(durable);\n        let timer = null;\n        const trackBytes = (opts.max_bytes ?? 0) > 0;\n        let receivedBytes = 0;\n        const max_bytes = trackBytes ? opts.max_bytes : 0;\n        let monitor = null;\n        const args = {};\n        args.batch = opts.batch || 1;\n        if (max_bytes) {\n            const fv = this.nc.features.get(Feature.JS_PULL_MAX_BYTES);\n            if (!fv.ok) {\n                throw new Error(`max_bytes is only supported on servers ${fv.min} or better`);\n            }\n            args.max_bytes = max_bytes;\n        }\n        args.no_wait = opts.no_wait || false;\n        if (args.no_wait && args.expires) {\n            args.expires = 0;\n        }\n        const expires = opts.expires || 0;\n        if (expires) {\n            args.expires = nanos(expires);\n        }\n        if (expires === 0 && args.no_wait === false) {\n            throw new Error(\"expires or no_wait is required\");\n        }\n        const hb = opts.idle_heartbeat || 0;\n        if (hb) {\n            args.idle_heartbeat = nanos(hb);\n            if (opts.delay_heartbeat === true) {\n                args.idle_heartbeat = nanos(hb * 4);\n            }\n        }\n        const qi = new QueuedIteratorImpl();\n        const wants = args.batch;\n        let received = 0;\n        qi.protocolFilterFn = (jm, _ingest = false)=>{\n            const jsmi = jm;\n            if (isHeartbeatMsg(jsmi.msg)) {\n                monitor?.work();\n                return false;\n            }\n            return true;\n        };\n        qi.dispatchedFn = (m)=>{\n            if (m) {\n                if (trackBytes) {\n                    receivedBytes += m.data.length;\n                }\n                received++;\n                if (timer && m.info.pending === 0) {\n                    return;\n                }\n                if (qi.getPending() === 1 && m.info.pending === 0 || wants === received || max_bytes > 0 && receivedBytes >= max_bytes) {\n                    qi.stop();\n                }\n            }\n        };\n        const inbox = createInbox(this.nc.options.inboxPrefix);\n        const sub = this.nc.subscribe(inbox, {\n            max: opts.batch,\n            callback: (err, msg)=>{\n                if (err === null) {\n                    err = checkJsError(msg);\n                }\n                if (err !== null) {\n                    if (timer) {\n                        timer.cancel();\n                        timer = null;\n                    }\n                    if (isNatsError(err)) {\n                        qi.stop(hideNonTerminalJsErrors(err) === null ? undefined : err);\n                    } else {\n                        qi.stop(err);\n                    }\n                } else {\n                    monitor?.work();\n                    qi.received++;\n                    qi.push(toJsMsg(msg, this.timeout));\n                }\n            }\n        });\n        if (expires) {\n            timer = timeout(expires);\n            timer.catch(()=>{\n                if (!sub.isClosed()) {\n                    sub.drain().catch(()=>{});\n                    timer = null;\n                }\n                if (monitor) {\n                    monitor.cancel();\n                }\n            });\n        }\n        (async ()=>{\n            try {\n                if (hb) {\n                    monitor = new IdleHeartbeatMonitor(hb, (v)=>{\n                        qi.push(()=>{\n                            qi.err = new NatsError(`${Js409Errors.IdleHeartbeatMissed}: ${v}`, ErrorCode.JetStreamIdleHeartBeat);\n                        });\n                        return true;\n                    });\n                }\n            } catch (_err) {}\n            await sub.closed;\n            if (timer !== null) {\n                timer.cancel();\n                timer = null;\n            }\n            if (monitor) {\n                monitor.cancel();\n            }\n            qi.stop();\n        })().catch();\n        this.nc.publish(`${this.prefix}.CONSUMER.MSG.NEXT.${stream}.${durable}`, this.jc.encode(args), {\n            reply: inbox\n        });\n        return qi;\n    }\n    async pullSubscribe(subject, opts = consumerOpts()) {\n        const cso = await this._processOptions(subject, opts);\n        if (cso.ordered) {\n            throw new Error(\"pull subscribers cannot be be ordered\");\n        }\n        if (cso.config.deliver_subject) {\n            throw new Error(\"consumer info specifies deliver_subject - pull consumers cannot have deliver_subject set\");\n        }\n        const ackPolicy = cso.config.ack_policy;\n        if (ackPolicy === AckPolicy.None || ackPolicy === AckPolicy.All) {\n            throw new Error(\"ack policy for pull consumers must be explicit\");\n        }\n        const so = this._buildTypedSubscriptionOpts(cso);\n        const sub = new JetStreamPullSubscriptionImpl(this, cso.deliver, so);\n        sub.info = cso;\n        try {\n            await this._maybeCreateConsumer(cso);\n        } catch (err) {\n            sub.unsubscribe();\n            throw err;\n        }\n        return sub;\n    }\n    async subscribe(subject, opts = consumerOpts()) {\n        const cso = await this._processOptions(subject, opts);\n        if (!cso.isBind && !cso.config.deliver_subject) {\n            throw new Error(\"push consumer requires deliver_subject\");\n        }\n        const so = this._buildTypedSubscriptionOpts(cso);\n        const sub = new JetStreamSubscriptionImpl(this, cso.deliver, so);\n        sub.info = cso;\n        try {\n            await this._maybeCreateConsumer(cso);\n        } catch (err) {\n            sub.unsubscribe();\n            throw err;\n        }\n        sub._maybeSetupHbMonitoring();\n        return sub;\n    }\n    async _processOptions(subject, opts = consumerOpts()) {\n        const jsi = isConsumerOptsBuilder(opts) ? opts.getOpts() : opts;\n        jsi.isBind = isConsumerOptsBuilder(opts) ? opts.isBind : false;\n        jsi.flow_control = {\n            heartbeat_count: 0,\n            fc_count: 0,\n            consumer_restarts: 0\n        };\n        if (jsi.ordered) {\n            jsi.ordered_consumer_sequence = {\n                stream_seq: 0,\n                delivery_seq: 0\n            };\n            if (jsi.config.ack_policy !== AckPolicy.NotSet && jsi.config.ack_policy !== AckPolicy.None) {\n                throw new NatsError(\"ordered consumer: ack_policy can only be set to 'none'\", ErrorCode.ApiError);\n            }\n            if (jsi.config.durable_name && jsi.config.durable_name.length > 0) {\n                throw new NatsError(\"ordered consumer: durable_name cannot be set\", ErrorCode.ApiError);\n            }\n            if (jsi.config.deliver_subject && jsi.config.deliver_subject.length > 0) {\n                throw new NatsError(\"ordered consumer: deliver_subject cannot be set\", ErrorCode.ApiError);\n            }\n            if (jsi.config.max_deliver !== undefined && jsi.config.max_deliver > 1) {\n                throw new NatsError(\"ordered consumer: max_deliver cannot be set\", ErrorCode.ApiError);\n            }\n            if (jsi.config.deliver_group && jsi.config.deliver_group.length > 0) {\n                throw new NatsError(\"ordered consumer: deliver_group cannot be set\", ErrorCode.ApiError);\n            }\n            jsi.config.deliver_subject = createInbox(this.nc.options.inboxPrefix);\n            jsi.config.ack_policy = AckPolicy.None;\n            jsi.config.max_deliver = 1;\n            jsi.config.flow_control = true;\n            jsi.config.idle_heartbeat = jsi.config.idle_heartbeat || nanos(5000);\n            jsi.config.ack_wait = nanos(22 * 60 * 60 * 1000);\n            jsi.config.mem_storage = true;\n            jsi.config.num_replicas = 1;\n        }\n        if (jsi.config.ack_policy === AckPolicy.NotSet) {\n            jsi.config.ack_policy = AckPolicy.All;\n        }\n        jsi.api = this;\n        jsi.config = jsi.config || {};\n        jsi.stream = jsi.stream ? jsi.stream : await this.findStream(subject);\n        jsi.attached = false;\n        if (jsi.config.durable_name) {\n            try {\n                const info = await this.consumerAPI.info(jsi.stream, jsi.config.durable_name);\n                if (info) {\n                    if (info.config.filter_subject && info.config.filter_subject !== subject) {\n                        throw new Error(\"subject does not match consumer\");\n                    }\n                    const qn = jsi.config.deliver_group ?? \"\";\n                    if (qn === \"\" && info.push_bound === true) {\n                        throw new Error(`duplicate subscription`);\n                    }\n                    const rqn = info.config.deliver_group ?? \"\";\n                    if (qn !== rqn) {\n                        if (rqn === \"\") {\n                            throw new Error(`durable requires no queue group`);\n                        } else {\n                            throw new Error(`durable requires queue group '${rqn}'`);\n                        }\n                    }\n                    jsi.last = info;\n                    jsi.config = info.config;\n                    jsi.attached = true;\n                    if (!jsi.config.durable_name) {\n                        jsi.name = info.name;\n                    }\n                }\n            } catch (err) {\n                if (err.code !== \"404\") {\n                    throw err;\n                }\n            }\n        }\n        if (!jsi.attached && jsi.config.filter_subject === undefined && jsi.config.filter_subjects === undefined) {\n            jsi.config.filter_subject = subject;\n        }\n        jsi.deliver = jsi.config.deliver_subject || createInbox(this.nc.options.inboxPrefix);\n        return jsi;\n    }\n    _buildTypedSubscriptionOpts(jsi) {\n        const so = {};\n        so.adapter = msgAdapter(jsi.callbackFn === undefined, this.timeout);\n        so.ingestionFilterFn = JetStreamClientImpl.ingestionFn(jsi.ordered);\n        so.protocolFilterFn = (jm, ingest = false)=>{\n            const jsmi = jm;\n            if (isFlowControlMsg(jsmi.msg)) {\n                if (!ingest) {\n                    jsmi.msg.respond();\n                }\n                return false;\n            }\n            return true;\n        };\n        if (!jsi.mack && jsi.config.ack_policy !== AckPolicy.None) {\n            so.dispatchedFn = autoAckJsMsg;\n        }\n        if (jsi.callbackFn) {\n            so.callback = jsi.callbackFn;\n        }\n        so.max = jsi.max || 0;\n        so.queue = jsi.queue;\n        return so;\n    }\n    async _maybeCreateConsumer(jsi) {\n        if (jsi.attached) {\n            return;\n        }\n        if (jsi.isBind) {\n            throw new Error(`unable to bind - durable consumer ${jsi.config.durable_name} doesn't exist in ${jsi.stream}`);\n        }\n        jsi.config = Object.assign({\n            deliver_policy: DeliverPolicy.All,\n            ack_policy: AckPolicy.Explicit,\n            ack_wait: nanos(30 * 1000),\n            replay_policy: ReplayPolicy.Instant\n        }, jsi.config);\n        const ci = await this.consumerAPI.add(jsi.stream, jsi.config);\n        if (Array.isArray(jsi.config.filter_subjects && !Array.isArray(ci.config.filter_subjects))) {\n            throw new Error(`jetstream server doesn't support consumers with multiple filter subjects`);\n        }\n        jsi.name = ci.name;\n        jsi.config = ci.config;\n        jsi.last = ci;\n    }\n    static ingestionFn(ordered) {\n        return (jm, ctx)=>{\n            const jsub = ctx;\n            if (!jm) return {\n                ingest: false,\n                protocol: false\n            };\n            const jmi = jm;\n            if (!checkJsError(jmi.msg)) {\n                jsub.monitor?.work();\n            }\n            if (isHeartbeatMsg(jmi.msg)) {\n                const ingest = ordered ? jsub._checkHbOrderConsumer(jmi.msg) : true;\n                if (!ordered) {\n                    jsub.info.flow_control.heartbeat_count++;\n                }\n                return {\n                    ingest,\n                    protocol: true\n                };\n            } else if (isFlowControlMsg(jmi.msg)) {\n                jsub.info.flow_control.fc_count++;\n                return {\n                    ingest: true,\n                    protocol: true\n                };\n            }\n            const ingest = ordered ? jsub._checkOrderedConsumer(jm) : true;\n            return {\n                ingest,\n                protocol: false\n            };\n        };\n    }\n}\nclass NatsConnectionImpl {\n    options;\n    protocol;\n    draining;\n    listeners;\n    _services;\n    constructor(opts){\n        this.draining = false;\n        this.options = parseOptions(opts);\n        this.listeners = [];\n    }\n    static connect(opts = {}) {\n        return new Promise((resolve, reject)=>{\n            const nc = new NatsConnectionImpl(opts);\n            ProtocolHandler.connect(nc.options, nc).then((ph)=>{\n                nc.protocol = ph;\n                (async function() {\n                    for await (const s of ph.status()){\n                        nc.listeners.forEach((l)=>{\n                            l.push(s);\n                        });\n                    }\n                })();\n                resolve(nc);\n            }).catch((err)=>{\n                reject(err);\n            });\n        });\n    }\n    closed() {\n        return this.protocol.closed;\n    }\n    async close() {\n        await this.protocol.close();\n    }\n    _check(subject, sub, pub) {\n        if (this.isClosed()) {\n            throw NatsError.errorForCode(ErrorCode.ConnectionClosed);\n        }\n        if (sub && this.isDraining()) {\n            throw NatsError.errorForCode(ErrorCode.ConnectionDraining);\n        }\n        if (pub && this.protocol.noMorePublishing) {\n            throw NatsError.errorForCode(ErrorCode.ConnectionDraining);\n        }\n        subject = subject || \"\";\n        if (subject.length === 0) {\n            throw NatsError.errorForCode(ErrorCode.BadSubject);\n        }\n    }\n    publish(subject, data, options) {\n        this._check(subject, false, true);\n        this.protocol.publish(subject, data, options);\n    }\n    publishMessage(msg) {\n        return this.publish(msg.subject, msg.data, {\n            reply: msg.reply,\n            headers: msg.headers\n        });\n    }\n    respondMessage(msg) {\n        if (msg.reply) {\n            this.publish(msg.reply, msg.data, {\n                reply: msg.reply,\n                headers: msg.headers\n            });\n            return true;\n        }\n        return false;\n    }\n    subscribe(subject, opts = {}) {\n        this._check(subject, true, false);\n        const sub = new SubscriptionImpl(this.protocol, subject, opts);\n        this.protocol.subscribe(sub);\n        return sub;\n    }\n    _resub(s, subject, max) {\n        this._check(subject, true, false);\n        const si = s;\n        si.max = max;\n        if (max) {\n            si.max = max + si.received;\n        }\n        this.protocol.resub(si, subject);\n    }\n    requestMany(subject, data = Empty, opts = {\n        maxWait: 1000,\n        maxMessages: -1\n    }) {\n        const asyncTraces = !(this.protocol.options.noAsyncTraces || false);\n        try {\n            this._check(subject, true, true);\n        } catch (err) {\n            return Promise.reject(err);\n        }\n        opts.strategy = opts.strategy || RequestStrategy.Timer;\n        opts.maxWait = opts.maxWait || 1000;\n        if (opts.maxWait < 1) {\n            return Promise.reject(new NatsError(\"timeout\", ErrorCode.InvalidOption));\n        }\n        const qi = new QueuedIteratorImpl();\n        function stop(err) {\n            qi.push(()=>{\n                qi.stop(err);\n            });\n        }\n        function callback(err, msg) {\n            if (err || msg === null) {\n                stop(err === null ? undefined : err);\n            } else {\n                qi.push(msg);\n            }\n        }\n        if (opts.noMux) {\n            const stack = asyncTraces ? new Error().stack : null;\n            let max = typeof opts.maxMessages === \"number\" && opts.maxMessages > 0 ? opts.maxMessages : -1;\n            const sub = this.subscribe(createInbox(this.options.inboxPrefix), {\n                callback: (err, msg)=>{\n                    if (msg?.data?.length === 0 && msg?.headers?.status === ErrorCode.NoResponders) {\n                        err = NatsError.errorForCode(ErrorCode.NoResponders);\n                    }\n                    if (err) {\n                        if (stack) {\n                            err.stack += `\\n\\n${stack}`;\n                        }\n                        cancel(err);\n                        return;\n                    }\n                    callback(null, msg);\n                    if (opts.strategy === RequestStrategy.Count) {\n                        max--;\n                        if (max === 0) {\n                            cancel();\n                        }\n                    }\n                    if (opts.strategy === RequestStrategy.JitterTimer) {\n                        clearTimers();\n                        timer = setTimeout(()=>{\n                            cancel();\n                        }, 300);\n                    }\n                    if (opts.strategy === RequestStrategy.SentinelMsg) {\n                        if (msg && msg.data.length === 0) {\n                            cancel();\n                        }\n                    }\n                }\n            });\n            sub.requestSubject = subject;\n            sub.closed.then(()=>{\n                stop();\n            }).catch((err)=>{\n                qi.stop(err);\n            });\n            const cancel = (err)=>{\n                if (err) {\n                    qi.push(()=>{\n                        throw err;\n                    });\n                }\n                clearTimers();\n                sub.drain().then(()=>{\n                    stop();\n                }).catch((_err)=>{\n                    stop();\n                });\n            };\n            qi.iterClosed.then(()=>{\n                clearTimers();\n                sub?.unsubscribe();\n            }).catch((_err)=>{\n                clearTimers();\n                sub?.unsubscribe();\n            });\n            try {\n                this.publish(subject, data, {\n                    reply: sub.getSubject()\n                });\n            } catch (err) {\n                cancel(err);\n            }\n            let timer = setTimeout(()=>{\n                cancel();\n            }, opts.maxWait);\n            const clearTimers = ()=>{\n                if (timer) {\n                    clearTimeout(timer);\n                }\n            };\n        } else {\n            const rmo = opts;\n            rmo.callback = callback;\n            qi.iterClosed.then(()=>{\n                r.cancel();\n            }).catch((err)=>{\n                r.cancel(err);\n            });\n            const r = new RequestMany(this.protocol.muxSubscriptions, subject, rmo);\n            this.protocol.request(r);\n            try {\n                this.publish(subject, data, {\n                    reply: `${this.protocol.muxSubscriptions.baseInbox}${r.token}`,\n                    headers: opts.headers\n                });\n            } catch (err) {\n                r.cancel(err);\n            }\n        }\n        return Promise.resolve(qi);\n    }\n    request(subject, data, opts = {\n        timeout: 1000,\n        noMux: false\n    }) {\n        try {\n            this._check(subject, true, true);\n        } catch (err) {\n            return Promise.reject(err);\n        }\n        const asyncTraces = !(this.protocol.options.noAsyncTraces || false);\n        opts.timeout = opts.timeout || 1000;\n        if (opts.timeout < 1) {\n            return Promise.reject(new NatsError(\"timeout\", ErrorCode.InvalidOption));\n        }\n        if (!opts.noMux && opts.reply) {\n            return Promise.reject(new NatsError(\"reply can only be used with noMux\", ErrorCode.InvalidOption));\n        }\n        if (opts.noMux) {\n            const inbox = opts.reply ? opts.reply : createInbox(this.options.inboxPrefix);\n            const d = deferred();\n            const errCtx = asyncTraces ? new Error() : null;\n            const sub = this.subscribe(inbox, {\n                max: 1,\n                timeout: opts.timeout,\n                callback: (err, msg)=>{\n                    if (err) {\n                        if (errCtx && err.code !== ErrorCode.Timeout) {\n                            err.stack += `\\n\\n${errCtx.stack}`;\n                        }\n                        sub.unsubscribe();\n                        d.reject(err);\n                    } else {\n                        err = isRequestError(msg);\n                        if (err) {\n                            if (errCtx) {\n                                err.stack += `\\n\\n${errCtx.stack}`;\n                            }\n                            d.reject(err);\n                        } else {\n                            d.resolve(msg);\n                        }\n                    }\n                }\n            });\n            sub.requestSubject = subject;\n            this.protocol.publish(subject, data, {\n                reply: inbox,\n                headers: opts.headers\n            });\n            return d;\n        } else {\n            const r = new RequestOne(this.protocol.muxSubscriptions, subject, opts, asyncTraces);\n            this.protocol.request(r);\n            try {\n                this.publish(subject, data, {\n                    reply: `${this.protocol.muxSubscriptions.baseInbox}${r.token}`,\n                    headers: opts.headers\n                });\n            } catch (err) {\n                r.cancel(err);\n            }\n            const p = Promise.race([\n                r.timer,\n                r.deferred\n            ]);\n            p.catch(()=>{\n                r.cancel();\n            });\n            return p;\n        }\n    }\n    flush() {\n        if (this.isClosed()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.ConnectionClosed));\n        }\n        return this.protocol.flush();\n    }\n    drain() {\n        if (this.isClosed()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.ConnectionClosed));\n        }\n        if (this.isDraining()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.ConnectionDraining));\n        }\n        this.draining = true;\n        return this.protocol.drain();\n    }\n    isClosed() {\n        return this.protocol.isClosed();\n    }\n    isDraining() {\n        return this.draining;\n    }\n    getServer() {\n        const srv = this.protocol.getServer();\n        return srv ? srv.listen : \"\";\n    }\n    status() {\n        const iter = new QueuedIteratorImpl();\n        iter.iterClosed.then(()=>{\n            const idx = this.listeners.indexOf(iter);\n            this.listeners.splice(idx, 1);\n        });\n        this.listeners.push(iter);\n        return iter;\n    }\n    get info() {\n        return this.protocol.isClosed() ? undefined : this.protocol.info;\n    }\n    async context() {\n        const r = await this.request(`$SYS.REQ.USER.INFO`);\n        return r.json((key, value)=>{\n            if (key === \"time\") {\n                return new Date(Date.parse(value));\n            }\n            return value;\n        });\n    }\n    stats() {\n        return {\n            inBytes: this.protocol.inBytes,\n            outBytes: this.protocol.outBytes,\n            inMsgs: this.protocol.inMsgs,\n            outMsgs: this.protocol.outMsgs\n        };\n    }\n    async jetstreamManager(opts = {}) {\n        const adm = new JetStreamManagerImpl(this, opts);\n        if (opts.checkAPI !== false) {\n            try {\n                await adm.getAccountInfo();\n            } catch (err) {\n                const ne = err;\n                if (ne.code === ErrorCode.NoResponders) {\n                    ne.code = ErrorCode.JetStreamNotEnabled;\n                }\n                throw ne;\n            }\n        }\n        return adm;\n    }\n    jetstream(opts = {}) {\n        return new JetStreamClientImpl(this, opts);\n    }\n    getServerVersion() {\n        const info = this.info;\n        return info ? parseSemVer(info.version) : undefined;\n    }\n    async rtt() {\n        if (!this.protocol._closed && !this.protocol.connected) {\n            throw NatsError.errorForCode(ErrorCode.Disconnect);\n        }\n        const start = Date.now();\n        await this.flush();\n        return Date.now() - start;\n    }\n    get features() {\n        return this.protocol.features;\n    }\n    get services() {\n        if (!this._services) {\n            this._services = new ServicesFactory(this);\n        }\n        return this._services;\n    }\n    reconnect() {\n        if (this.isClosed()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.ConnectionClosed));\n        }\n        if (this.isDraining()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.ConnectionDraining));\n        }\n        return this.protocol.reconnect();\n    }\n}\nclass ServicesFactory {\n    nc;\n    constructor(nc){\n        this.nc = nc;\n    }\n    add(config) {\n        try {\n            const s = new ServiceImpl(this.nc, config);\n            return s.start();\n        } catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    client(opts, prefix) {\n        return new ServiceClientImpl(this.nc, opts, prefix);\n    }\n}\nclass KvStoredEntryImpl {\n    bucket;\n    sm;\n    prefixLen;\n    constructor(bucket, prefixLen, sm){\n        this.bucket = bucket;\n        this.prefixLen = prefixLen;\n        this.sm = sm;\n    }\n    get key() {\n        return this.sm.subject.substring(this.prefixLen);\n    }\n    get value() {\n        return this.sm.data;\n    }\n    get delta() {\n        return 0;\n    }\n    get created() {\n        return this.sm.time;\n    }\n    get revision() {\n        return this.sm.seq;\n    }\n    get operation() {\n        return this.sm.header.get(kvOperationHdr) || \"PUT\";\n    }\n    get length() {\n        const slen = this.sm.header.get(JsHeaders.MessageSizeHdr) || \"\";\n        if (slen !== \"\") {\n            return parseInt(slen, 10);\n        }\n        return this.sm.data.length;\n    }\n    json() {\n        return this.sm.json();\n    }\n    string() {\n        return this.sm.string();\n    }\n}\nclass KvJsMsgEntryImpl {\n    bucket;\n    key;\n    sm;\n    constructor(bucket, key, sm){\n        this.bucket = bucket;\n        this.key = key;\n        this.sm = sm;\n    }\n    get value() {\n        return this.sm.data;\n    }\n    get created() {\n        return new Date(millis(this.sm.info.timestampNanos));\n    }\n    get revision() {\n        return this.sm.seq;\n    }\n    get operation() {\n        return this.sm.headers?.get(kvOperationHdr) || \"PUT\";\n    }\n    get delta() {\n        return this.sm.info.pending;\n    }\n    get length() {\n        const slen = this.sm.headers?.get(JsHeaders.MessageSizeHdr) || \"\";\n        if (slen !== \"\") {\n            return parseInt(slen, 10);\n        }\n        return this.sm.data.length;\n    }\n    json() {\n        return this.sm.json();\n    }\n    string() {\n        return this.sm.string();\n    }\n}\nclass JetStreamSubscriptionImpl extends TypedSubscription {\n    js;\n    monitor;\n    constructor(js, subject, opts){\n        super(js.nc, subject, opts);\n        this.js = js;\n        this.monitor = null;\n        this.sub.closed.then(()=>{\n            if (this.monitor) {\n                this.monitor.cancel();\n            }\n        });\n    }\n    set info(info) {\n        this.sub.info = info;\n    }\n    get info() {\n        return this.sub.info;\n    }\n    _resetOrderedConsumer(sseq) {\n        if (this.info === null || this.sub.isClosed()) {\n            return;\n        }\n        const newDeliver = createInbox(this.js.nc.options.inboxPrefix);\n        const nci = this.js.nc;\n        nci._resub(this.sub, newDeliver);\n        const info = this.info;\n        info.config.name = nuid.next();\n        info.ordered_consumer_sequence.delivery_seq = 0;\n        info.flow_control.heartbeat_count = 0;\n        info.flow_control.fc_count = 0;\n        info.flow_control.consumer_restarts++;\n        info.deliver = newDeliver;\n        info.config.deliver_subject = newDeliver;\n        info.config.deliver_policy = DeliverPolicy.StartSequence;\n        info.config.opt_start_seq = sseq;\n        const req = {};\n        req.stream_name = this.info.stream;\n        req.config = info.config;\n        const subj = `${info.api.prefix}.CONSUMER.CREATE.${info.stream}`;\n        this.js._request(subj, req, {\n            retries: -1\n        }).then((v)=>{\n            const ci = v;\n            const jinfo = this.sub.info;\n            jinfo.last = ci;\n            this.info.config = ci.config;\n            this.info.name = ci.name;\n        }).catch((err)=>{\n            const nerr = new NatsError(`unable to recreate ordered consumer ${info.stream} at seq ${sseq}`, ErrorCode.RequestError, err);\n            this.sub.callback(nerr, {});\n        });\n    }\n    _maybeSetupHbMonitoring() {\n        const ns = this.info?.config?.idle_heartbeat || 0;\n        if (ns) {\n            this._setupHbMonitoring(millis(ns));\n        }\n    }\n    _setupHbMonitoring(millis, cancelAfter = 0) {\n        const opts = {\n            cancelAfter: 0,\n            maxOut: 2\n        };\n        if (cancelAfter) {\n            opts.cancelAfter = cancelAfter;\n        }\n        const sub = this.sub;\n        const handler = (v)=>{\n            const msg = newJsErrorMsg(409, `${Js409Errors.IdleHeartbeatMissed}: ${v}`, this.sub.subject);\n            const ordered = this.info?.ordered;\n            if (!ordered) {\n                this.sub.callback(null, msg);\n            } else {\n                if (!this.js.nc.protocol.connected) {\n                    return false;\n                }\n                const seq = this.info?.ordered_consumer_sequence?.stream_seq || 0;\n                this._resetOrderedConsumer(seq + 1);\n                this.monitor?.restart();\n                return false;\n            }\n            return !sub.noIterator;\n        };\n        this.monitor = new IdleHeartbeatMonitor(millis, handler, opts);\n    }\n    _checkHbOrderConsumer(msg) {\n        const rm = msg.headers.get(JsHeaders.ConsumerStalledHdr);\n        if (rm !== \"\") {\n            const nci = this.js.nc;\n            nci.publish(rm);\n        }\n        const lastDelivered = parseInt(msg.headers.get(JsHeaders.LastConsumerSeqHdr), 10);\n        const ordered = this.info.ordered_consumer_sequence;\n        this.info.flow_control.heartbeat_count++;\n        if (lastDelivered !== ordered.delivery_seq) {\n            this._resetOrderedConsumer(ordered.stream_seq + 1);\n        }\n        return false;\n    }\n    _checkOrderedConsumer(jm) {\n        const ordered = this.info.ordered_consumer_sequence;\n        const sseq = jm.info.streamSequence;\n        const dseq = jm.info.deliverySequence;\n        if (dseq != ordered.delivery_seq + 1) {\n            this._resetOrderedConsumer(ordered.stream_seq + 1);\n            return false;\n        }\n        ordered.delivery_seq = dseq;\n        ordered.stream_seq = sseq;\n        return true;\n    }\n    async destroy() {\n        if (!this.isClosed()) {\n            await this.drain();\n        }\n        const jinfo = this.sub.info;\n        const name = jinfo.config.durable_name || jinfo.name;\n        const subj = `${jinfo.api.prefix}.CONSUMER.DELETE.${jinfo.stream}.${name}`;\n        await jinfo.api._request(subj);\n    }\n    async consumerInfo() {\n        const jinfo = this.sub.info;\n        const name = jinfo.config.durable_name || jinfo.name;\n        const subj = `${jinfo.api.prefix}.CONSUMER.INFO.${jinfo.stream}.${name}`;\n        const ci = await jinfo.api._request(subj);\n        jinfo.last = ci;\n        return ci;\n    }\n}\nclass JetStreamPullSubscriptionImpl extends JetStreamSubscriptionImpl {\n    constructor(js, subject, opts){\n        super(js, subject, opts);\n    }\n    pull(opts = {\n        batch: 1\n    }) {\n        const { stream, config, name } = this.sub.info;\n        const consumer = config.durable_name ?? name;\n        const args = {};\n        args.batch = opts.batch || 1;\n        args.no_wait = opts.no_wait || false;\n        if ((opts.max_bytes ?? 0) > 0) {\n            const fv = this.js.nc.features.get(Feature.JS_PULL_MAX_BYTES);\n            if (!fv.ok) {\n                throw new Error(`max_bytes is only supported on servers ${fv.min} or better`);\n            }\n            args.max_bytes = opts.max_bytes;\n        }\n        let expires = 0;\n        if (opts.expires && opts.expires > 0) {\n            expires = opts.expires;\n            args.expires = nanos(expires);\n        }\n        let hb = 0;\n        if (opts.idle_heartbeat && opts.idle_heartbeat > 0) {\n            hb = opts.idle_heartbeat;\n            args.idle_heartbeat = nanos(hb);\n        }\n        if (hb && expires === 0) {\n            throw new Error(\"idle_heartbeat requires expires\");\n        }\n        if (hb > expires) {\n            throw new Error(\"expires must be greater than idle_heartbeat\");\n        }\n        if (this.info) {\n            if (this.monitor) {\n                this.monitor.cancel();\n            }\n            if (expires && hb) {\n                if (!this.monitor) {\n                    this._setupHbMonitoring(hb, expires);\n                } else {\n                    this.monitor._change(hb, expires);\n                }\n            }\n            const api = this.info.api;\n            const subj = `${api.prefix}.CONSUMER.MSG.NEXT.${stream}.${consumer}`;\n            const reply = this.sub.subject;\n            api.nc.publish(subj, api.jc.encode(args), {\n                reply: reply\n            });\n        }\n    }\n}\nfunction msgAdapter(iterator, ackTimeout) {\n    if (iterator) {\n        return iterMsgAdapter(ackTimeout);\n    } else {\n        return cbMsgAdapter(ackTimeout);\n    }\n}\nfunction cbMsgAdapter(ackTimeout) {\n    return (err, msg)=>{\n        if (err) {\n            return [\n                err,\n                null\n            ];\n        }\n        err = checkJsError(msg);\n        if (err) {\n            return [\n                err,\n                null\n            ];\n        }\n        return [\n            null,\n            toJsMsg(msg, ackTimeout)\n        ];\n    };\n}\nfunction iterMsgAdapter(ackTimeout) {\n    return (err, msg)=>{\n        if (err) {\n            return [\n                err,\n                null\n            ];\n        }\n        const ne = checkJsError(msg);\n        if (ne !== null) {\n            return [\n                hideNonTerminalJsErrors(ne),\n                null\n            ];\n        }\n        return [\n            null,\n            toJsMsg(msg, ackTimeout)\n        ];\n    };\n}\nfunction hideNonTerminalJsErrors(ne) {\n    if (ne !== null) {\n        switch(ne.code){\n            case ErrorCode.JetStream404NoMessages:\n            case ErrorCode.JetStream408RequestTimeout:\n                return null;\n            case ErrorCode.JetStream409:\n                if (isTerminal409(ne)) {\n                    return ne;\n                }\n                return null;\n            default:\n                return ne;\n        }\n    }\n    return null;\n}\nfunction autoAckJsMsg(data) {\n    if (data) {\n        data.ack();\n    }\n}\nfunction parseInfo(s) {\n    const tokens = s.split(\".\");\n    if (tokens.length === 9) {\n        tokens.splice(2, 0, \"_\", \"\");\n    }\n    if (tokens.length < 11 || tokens[0] !== \"$JS\" || tokens[1] !== \"ACK\") {\n        throw new Error(`not js message`);\n    }\n    const di = {};\n    di.domain = tokens[2] === \"_\" ? \"\" : tokens[2];\n    di.account_hash = tokens[3];\n    di.stream = tokens[4];\n    di.consumer = tokens[5];\n    di.redeliveryCount = parseInt(tokens[6], 10);\n    di.redelivered = di.redeliveryCount > 1;\n    di.streamSequence = parseInt(tokens[7], 10);\n    di.deliverySequence = parseInt(tokens[8], 10);\n    di.timestampNanos = parseInt(tokens[9], 10);\n    di.pending = parseInt(tokens[10], 10);\n    return di;\n}\nclass JsMsgImpl {\n    msg;\n    di;\n    didAck;\n    timeout;\n    constructor(msg, timeout){\n        this.msg = msg;\n        this.didAck = false;\n        this.timeout = timeout;\n    }\n    get subject() {\n        return this.msg.subject;\n    }\n    get sid() {\n        return this.msg.sid;\n    }\n    get data() {\n        return this.msg.data;\n    }\n    get headers() {\n        return this.msg.headers;\n    }\n    get info() {\n        if (!this.di) {\n            this.di = parseInfo(this.reply);\n        }\n        return this.di;\n    }\n    get redelivered() {\n        return this.info.redeliveryCount > 1;\n    }\n    get reply() {\n        return this.msg.reply || \"\";\n    }\n    get seq() {\n        return this.info.streamSequence;\n    }\n    doAck(payload) {\n        if (!this.didAck) {\n            this.didAck = !this.isWIP(payload);\n            this.msg.respond(payload);\n        }\n    }\n    isWIP(p) {\n        return p.length === 4 && p[0] === WPI[0] && p[1] === WPI[1] && p[2] === WPI[2] && p[3] === WPI[3];\n    }\n    async ackAck(opts) {\n        opts = opts || {};\n        opts.timeout = opts.timeout || this.timeout;\n        const d = deferred();\n        if (!this.didAck) {\n            this.didAck = true;\n            if (this.msg.reply) {\n                const mi = this.msg;\n                const proto = mi.publisher;\n                const trace = !(proto.options?.noAsyncTraces || false);\n                const r = new RequestOne(proto.muxSubscriptions, this.msg.reply, {\n                    timeout: opts.timeout\n                }, trace);\n                proto.request(r);\n                try {\n                    proto.publish(this.msg.reply, ACK, {\n                        reply: `${proto.muxSubscriptions.baseInbox}${r.token}`\n                    });\n                } catch (err) {\n                    r.cancel(err);\n                }\n                try {\n                    await Promise.race([\n                        r.timer,\n                        r.deferred\n                    ]);\n                    d.resolve(true);\n                } catch (err) {\n                    r.cancel(err);\n                    d.reject(err);\n                }\n            } else {\n                d.resolve(false);\n            }\n        } else {\n            d.resolve(false);\n        }\n        return d;\n    }\n    ack() {\n        this.doAck(ACK);\n    }\n    nak(millis) {\n        let payload = NAK;\n        if (millis) {\n            payload = StringCodec().encode(`-NAK ${JSON.stringify({\n                delay: nanos(millis)\n            })}`);\n        }\n        this.doAck(payload);\n    }\n    working() {\n        this.doAck(WPI);\n    }\n    next(subj, opts = {\n        batch: 1\n    }) {\n        const args = {};\n        args.batch = opts.batch || 1;\n        args.no_wait = opts.no_wait || false;\n        if (opts.expires && opts.expires > 0) {\n            args.expires = nanos(opts.expires);\n        }\n        const data = JSONCodec().encode(args);\n        const payload = DataBuffer.concat(NXT, SPACE, data);\n        const reqOpts = subj ? {\n            reply: subj\n        } : undefined;\n        this.msg.respond(payload, reqOpts);\n    }\n    term(reason = \"\") {\n        let term = TERM;\n        if (reason?.length > 0) {\n            term = StringCodec().encode(`+TERM ${reason}`);\n        }\n        this.doAck(term);\n    }\n    json() {\n        return this.msg.json();\n    }\n    string() {\n        return this.msg.string();\n    }\n}\n\n\n\nconst VERSION = \"1.29.2\";\nconst LANG = \"nats.ws\";\nclass WsTransport {\n    version;\n    lang;\n    closeError;\n    connected;\n    done;\n    socket;\n    options;\n    socketClosed;\n    encrypted;\n    peeked;\n    yields;\n    signal;\n    closedNotification;\n    constructor(){\n        this.version = VERSION;\n        this.lang = LANG;\n        this.connected = false;\n        this.done = false;\n        this.socketClosed = false;\n        this.encrypted = false;\n        this.peeked = false;\n        this.yields = [];\n        this.signal = deferred();\n        this.closedNotification = deferred();\n    }\n    async connect(server, options) {\n        const connected = false;\n        const connLock = deferred();\n        if (options.tls) {\n            connLock.reject(new NatsError(\"tls\", ErrorCode.InvalidOption));\n            return connLock;\n        }\n        this.options = options;\n        const u = server.src;\n        if (options.wsFactory) {\n            const { socket, encrypted } = await options.wsFactory(server.src, options);\n            this.socket = socket;\n            this.encrypted = encrypted;\n        } else {\n            this.encrypted = u.indexOf(\"wss://\") === 0;\n            this.socket = new WebSocket(u);\n        }\n        this.socket.binaryType = \"arraybuffer\";\n        this.socket.onopen = ()=>{\n            if (this.isDiscarded()) {\n                return;\n            }\n        };\n        this.socket.onmessage = (me)=>{\n            if (this.isDiscarded()) {\n                return;\n            }\n            this.yields.push(new Uint8Array(me.data));\n            if (this.peeked) {\n                this.signal.resolve();\n                return;\n            }\n            const t = DataBuffer.concat(...this.yields);\n            const pm = extractProtocolMessage(t);\n            if (pm !== \"\") {\n                const m = INFO.exec(pm);\n                if (!m) {\n                    if (options.debug) {\n                        console.error(\"!!!\", render(t));\n                    }\n                    connLock.reject(new Error(\"unexpected response from server\"));\n                    return;\n                }\n                try {\n                    const info = JSON.parse(m[1]);\n                    checkOptions(info, this.options);\n                    this.peeked = true;\n                    this.connected = true;\n                    this.signal.resolve();\n                    connLock.resolve();\n                } catch (err) {\n                    connLock.reject(err);\n                    return;\n                }\n            }\n        };\n        this.socket.onclose = (evt)=>{\n            if (this.isDiscarded()) {\n                return;\n            }\n            this.socketClosed = true;\n            let reason;\n            if (this.done) return;\n            if (!evt.wasClean) {\n                reason = new Error(evt.reason);\n            }\n            this._closed(reason);\n        };\n        this.socket.onerror = (e)=>{\n            if (this.isDiscarded()) {\n                return;\n            }\n            const evt = e;\n            const err = new NatsError(evt.message, ErrorCode.Unknown, new Error(evt.error));\n            if (!connected) {\n                connLock.reject(err);\n            } else {\n                this._closed(err);\n            }\n        };\n        return connLock;\n    }\n    disconnect() {\n        this._closed(undefined, true);\n    }\n    async _closed(err, internal = true) {\n        if (this.isDiscarded()) {\n            return;\n        }\n        if (!this.connected) return;\n        if (this.done) return;\n        this.closeError = err;\n        if (!err) {\n            while(!this.socketClosed && this.socket.bufferedAmount > 0){\n                await delay(100);\n            }\n        }\n        this.done = true;\n        try {\n            this.socket.close(err ? 1002 : 1000, err ? err.message : undefined);\n        } catch (err) {}\n        if (internal) {\n            this.closedNotification.resolve(err);\n        }\n    }\n    get isClosed() {\n        return this.done;\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n    async *iterate() {\n        while(true){\n            if (this.isDiscarded()) {\n                return;\n            }\n            if (this.yields.length === 0) {\n                await this.signal;\n            }\n            const yields = this.yields;\n            this.yields = [];\n            for(let i = 0; i < yields.length; i++){\n                if (this.options.debug) {\n                    console.info(`> ${render(yields[i])}`);\n                }\n                yield yields[i];\n            }\n            if (this.done) {\n                break;\n            } else if (this.yields.length === 0) {\n                yields.length = 0;\n                this.yields = yields;\n                this.signal = deferred();\n            }\n        }\n    }\n    isEncrypted() {\n        return this.connected && this.encrypted;\n    }\n    send(frame) {\n        if (this.isDiscarded()) {\n            return;\n        }\n        try {\n            this.socket.send(frame.buffer);\n            if (this.options.debug) {\n                console.info(`< ${render(frame)}`);\n            }\n            return;\n        } catch (err) {\n            if (this.options.debug) {\n                console.error(`!!! ${render(frame)}: ${err}`);\n            }\n        }\n    }\n    close(err) {\n        return this._closed(err, false);\n    }\n    closed() {\n        return this.closedNotification;\n    }\n    isDiscarded() {\n        if (this.done) {\n            this.discard();\n            return true;\n        }\n        return false;\n    }\n    discard() {\n        this.done = true;\n        try {\n            this.socket?.close();\n        } catch (_err) {}\n    }\n}\nfunction wsUrlParseFn(u, encrypted) {\n    const ut = /^(.*:\\/\\/)(.*)/;\n    if (!ut.test(u)) {\n        if (typeof encrypted === \"boolean\") {\n            u = `${encrypted === true ? \"https\" : \"http\"}://${u}`;\n        } else {\n            u = `https://${u}`;\n        }\n    }\n    let url = new URL(u);\n    const srcProto = url.protocol.toLowerCase();\n    if (srcProto === \"ws:\") {\n        encrypted = false;\n    }\n    if (srcProto === \"wss:\") {\n        encrypted = true;\n    }\n    if (srcProto !== \"https:\" && srcProto !== \"http\") {\n        u = u.replace(/^(.*:\\/\\/)(.*)/gm, \"$2\");\n        url = new URL(`http://${u}`);\n    }\n    let protocol;\n    let port;\n    const host = url.hostname;\n    const path = url.pathname;\n    const search = url.search || \"\";\n    switch(srcProto){\n        case \"http:\":\n        case \"ws:\":\n        case \"nats:\":\n            port = url.port || \"80\";\n            protocol = \"ws:\";\n            break;\n        case \"https:\":\n        case \"wss:\":\n        case \"tls:\":\n            port = url.port || \"443\";\n            protocol = \"wss:\";\n            break;\n        default:\n            port = url.port || encrypted === true ? \"443\" : \"80\";\n            protocol = encrypted === true ? \"wss:\" : \"ws:\";\n            break;\n    }\n    return `${protocol}//${host}:${port}${path}${search}`;\n}\nfunction connect(opts = {}) {\n    setTransportFactory({\n        defaultPort: 443,\n        urlParseFn: wsUrlParseFn,\n        factory: ()=>{\n            return new WsTransport();\n        }\n    });\n    return NatsConnectionImpl.connect(opts);\n}\n\n\n\n//# sourceURL=webpack:///./node_modules/nats.ws/esm/nats.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	__webpack_require__("../../src/foxlisp-web.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./rtc.js");
/******/ 	
/******/ })()
;