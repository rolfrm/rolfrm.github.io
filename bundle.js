/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../src/foxlisp-web.js":
/*!********************************!*\
  !*** ../../src/foxlisp-web.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! ./lisp */ \"../../src/lisp.js\")\n\nlet load_file = (filePath) => {\n\t\n\treturn fetch(filePath)\n\t \t\n\t\t  .then(response => {\n\t\t\tif (!response.ok) {\n\t\t\t\treturn \"(println 'file-not-found \\\"\" + filePath + \"\\\")\"\n\t\t\t}\n\t\t\treturn response.text()\n\t\t\t\n\t\t  })\n\t\t  \n}\n\nfunction WriteCodeToLog(code){\n\treturn;\n}\nwriteCodetoLog = WriteCodeToLog\nloadFileAsync = load_file\n\nconsole.log(\"foxlisp JS loaded!\")\n\n\n//# sourceURL=webpack:///../../src/foxlisp-web.js?");

/***/ }),

/***/ "../../src/lisp.js":
/*!*************************!*\
  !*** ../../src/lisp.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const parser = __webpack_require__(/*! ./lispy_parser */ \"../../src/lispy_parser.js\")\nconst lisp = __webpack_require__(/*! ./symbols */ \"../../src/symbols.js\")\n\n\nconsole.log(\"loading lispy\")\nfunction sym(x, jsname){\n    return lisp.sym(x, jsname)\n}\n\nfunction issym(x){\n\t return x && x.type == \"symbol\";\n}\n\n\nquotes = []\nquotes_lookup = new Map();\nfunction _getQuote(id) {\n    return quotes[id]\n}\ngetQuote = _getQuote\nfunction setQuote(newQuote){\n\t if(quotes_lookup.has(newQuote)) {\n\t\t  return quotes_lookup.get(newQuote);\n\t }\n    let id = quotes.length;\n    quotes.length += 1\n    quotes[id] = newQuote\n\tquotes_lookup.set(newQuote, id)\n    return id\n}\n\nlookupsym = lisp.getsym\ncar = (x) => x && x[0]\ncdr = (x) => x && x.slice(1)\nop_add = (x, y) => x + y\nop_sub = (x, y) => x - y\nop_div = (x, y) => x / y\nop_mul = (x, y) => x * y\nop_leftshift = (x, y) => x << y;\nop_rightshift = (x, y) => x >> y;\nop_xor = (x, y) => x ^ y;\nmod = (x, y) => x % y\nlen = (x) => (x && x.length) || 0\nlist = (...x) => x\nmakehashmap = () => new Map();\n__undefined = undefined\n\neq = (a, b) => a === b;\nslice = (a, n) => a && (a.length <= n ? null : a.slice(n));\nraise = (err) => {\n\t throw err;\n};\n\nusplice = (x) => ({type: \"unsplice\", value: x})\n\nloadfile = (x, loadcontext) => ({type: \"load\", value: x, loadcontext: loadcontext})\n\nmacroLookup = new Map();\n\nismacro = (x) => macroLookup.has(x)\n\nulist = (...x) => {\n\t let out = []\n\t for (let elem of x){\n\t\t  if(elem == undefined){\n\t\t\t\tthrow new Error(\"content is undefined\" + x);\n\t\t  }\n\t\t  if(typeof(elem) == \"object\" && elem.type == \"unsplice\"){\n\t\t\t\tfor (let elem2 of elem.value){\n\t\t\t\t\t out.push(elem2);\n\t\t\t\t}\n\t\t\t\t\n\t\t  }else{\n\t\t\t\tout.push(elem);\n\t\t  }\n\t }\n\t \n\t return out\n}\n\nfunction escapeString(x){\n\t return x.replace(/\"/g, '\"\"').replace(/\\n/g, '\\\\n')\n}\n\ngetsym = (s) => sym(s, null)\n\nfunction println_impl(obj){\n\t //console.log(\"print? \", Array.isArray(obj), obj)\n\t if(Array.isArray(obj)){\n\t\t  let strOut = \"\"\n\t\t  let first = true\n\t\t  strOut += \"(\"\n\t\t  for(let elem of obj){\n\t\t\t\tif(!first){\n\t\t\t\t\t strOut = strOut + \" \";\n\t\t\t\t}else{\n\t\t\t\t\t first = false;\n\t\t\t\t\t if(elem == quoteSym){\n\t\t\t\t\t\t  return \"'\" + println_impl(obj[1]);\n\t\t\t\t\t }\n\t\t\t\t}\n\t\t\t\tstrOut += println_impl(elem)\n\n\t\t  }\n\t\t  strOut += \")\"\n\t\t  return strOut;\n\t }else{\n\t\t  if(obj == undefined){\n\t\t\t\treturn \"undefined\"\n\t\t  }\n\t\t  if(obj == null){\n\t\t\t\treturn \"null\";\n\t\t  }\n\t\t  if(obj.type == \"symbol\"){\n\t\t\t\treturn obj.value;\n\t\t  }\n\t\t  return obj.toString()\n\t }\n}\n\nprintln = (...a) => {\n\t let combined = \"\"\n\t let first = true\n\t for(let elem of a){\n\t\t  if(!first){\n\t\t\t\tcombined = combined + \", \"\n\t\t  }else{\n\t\t\t\tfirst = false\n\t\t  }\n\t\t  combined = combined + println_impl(elem)\n\t }\n\t // print without newline:\n\t console.log(combined)\n\t return a[0]\n}\n\n__valueToString = (a) => println_impl(a);\n\nnth = (a, n) => a && (n >= a.length ? null : a[n])\nsetnth = (a, n, v) => a[n] = v\ngetnth = (a, n) => a[n]\nmakemap_ = () => ({type: \"lisp-object\"})\nput = (obj, name, value) =>  obj[name.jsname ? name.jsname : name] = value\nget = (obj, name) => obj[name.jsname ? name.jsname : name]\ncharcode = (a) => a.charCodeAt(0)\nstrfromchar = (...a) => String.fromCharCode(...a)\nreverse = (a) => a.slice().reverse()\n_op_gte = (a,b) => a >= b\n_op_lte = (a,b) => b >= a\n_op_lt = (a,b) => a < b\n_op_gt = (a,b) => a > b\nconcat = (...lst)=> len(lst) == 0 ? [] : lst[0].concat(...lst.slice(1))\n__makesym = (a) => sym(a)\n\n\nconst loopSym = sym(\"loop\");\nconst notSym = sym(\"not\");\nconst setSym = sym(\"set\");\nconst letSym = sym(\"let\");\nconst prognSym = sym(\"progn\");\nconst ifSym = sym(\"if\");\nconst lambdaSym = sym(\"_lambda\");\nconst defMacroSym = sym(\"setmacro\");\nconst orSym = sym(\"or\");\nconst andSym = sym(\"and\");\nconst blockSym = sym(\"block\");\nconst returnFromSym = sym(\"return-from\")\nconst jsSym = sym(\"%js\")\nconst quoteSym = lisp.quote_sym;\nconst quasiQuoteSym = lisp.quasiquote_sym;\nconst quasiUnQuoteSym = lisp.quasiunquote_sym;\nconst quasiUnQuoteSpliceSym = lisp.quasiunquotesplice_sym;\nconst restSym = sym(\"&rest\")\nconst typeOfSym = sym(\"type-of\")\nconst declareSym = sym(\"declare\")\nconst defvarSym = sym(\"defvar\");\nconst defConstSym = sym(\"defconstant\");\nconst handleErrorsSym = sym(\"handle-errors\")\nconst loop_sym = sym(\"loop\")\n\nfunction quotedJs(code){\n\t if(Array.isArray(code)){\n\t\t  const innerCode = code.map(elem => quotedJs(elem)).join(',');\n\t\t  return `[${innerCode}]`\n\t }\n\t if(code.type == \"symbol\"){\n\t\t  return `getsym(\"${escapeString(code.value)}\")`\n\t }\n\t if(typeof(code) == 'string'){\n\t\t  return `\"${escapeString(code)}\"`\n\t }\t \n\t return code.toString();\n\n}\n\nfunction unquoteToJs(code){\n\t if(code == null){\n\t\t  return \"null\"\n\t }\n\t if(Array.isArray(code)){\n\t\t  if(code[0] == quasiQuoteSym){\n\t\t\t\t\n\t\t\t\treturn quotedJs(code) \n\t\t  }\n\t\t  if(code[0] == quasiUnQuoteSpliceSym){\n\t\t\t\t\n\t\t\t\treturn `usplice(${lispCompile(code[1])})`;\n\t\t  }\n\t\t  if(code[0] == quasiUnQuoteSym){\n\t\t\t\treturn lispCompile(code[1])\n\t\t  }\n\t\t  const innerCode = code.map(elem => unquoteToJs(elem)).join(',');\n\t\t  return `ulist(${innerCode})`;\n\t }\n\t if(code.type == \"symbol\"){\n\t\t  return `getsym(\"${escapeString(code.value)}\")`\n\t }\n\t if(typeof(code) == 'string'){\n\t\t  return `\"${escapeString(code)}\"`\n\t }\n\t \n\t \n\t return code.toString();\n}\n\n\nfunction lispCompileLet(variables, body){\n\t const  varCode = variables.map(updateExpr => {\n\t\t  if(updateExpr.length != 2){\n\t\t\t\tthrow new Error(\"The expression (xyz) is malformed.\" + updateExpr.toString());\n\t\t  }\n        const [left, right] = updateExpr;\n        code = `let ${left.jsname} = (${lispCompile(right)})`\n        return code;\n    }).join(';');\n    \n\t if(body.length == 1){\n\t\t  if(variables.length == 0){\n\t\t\t\treturn `${lispCompile(body[0])}`\n\t\t  }\n\t\t  return `(() => {${varCode};return ${lispCompile(body[0])};})()`\n\t }\n\n\t let bodyCode = \"\"\n\t if(variables.length > 0){\n\t \t  bodyCode += \"(() => {\"+ varCode + \";return \";\n\t }else{\n\t\t  bodyCode += \"(\";\n\t }\n\t \n\t for(let i in body){\n\t\t  if(i > 0){\n\t\t\t\tbodyCode = bodyCode + \",\"\n\t\t  }\n\t\t  bodyCode = bodyCode + `${lispCompile(body[i])}`;\n\t\t  \n\t }\n\t if(body.length == 0){\n\t\t  bodyCode += \"null\";\n\t }\n\t if(variables.length > 0){\n\t\t  bodyCode = bodyCode + \"})()\";\n\t }else{\n\t\t  bodyCode = bodyCode + \")\";\n\t }\n\t \n\t return bodyCode;\n}\nlmbmark = (id, f) => {\n\tf.assoc_id = id;\n\treturn f;\n}\n\nlet associd = 0;\nlet assoc = {}\n                ///\\/\\*lmb#(\\d+)\\*\\//\nconst markRegex = /\\/\\*lmb#(\\d+)\\*\\/\\(/g;\nlet codeStack = []\nfunction lispCompile(code) {\n\t try{\n\t\t  codeStack.push(code);\n\t if(typeof(code) == \"number\"){\n        return code\n\t }\n\t if(typeof(code) == \"string\"){\n\t\t  code = code.replaceAll(\"\\\"\", \"\\\\\\\"\");\n\t\t  code = code.replaceAll(\"\\n\", \"\\\\n\");\n\t\t  return `\\\"${code}\\\"`;\n\t }\n\t if(code == undefined){\n\t\t  return \"undefined\"\n\t }\n    if (code.type == \"symbol\"){\n        return code.jsname\n    }\n    if(code.length == 0) {\n        return \"null\"\n    }\n\n    const [operator, ...operands] = code;\n    switch (operator) {\n    case loopSym:\n        const [condition, ...update] = operands;\n        \n\t\t  const updateCode = lispCompileLet([], update);\n\t\t  const conditionCode = lispCompile(condition);\n        return `(() => {let tmp = null; for (;${conditionCode};) { tmp = ${updateCode} };return tmp})()`;\n    case orSym:\n        {\n\t\t\t\tconst combined = operands.map(op => lispCompile(op)).join(\"||\")\n\t\t\t\treturn `(${combined})`\n        }\n    case andSym:\n        {\n\t\t\t\tconst combined = operands.map(op => lispCompile(op)).join(\"&&\")\n\t\t\t\treturn `(${combined})`\n        }\n\t case jsSym:\n\t\t  {\n\t\t\tlet outstr = \"\";\n\t\t\tfor (let x of operands) {\n\t\t\t\tif (typeof(x) == \"string\") {\n                   outstr += x;\n\t\t\t\t}else{\n                   outstr += lispCompile(x)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn outstr;\n\t\t\t\t\n\t\t  }\n\t case typeOfSym:\n\t\t  {\n\t\t\t\treturn `typeof ${lispCompile(operands[0])}`;\n\t\t  }\n\t\t  \n    case blockSym:{\n        const [sym, ...body] = operands;\n        const bodyCode = body.map(updateExpr => 'tmp =(' + lispCompile(updateExpr) +')').join(';');\n        \n        return `(()=>{let tmp = null;const ${sym.jsname} = {};\n         try{${bodyCode}}catch(ex){if(ex.id === ${sym.jsname}){return ex.value;}else{throw ex;}} return tmp;})()`\n    }\n    case returnFromSym:{\n        const [sym, value] = operands;\n        \n        return `(()=> {throw {id:${sym.jsname}, value:${lispCompile(value)}, type: \"return-from\" }})()`;\n    }\n    case lambdaSym:\n        {\n\n            const [args, ...body] = operands;\n\t\t\t// find invalid args    \n\t\t\tfor(let arg of args){\n\t\t\t\tif(arg.type != \"symbol\"){\n\t\t\t\t\t throw new Error(\"Invalid argument in lambda: \" + arg + \" in \" + println_impl(code));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\tconst restIndex = args.indexOf(restSym)\n\t\t\t\tlet argstr = args.map(arg => arg.jsname).join(\",\")\n\t\t\t\tif(restIndex != -1){\n\t\t\t\t\t argstr = args.slice(0, restIndex).map(arg => arg.jsname).concat([\"...\" + args[restIndex + 1].jsname]).join(\",\");\n\t\t\t\t}\n\t\t\t\n\t\t\tassoc[associd] = operands\n            if(body.length == 1) {\n                let lmb = `/*lmb#${associd++}*/((${argstr}) => ${lispCompile(body[0])})`;\n\t\t\t\treturn lmb\n            }\n\n            const bodyCode = body.map(updateExpr => 'tmp =(' + lispCompile(updateExpr) +')').join(';');\n            let lmb = `/*lmb#${associd++}*/((${argstr}) => {let tmp = null; ${bodyCode}; return tmp;})`;\n\t\t\t\t\n\t\t\t\treturn lmb\n\t\t  }\n\t case prognSym:\n\t\t  return lispCompileLet([], operands)\n    case notSym:\n        {\n            const [left] = operands;\n            return `(!${lispCompile(left)})`;\n        }\n    case quoteSym:\n        {\n            const [quoted] = operands\n\t\t\t\tif(issym(quoted)){\n\t\t\t\t\t return `getsym(\\\"${quoted.value}\\\")`\n\t\t\t\t}\n\t\t\t\t\n            const id = setQuote(quoted)\n            return `getQuote(${id})`\n        }\n\t case quasiQuoteSym:\n\t\t  {\n\t\t\t\tconst [quoted] = operands\n\t\t\t\tconst code = unquoteToJs(quoted)\n\t\t\t\treturn code;\n\n\t\t  }\n\t\t  \n    case defvarSym:\n        {\n\t\t\t    \n\t\t\t\tconst [sym, code] = operands;\n\t\t\t\tlet valueCode = lispCompile(code);\n\t\t\t\tif (typeof(valueCode) == \"string\"){\n\t\t\t\t\tvalueCode = valueCode.replace(markRegex, 'lmbmark($1,');\n\t\t\t\t}\n\t\t\t\tconst code2 = `${sym.jsname} = ${valueCode}`;\n\t\t\t\t//WriteCodeToLog(code2 + \";\")\n\t\t\t\tlet result = eval(code2);\n\t\t\t\tconsole.log(\"result: \", valueCode)\n\t\t\t\tif(typeof(result) == \"function\" && result.assoc_id){\n\t\t\t\t\tresult.lispname = sym\n\t\t\t\t\tresult.lispargs = assoc[result.assoc_id][0]\n\t\t\t\t}\n\t\t\t\treturn `${sym.jsname}`\n        }\n\t case defConstSym:\n        {\n\t\t\t\tconst [sym, code] = operands;\n\t\t\t\tconst valueCode = lispCompile(code);\n\t\t\t\teval(`${sym.jsname} = ${valueCode}`)\n\t\t\t\treturn `${sym.jsname}`\n        }\n    case defMacroSym:\n        {\n\t\t\t\tconst [sym, code] = operands;\n\t\t\t\tconst macroCode = lispCompile(code)\n\t\t\t\tmacroValue = eval(macroCode);\n\t\t\t\t\n\t\t\t\tmacroLookup.set(sym, macroValue)\n\t\t\t\t\n\t\t\t\treturn \"1\"\n        }\n    case setSym:\n        const [variable, value] = operands;\n        return `${lispCompile(variable)} = ${lispCompile(value)}`;\n    case letSym: {\n\t\t  const [variables, ...body] = operands\n\t\t  return lispCompileLet(variables, body)\n\t }\n    case ifSym:\n        {\n\t\t\t\tconst [condition, thenClause, elseClause] = operands;\n\t\t\t\tconst conditionCode = lispCompile(condition);\n\t\t\t\tconst thenCode = lispCompile(thenClause);\n\t\t\t\tconst elseCode = elseClause == null ? \"null\" : lispCompile(elseClause);\n\t\t\t\treturn `(${conditionCode} ? ${thenCode} : ${elseCode})`\n        }\n\t case handleErrorsSym:\n\t\t  {\n\t\t\t\t\n\t\t\t\tconst [body, handler] = operands;\n\n\t\t\t\tconst [varSym, handlerBody] = handler;\n\t\t\t\tconst bodyCode = lispCompile(body);\n\t\t\t\tconst handlerBodyCode = lispCompile(handlerBody);\n\t\t\t\treturn `(()=>{try{return ${bodyCode}}catch(${varSym.jsname}){ if(${varSym.jsname}.type === \"return-from\") throw ${varSym.jsname}; return ${handlerBodyCode}}})()`\n\t\t\t\t\n\t\t  }\n        // Add more cases for other operators as needed\n\t\t  \n    default:\n\t\t  if(operator == undefined){\n\t\t\t\tthrow new Error(\"undefined operator in \", code)\n\t\t  }\n        if (macroLookup.has(operator)) {\n\t\t\t\tlet macroFcn = macroLookup.get(operator)\n\t\t\t\tlet newcode = null;\n\t\t\t\t\n\t\t\t\tnewcode = macroFcn(...operands)\n\t\t\t\t\n\t\t\t\treturn lispCompile(newcode)\n        }\n        args = operands.map(op => lispCompile(op)).join(\",\")\n        \n        return `${operator.jsname}(${args})`;\n    }\n\t }finally{\n\t\t  codeStack.pop()\n\t }\n}\n\nlisp_reader = function(code) {\n\treturn code;\n}\n\nfunction lispCompileAst(ast){\n    js = \"'use strict'; return \"+ lispCompile(lisp_reader(ast))\n    //console.log(\"ast: \", ast)\n    //console.log(\"js: \", js)\n    return Function(js)\n}\n\nfunction lispCompileString(code) {\n    const [ast, next] = parser.ParseLisp(code)\n    if (next == null){\n        throw \"unable to parse code\"\n    }\n    return lispCompileAst(ast)\n}\n\nfunction evalLisp(code){\n\t let fn = lispCompileAst(code)\n\t return fn();\n}\n\neval2 = evalLisp\nloadFileAsync = null\nloadcontext = \"\"\nasync function LispEvalBlock(code, file) {\n\t\n\t for(;;){\n\t\t  \n\t\t  const [ast, next] = parser.ParseLisp(code)\n\t\t  //console.log(\">>>>\", code.slice(0, code.length- next.length) )\n\t\t  if (ast == parser.UnexpectedEOF){\n\t\t\t\talert(\"!\")\n\t\t\t\tthrow new Error(\"Unexpected EOF\" + file == nil ? \"\" : \" in file \" + file)\n\t\t  }\n\t\t  if (next == null){\n\t\t\t\treturn;\n\t\t  }\n\t\t  code = next;\n\t\t  js = \"'use strict'; return \"+ lispCompile(lisp_reader(ast))\n\t\t  //WriteCodeToLog(\"()=> \" + js +\";\")\n\t\t  println([\"value code:\", ast, \"=>\", js])\n\t\t  \n\t\t  let f = Function(js)\n\t\t  const result = f();\n\t\t  if(result != null && typeof(result) == \"object\" && result.type == \"load\"){\n\n\t\t\t\tconst data = await loadFileAsync(result.value)\n\t\t\t\tconst prevContext = loadcontext\n\t\t\t\tloadcontext = result.value\n\t\t\t\tLispEvalBlock(data + \"\\n\" + next, result.value)\n\t\t\t\tloadcontext = prevContext\n\t\t\t\treturn;\n\t\t  }\n\t }\n}\n\nfunction do_eval(code){\n\t return eval?.(code)\n}\n\njs_eval = do_eval\n\n\n\n\nlisp.lisp.eval = evalLisp\nlisp.lisp.LispEvalBlock = LispEvalBlock\n\nmodule.exports = {\n\t EvalLisp: evalLisp,\n\t LispEvalBlock: LispEvalBlock,\n\t lispCompile: lispCompile\n};\n\n\n//# sourceURL=webpack:///../../src/lisp.js?");

/***/ }),

/***/ "../../src/lispy_parser.js":
/*!*********************************!*\
  !*** ../../src/lispy_parser.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const lisp = __webpack_require__(/*! ./symbols */ \"../../src/symbols.js\")\n\nclass ParserCondition {\n    constructor(err) {\n      this.err = err;\n    }\n  \n    toString() {\n      return \"Error parsing lisp code\";\n    }\n  }\n  \n  class NothingParsed2 {}\n  \n  const NothingParsed = new ParserCondition();\n  const UnexpectedEOF = new ParserCondition();\n  \n  // Helper function to skip whitespace\n  function skipWhitespace(input) {\n    while (input.length > 0 && /\\s|\\n|\\t/.test(input[0])) {\n      input = input.slice(1);\n    }\n    return input\n  }\n\n  function skipComment(input) {\n    if(input.length == 0 || input[0] != ';'){\n      return input;\n    }\n    while (input.length > 0 && input[0] !== '\\n') {\n            \n      input = input.slice(1);\n    }\n    if (input.length > 0) {\n      input = input.slice(1);\n    }\n    return input;\n  }\n\n  function skipCommentAndWhitespace(input){\n    while(true){\n      const input1 = input;\n      input = skipComment(skipWhitespace(input))\n      if(input == input1){\n        return input;\n      }\n    }\n  }\n\n  \n  // Helper function to parse a number\n  function parseNumber(input) {\n    let value = \"\";\n    let isFloat = false;\n    let isNegative = false;\n    if(input[0] == '-'){\n      isNegative = true;\n      input = input.slice(1);\n    }\n    if(input[0] == '+'){\n      input = input.slice(1)\n    }\n  \n    while (input.length > 0 && (/\\d/.test(input[0]) || (!isFloat && input[0] === '.'))) {\n      value += input[0];\n      if (input[0] === '.') {\n        isFloat = true;\n      }\n      input = input.slice(1);\n    }\n  \n    if (value === \"\") {\n      return [null, null];\n    }\n  \n    if (input.length > 0) {\n      const nextchr = input[0];\n      if (/\\s|\\)|\\(/.test(nextchr)) {\n  \n      } else {\n        return [null, null];\n      }\n    }\n  \n    if (isFloat) {\n      const num = parseFloat(value);\n      if (isNaN(num)) {\n        return [null, null];\n      }\n      if(isNegative){\n        return [-num, input];  \n      }\n      return [num, input];\n    }\n  \n    const num = parseInt(value, 10);\n    if (isNaN(num)) {\n      return [null, null];\n    }\n    if(isNegative){\n      return [-num, input];  \n    }\n    return [num, input];  \n  }\n  \n  function parseString(input) {\n    if (input.length === 0 || input[0] !== '\"') {\n      return [null, null];\n    }\n  \n    input = input.slice(1); // Consume opening quote\n    let value = \"\";\n    let escaped = false;\n  \n    while (input.length > 0) {\n      const char = input[0];\n      input = input.slice(1);\n  \n      if (char === '\\\\' && !escaped) {\n        escaped = true;\n        continue;\n      }\n  \n      if (char === '\"' && !escaped) {\n        // Closing quote found\n        return [value, input];\n      }\n  \n      value += char;\n      escaped = false;\n    }\n  \n    return [null, null]; // Unclosed string\n  }\n  \n  // ParseLisp function\n  function ParseLisp(input) {\n    \n    // Parsing loop\n    while (true) {\n      input = skipCommentAndWhitespace(input);\n      if (input.length === 0) {\n        \n        return [NothingParsed, null];\n      }\n      \n      switch (input[0]) {\n        \n        case '(':\n          \n          input = skipCommentAndWhitespace(input.slice(1));\n          \n          if(input[0] == ')'){  \n            return [[], input.slice(1)];\n          }\n          let out = []\n          for(;;){\n            const [result,next] = ParseLisp(input)\n            if(next){\n              input = next;\n              out.push(result)\n              input = skipCommentAndWhitespace(input);\n\t\t\t\t\t if(input[0] == ')'){\n\t\t\t\t\t\t  Object.freeze(out)\n\t\t\t\t\t\t  return [out, input.slice(1)];\n\t\t\t\t\t }\n            }else{\n              return [UnexpectedEOF, null]\n            }\n          }\n          break;\n        case ':':\n          {\n            // Parse keyword\n            const [r, next] = ParseLisp(input.slice(1));\n            return [[lisp.quote_sym, r], next]\n          }\n\n        break;\n        case '\\'':\n          {\n            // Parse quote\n\n            const [r, next] = ParseLisp(input.slice(1));\n            return [[lisp.quote_sym, r], next]\n          }\n\t\tcase '`':\n\t\t\t {\n\t\t\t\t  const [r, next] = ParseLisp(input.slice(1));\n              return [[lisp.quasiquote_sym, r], next]\n\n\t\t\t }\n\t\tcase ',':\n\t\t\t {\n\t\t\t\t  if(input[1] == '@'){\n\t\t\t\t\t\tconst [r, next] = ParseLisp(input.slice(2));\n\t\t\t\t\t\treturn [[lisp.quasiunquotesplice_sym, r], next]\n\t\t\t\t  }\n\t\t\t\t  const [r, next] = ParseLisp(input.slice(1));\n              return [[lisp.quasiunquote_sym, r], next]\n\n\t\t\t }\n      case '\"':\n          return parseString(input);\n\n  \n        default:\n          \n          const [num, next] = parseNumber(input);\n  \n          if (next) {\n            return [num, next];\n          }\n          \n          // parse symbol\n          value = \"\"\n          while (input.length > 0 && !/\\s|\\n|\\t|\\(|\\)/.test(input[0])) {\n            value += input[0];\n            input = input.slice(1);\n          }\n          if (value === \"\"){\n            return [null, null]\n          }\n           \n          s = lisp.sym(value);\n          return [s, input]          \n      }\n    }\n  }\n  \n  module.exports = {\n    ParseLisp: ParseLisp,\n    UnexpectedEOF: UnexpectedEOF\n  };\n\n\n//# sourceURL=webpack:///../../src/lispy_parser.js?");

/***/ }),

/***/ "../../src/symbols.js":
/*!****************************!*\
  !*** ../../src/symbols.js ***!
  \****************************/
/***/ ((module) => {

eval("\nlisp = { symbolName: {}, symbols: [] }\nconst reserved = {\n\t\"true\": true, \"false\": true, \"null\": true, \"case\": true,\n\t\"tmp\": true, \"undefined\": true, \"new\": true, \"eval\": true\n}\n\nconst sanitizedLookup = {}\nconst sanitizedLookupRev = {}\n\nnameid = 0;\nfunction sanitizeSymbolName(name) {\n\tif (name in sanitizedLookup) {\n\t\treturn sanitizedLookup[name]\n\t}\n\n\tconst sanitized = name.replace(/[^\\.a-zA-Z0-9_]/g, '_')\n\n\tisreserved = reserved[name];\n\n\tif (sanitized == name && !isreserved)\n\t\treturn sanitized;\n\n\tif (sanitized in sanitizedLookupRev || isreserved) {\n\t\tfor (i = 0; true; i = i + 1) {\n\t\t\tconst test = `_${sanitized}_${i}`\n\t\t\tif (test in sanitizedLookupRev) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsanitizedLookup[name] = test\n\t\t\tsanitizedLookupRev[test] = name\n\t\t\treturn test;\n\t\t}\n\t}\n\n\tsanitizedLookup[name] = sanitized\n\tsanitizedLookupRev[sanitized] = name\n\treturn sanitized;\n\n}\n\nfunction getsym(str) {\n\treturn lisp.symbolName[str]\n}\n\n\nfunction sym(str, jsname) {\n\tif (!lisp.symbolName[str]) {\n\t\tif (jsname == null) {\n\t\t\tjsname = str;\n\t\t\tjsname = sanitizeSymbolName(jsname)\n\t\t}\n\n\t\tconst symbol = {\n\t\t\ttype: \"symbol\",\n\t\t\tvalue: str,\n\t\t\tjsname: jsname\n\t\t};\n\t\tObject.freeze(symbol)\n\n\t\tlisp.symbolName[str] = symbol;\n\t\tlisp.symbols.push(symbol);\n\t}\n\treturn lisp.symbolName[str];\n}\nquote_sym = sym(\"quote\");\nquasiquote_sym = sym(\"quasiquote\")\nquasiunquote_sym = sym(\"quasiunquote\")\nquasiunquotesplice_sym = sym(\"quasiunquote-splice\")\n\nmodule.exports = {\n\tsym: sym,\n\tgetsym: getsym,\n\tlisp: lisp,\n\tquote_sym: quote_sym,\n\tquasiquote_sym: quasiquote_sym,\n\tquasiunquote_sym: quasiunquote_sym,\n\tquasiunquotesplice_sym: quasiunquotesplice_sym\n};\n\n\n//# sourceURL=webpack:///../../src/symbols.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("../../src/foxlisp-web.js");
/******/ 	
/******/ })()
;